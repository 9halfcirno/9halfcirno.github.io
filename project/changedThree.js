//! For license information please see webgl_loader_mmd_audio.js.LICENSE.txt */ 
var mmdinfo = {
        model: {
            file: "model/琪露诺/cirno.pmx",
            scale: {
                x: 1.5,
                y: -1.5,
                z: 1.5
            },
            size: 1.5
        },
        an: {
            camera: "an/wavefile_camera.vmd",
            model: "an/wavefile_v2.vmd"
        },
        audio: "wavefile_short cirno.mp3"
    }

let fillInput = function() {
    document.getElementById('model').value = mmdinfo.model.file;
    document.getElementById('audio').value = mmdinfo.audio;
    document.getElementById('anmodel').value = mmdinfo.an.model;
    document.getElementById('ancamera').value = mmdinfo.an.camera;
    document.getElementById('size').value = mmdinfo.model.size;
};

fillInput();

function updateMMDinfo(){
    mmdinfo.model.file = document.getElementById('model').value;
    mmdinfo.audio = document.getElementById('audio').value;
    mmdinfo.an.model = document.getElementById('anmodel').value;
    mmdinfo.an.camera = document.getElementById('ancamera').value;
    let size = document.getElementById('size').value;
    mmdinfo.model.scale.x = size;
    mmdinfo.model.scale.y = size;
    mmdinfo.model.scale.z = size;
    mmdinfo.model.scale.size = size;
}

const sp = {
    ctrlCamera(c) {
        return undefined;
    }
}

// cam = new THREE.camera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
// cam.position.set(0, 25, 75);

    ! function(t, e) {
        "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.webgl_loader_mmd_audio = e() : t.webgl_loader_mmd_audio = e()
    }(globalThis, (() => (() => {
        var t = {
                266: (t, e, i) => {
                    "use strict";
                    i.d(e, {
                        $: () => C
                    });
                    var n = i(979);
                    const r = new n.PTz,
                        s = new n.Pq0,
                        a = new n.Pq0,
                        o = new n.Pq0,
                        l = new n.Pq0,
                        h = new n.Pq0,
                        c = new n.PTz,
                        u = new n.Pq0,
                        d = new n.Pq0,
                        p = new n.Pq0,
                        m = new n.kn4;
                    class f {
                        constructor(t, e = []) {
                            this.mesh = t, this.iks = e, this._valid()
                        }
                        update() {
                            const t = this.iks;
                            for (let e = 0, i = t.length; e < i; e++) this.updateOne(t[e]);
                            return this
                        }
                        updateOne(t) {
                            const e = this.mesh.skeleton.bones,
                                i = Math,
                                n = e[t.effector],
                                m = e[t.target];
                            s.setFromMatrixPosition(m.matrixWorld);
                            const f = t.links,
                                g = void 0 !== t.iteration ? t.iteration : 1;
                            for (let m = 0; m < g; m++) {
                                let m = !1;
                                for (let g = 0, v = f.length; g < v; g++) {
                                    const v = e[f[g].index];
                                    if (!1 === f[g].enabled) break;
                                    const _ = f[g].limitation,
                                        y = f[g].rotationMin,
                                        x = f[g].rotationMax;
                                    v.matrixWorld.decompose(h, c, u), c.invert(), o.setFromMatrixPosition(n.matrixWorld), l.subVectors(o, h), l.applyQuaternion(c), l.normalize(), a.subVectors(s, h), a.applyQuaternion(c), a.normalize();
                                    let M = a.dot(l);
                                    if (M > 1 ? M = 1 : M < -1 && (M = -1), M = i.acos(M), !(M < 1e-5)) {
                                        if (void 0 !== t.minAngle && M < t.minAngle && (M = t.minAngle), void 0 !== t.maxAngle && M > t.maxAngle && (M = t.maxAngle), d.crossVectors(l, a), d.normalize(), r.setFromAxisAngle(d, M), v.quaternion.multiply(r), void 0 !== _) {
                                            let t = v.quaternion.w;
                                            t > 1 && (t = 1);
                                            const e = i.sqrt(1 - t * t);
                                            v.quaternion.set(_.x * e, _.y * e, _.z * e, t)
                                        }
                                        void 0 !== y && v.rotation.setFromVector3(p.setFromEuler(v.rotation).max(y)), void 0 !== x && v.rotation.setFromVector3(p.setFromEuler(v.rotation).min(x)), v.updateMatrixWorld(!0), m = !0
                                    }
                                }
                                if (!m) break
                            }
                            return this
                        }
                        createHelper(t) {
                            return new _(this.mesh, this.iks, t)
                        }
                        _valid() {
                            const t = this.iks,
                                e = this.mesh.skeleton.bones;
                            for (let i = 0, n = t.length; i < n; i++) {
                                const n = t[i],
                                    r = e[n.effector],
                                    s = n.links;
                                let a, o;
                                a = r;
                                for (let t = 0, i = s.length; t < i; t++) o = e[s[t].index], a.parent !== o && console.warn("THREE.CCDIKSolver: bone " + a.name + " is not the child of bone " + o.name), a = o
                            }
                        }
                    }

                    function g(t, e) {
                        return p.setFromMatrixPosition(t.matrixWorld).applyMatrix4(e)
                    }

                    function v(t, e, i, n) {
                        const r = g(i, n);
                        t[3 * e + 0] = r.x, t[3 * e + 1] = r.y, t[3 * e + 2] = r.z
                    }
                    class _ extends n.B69 {
                        constructor(t, e = [], i = .25) {
                            super(), this.root = t, this.iks = e, this.matrix.copy(t.matrixWorld), this.matrixAutoUpdate = !1, this.sphereGeometry = new n.Gu$(i, 16, 8), this.targetSphereMaterial = new n.V9B({
                                color: new n.Q1f(16746632),
                                depthTest: !1,
                                depthWrite: !1,
                                transparent: !0
                            }), this.effectorSphereMaterial = new n.V9B({
                                color: new n.Q1f(8978312),
                                depthTest: !1,
                                depthWrite: !1,
                                transparent: !0
                            }), this.linkSphereMaterial = new n.V9B({
                                color: new n.Q1f(8947967),
                                depthTest: !1,
                                depthWrite: !1,
                                transparent: !0
                            }), this.lineMaterial = new n.mrM({
                                color: new n.Q1f(16711680),
                                depthTest: !1,
                                depthWrite: !1,
                                transparent: !0
                            }), this._init()
                        }
                        updateMatrixWorld(t) {
                            const e = this.root;
                            if (this.visible) {
                                let t = 0;
                                const i = this.iks,
                                    n = e.skeleton.bones;
                                m.copy(e.matrixWorld).invert();
                                for (let e = 0, r = i.length; e < r; e++) {
                                    const r = i[e],
                                        s = n[r.target],
                                        a = n[r.effector],
                                        o = this.children[t++],
                                        l = this.children[t++];
                                    o.position.copy(g(s, m)), l.position.copy(g(a, m));
                                    for (let e = 0, i = r.links.length; e < i; e++) {
                                        const i = n[r.links[e].index];
                                        this.children[t++].position.copy(g(i, m))
                                    }
                                    const h = this.children[t++],
                                        c = h.geometry.attributes.position.array;
                                    v(c, 0, s, m), v(c, 1, a, m);
                                    for (let t = 0, e = r.links.length; t < e; t++) v(c, t + 2, n[r.links[t].index], m);
                                    h.geometry.attributes.position.needsUpdate = !0
                                }
                            }
                            this.matrix.copy(e.matrixWorld), super.updateMatrixWorld(t)
                        }
                        dispose() {
                            this.sphereGeometry.dispose(), this.targetSphereMaterial.dispose(), this.effectorSphereMaterial.dispose(), this.linkSphereMaterial.dispose(), this.lineMaterial.dispose();
                            const t = this.children;
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e];
                                i.isLine && i.geometry.dispose()
                            }
                        }
                        _init() {
                            const t = this,
                                e = this.iks;

                            function i(e) {
                                return new n.N1A(function(t) {
                                    const e = new n.LoY,
                                        i = new Float32Array(3 * (2 + t.links.length));
                                    return e.setAttribute("position", new n.THS(i, 3)), e
                                }(e), t.lineMaterial)
                            }
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r];
                                this.add(new n.eaF(t.sphereGeometry, t.targetSphereMaterial)), this.add(new n.eaF(t.sphereGeometry, t.effectorSphereMaterial));
                                for (let e = 0, i = s.links.length; e < i; e++) this.add(new n.eaF(t.sphereGeometry, t.linkSphereMaterial));
                                this.add(i(s))
                            }
                        }
                    }
                    class y {
                        constructor(t, e, i = [], r = {}) {
                            if ("undefined" == typeof Ammo) throw new Error("THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js");
                            this.manager = new x, this.mesh = t, this.unitStep = void 0 !== r.unitStep ? r.unitStep : 1 / 65, this.maxStepNum = void 0 !== r.maxStepNum ? r.maxStepNum : 3, this.gravity = new n.Pq0(0, -98, 0), void 0 !== r.gravity && this.gravity.copy(r.gravity), this.world = void 0 !== r.world ? r.world : null, this.bodies = [], this.constraints = [], this._init(t, e, i)
                        }
                        update(t) {
                            const e = this.manager,
                                i = this.mesh;
                            let n = !1;
                            const r = e.allocThreeVector3(),
                                s = e.allocThreeQuaternion(),
                                a = e.allocThreeVector3();
                            let o;
                            return i.matrixWorld.decompose(r, s, a), 1 === a.x && 1 === a.y && 1 === a.z || (n = !0), n && (o = i.parent, null !== o && (i.parent = null), a.copy(this.mesh.scale), i.scale.set(1, 1, 1), i.updateMatrixWorld(!0)), this._updateRigidBodies(), this._stepSimulation(t), this._updateBones(), n && (null !== o && (i.parent = o), i.scale.copy(a)), e.freeThreeVector3(a), e.freeThreeQuaternion(s), e.freeThreeVector3(r), this
                        }
                        reset() {
                            for (let t = 0, e = this.bodies.length; t < e; t++) this.bodies[t].reset();
                            return this
                        }
                        warmup(t) {
                            for (let e = 0; e < t; e++) this.update(1 / 60);
                            return this
                        }
                        setGravity(t) {
                            return this.world.setGravity(new Ammo.btVector3(t.x, t.y, t.z)), this.gravity.copy(t), this
                        }
                        createHelper() {
                            return new E(this.mesh, this)
                        }
                        _init(t, e, i) {
                            const n = this.manager,
                                r = t.parent;
                            null !== r && (t.parent = null);
                            const s = n.allocThreeVector3(),
                                a = n.allocThreeQuaternion(),
                                o = n.allocThreeVector3();
                            s.copy(t.position), a.copy(t.quaternion), o.copy(t.scale), t.position.set(0, 0, 0), t.quaternion.set(0, 0, 0, 1), t.scale.set(1, 1, 1), t.updateMatrixWorld(!0), null === this.world && (this.world = this._createWorld(), this.setGravity(this.gravity)), this._initRigidBodies(e), this._initConstraints(i), null !== r && (t.parent = r), t.position.copy(s), t.quaternion.copy(a), t.scale.copy(o), t.updateMatrixWorld(!0), this.reset(), n.freeThreeVector3(s), n.freeThreeQuaternion(a), n.freeThreeVector3(o)
                        }
                        _createWorld() {
                            const t = new Ammo.btDefaultCollisionConfiguration,
                                e = new Ammo.btCollisionDispatcher(t),
                                i = new Ammo.btDbvtBroadphase,
                                n = new Ammo.btSequentialImpulseConstraintSolver;
                            return new Ammo.btDiscreteDynamicsWorld(e, i, n, t)
                        }
                        _initRigidBodies(t) {
                            for (let e = 0, i = t.length; e < i; e++) this.bodies.push(new M(this.mesh, this.world, t[e], this.manager))
                        }
                        _initConstraints(t) {
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e],
                                    n = this.bodies[i.rigidBodyIndex1],
                                    r = this.bodies[i.rigidBodyIndex2];
                                this.constraints.push(new b(this.mesh, this.world, n, r, i, this.manager))
                            }
                        }
                        _stepSimulation(t) {
                            const e = this.unitStep;
                            let i = t,
                                n = 1 + (t / e | 0);
                            i < e && (i = e, n = 1), n > this.maxStepNum && (n = this.maxStepNum), this.world.stepSimulation(i, n, e)
                        }
                        _updateRigidBodies() {
                            for (let t = 0, e = this.bodies.length; t < e; t++) this.bodies[t].updateFromBone()
                        }
                        _updateBones() {
                            for (let t = 0, e = this.bodies.length; t < e; t++) this.bodies[t].updateBone()
                        }
                    }
                    class x {
                        constructor() {
                            this.threeVector3s = [], this.threeMatrix4s = [], this.threeQuaternions = [], this.threeEulers = [], this.transforms = [], this.quaternions = [], this.vector3s = []
                        }
                        allocThreeVector3() {
                            return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new n.Pq0
                        }
                        freeThreeVector3(t) {
                            this.threeVector3s.push(t)
                        }
                        allocThreeMatrix4() {
                            return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new n.kn4
                        }
                        freeThreeMatrix4(t) {
                            this.threeMatrix4s.push(t)
                        }
                        allocThreeQuaternion() {
                            return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new n.PTz
                        }
                        freeThreeQuaternion(t) {
                            this.threeQuaternions.push(t)
                        }
                        allocThreeEuler() {
                            return this.threeEulers.length > 0 ? this.threeEulers.pop() : new n.O9p
                        }
                        freeThreeEuler(t) {
                            this.threeEulers.push(t)
                        }
                        allocTransform() {
                            return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform
                        }
                        freeTransform(t) {
                            this.transforms.push(t)
                        }
                        allocQuaternion() {
                            return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion
                        }
                        freeQuaternion(t) {
                            this.quaternions.push(t)
                        }
                        allocVector3() {
                            return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3
                        }
                        freeVector3(t) {
                            this.vector3s.push(t)
                        }
                        setIdentity(t) {
                            t.setIdentity()
                        }
                        getBasis(t) {
                            var e = this.allocQuaternion();
                            return t.getBasis().getRotation(e), e
                        }
                        getBasisAsMatrix3(t) {
                            var e = this.getBasis(t),
                                i = this.quaternionToMatrix3(e);
                            return this.freeQuaternion(e), i
                        }
                        getOrigin(t) {
                            return t.getOrigin()
                        }
                        setOrigin(t, e) {
                            t.getOrigin().setValue(e.x(), e.y(), e.z())
                        }
                        copyOrigin(t, e) {
                            var i = e.getOrigin();
                            this.setOrigin(t, i)
                        }
                        setBasis(t, e) {
                            t.setRotation(e)
                        }
                        setBasisFromMatrix3(t, e) {
                            var i = this.matrix3ToQuaternion(e);
                            this.setBasis(t, i), this.freeQuaternion(i)
                        }
                        setOriginFromArray3(t, e) {
                            t.getOrigin().setValue(e[0], e[1], e[2])
                        }
                        setOriginFromThreeVector3(t, e) {
                            t.getOrigin().setValue(e.x, e.y, e.z)
                        }
                        setBasisFromArray3(t, e) {
                            var i = this.allocThreeQuaternion(),
                                n = this.allocThreeEuler();
                            n.set(e[0], e[1], e[2]), this.setBasisFromThreeQuaternion(t, i.setFromEuler(n)), this.freeThreeEuler(n), this.freeThreeQuaternion(i)
                        }
                        setBasisFromThreeQuaternion(t, e) {
                            var i = this.allocQuaternion();
                            i.setX(e.x), i.setY(e.y), i.setZ(e.z), i.setW(e.w), this.setBasis(t, i), this.freeQuaternion(i)
                        }
                        multiplyTransforms(t, e) {
                            var i = this.allocTransform();
                            this.setIdentity(i);
                            var n = this.getBasisAsMatrix3(t),
                                r = this.getBasisAsMatrix3(e),
                                s = this.getOrigin(t),
                                a = this.getOrigin(e),
                                o = this.multiplyMatrix3ByVector3(n, a),
                                l = this.addVector3(o, s);
                            this.setOrigin(i, l);
                            var h = this.multiplyMatrices3(n, r);
                            return this.setBasisFromMatrix3(i, h), this.freeVector3(o), this.freeVector3(l), i
                        }
                        inverseTransform(t) {
                            var e = this.allocTransform(),
                                i = this.getBasisAsMatrix3(t),
                                n = this.getOrigin(t),
                                r = this.transposeMatrix3(i),
                                s = this.negativeVector3(n),
                                a = this.multiplyMatrix3ByVector3(r, s);
                            return this.setOrigin(e, a), this.setBasisFromMatrix3(e, r), this.freeVector3(s), this.freeVector3(a), e
                        }
                        multiplyMatrices3(t, e) {
                            var i = [],
                                n = this.rowOfMatrix3(t, 0),
                                r = this.rowOfMatrix3(t, 1),
                                s = this.rowOfMatrix3(t, 2),
                                a = this.columnOfMatrix3(e, 0),
                                o = this.columnOfMatrix3(e, 1),
                                l = this.columnOfMatrix3(e, 2);
                            return i[0] = this.dotVectors3(n, a), i[1] = this.dotVectors3(n, o), i[2] = this.dotVectors3(n, l), i[3] = this.dotVectors3(r, a), i[4] = this.dotVectors3(r, o), i[5] = this.dotVectors3(r, l), i[6] = this.dotVectors3(s, a), i[7] = this.dotVectors3(s, o), i[8] = this.dotVectors3(s, l), this.freeVector3(n), this.freeVector3(r), this.freeVector3(s), this.freeVector3(a), this.freeVector3(o), this.freeVector3(l), i
                        }
                        addVector3(t, e) {
                            var i = this.allocVector3();
                            return i.setValue(t.x() + e.x(), t.y() + e.y(), t.z() + e.z()), i
                        }
                        dotVectors3(t, e) {
                            return t.x() * e.x() + t.y() * e.y() + t.z() * e.z()
                        }
                        rowOfMatrix3(t, e) {
                            var i = this.allocVector3();
                            return i.setValue(t[3 * e + 0], t[3 * e + 1], t[3 * e + 2]), i
                        }
                        columnOfMatrix3(t, e) {
                            var i = this.allocVector3();
                            return i.setValue(t[e + 0], t[e + 3], t[e + 6]), i
                        }
                        negativeVector3(t) {
                            var e = this.allocVector3();
                            return e.setValue(-t.x(), -t.y(), -t.z()), e
                        }
                        multiplyMatrix3ByVector3(t, e) {
                            var i = this.allocVector3(),
                                n = this.rowOfMatrix3(t, 0),
                                r = this.rowOfMatrix3(t, 1),
                                s = this.rowOfMatrix3(t, 2),
                                a = this.dotVectors3(n, e),
                                o = this.dotVectors3(r, e),
                                l = this.dotVectors3(s, e);
                            return i.setValue(a, o, l), this.freeVector3(n), this.freeVector3(r), this.freeVector3(s), i
                        }
                        transposeMatrix3(t) {
                            var e = [];
                            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], e
                        }
                        quaternionToMatrix3(t) {
                            var e = [],
                                i = t.x(),
                                n = t.y(),
                                r = t.z(),
                                s = t.w(),
                                a = i * i,
                                o = n * n,
                                l = r * r,
                                h = i * n,
                                c = n * r,
                                u = r * i,
                                d = i * s,
                                p = n * s,
                                m = r * s;
                            return e[0] = 1 - 2 * (o + l), e[1] = 2 * (h - m), e[2] = 2 * (u + p), e[3] = 2 * (h + m), e[4] = 1 - 2 * (l + a), e[5] = 2 * (c - d), e[6] = 2 * (u - p), e[7] = 2 * (c + d), e[8] = 1 - 2 * (a + o), e
                        }
                        matrix3ToQuaternion(t) {
                            var e, i, n, r, s, a = t[0] + t[4] + t[8];
                            a > 0 ? (s = .25 * (e = 2 * Math.sqrt(a + 1)), i = (t[7] - t[5]) / e, n = (t[2] - t[6]) / e, r = (t[3] - t[1]) / e) : t[0] > t[4] && t[0] > t[8] ? (e = 2 * Math.sqrt(1 + t[0] - t[4] - t[8]), s = (t[7] - t[5]) / e, i = .25 * e, n = (t[1] + t[3]) / e, r = (t[2] + t[6]) / e) : t[4] > t[8] ? (e = 2 * Math.sqrt(1 + t[4] - t[0] - t[8]), s = (t[2] - t[6]) / e, i = (t[1] + t[3]) / e, n = .25 * e, r = (t[5] + t[7]) / e) : (e = 2 * Math.sqrt(1 + t[8] - t[0] - t[4]), s = (t[3] - t[1]) / e, i = (t[2] + t[6]) / e, n = (t[5] + t[7]) / e, r = .25 * e);
                            var o = this.allocQuaternion();
                            return o.setX(i), o.setY(n), o.setZ(r), o.setW(s), o
                        }
                    }
                    class M {
                        constructor(t, e, i, n) {
                            this.mesh = t, this.world = e, this.params = i, this.manager = n, this.body = null, this.bone = null, this.boneOffsetForm = null, this.boneOffsetFormInverse = null, this._init()
                        }
                        reset() {
                            return this._setTransformFromBone(), this
                        }
                        updateFromBone() {
                            return -1 !== this.params.boneIndex && 0 === this.params.type && this._setTransformFromBone(), this
                        }
                        updateBone() {
                            return 0 === this.params.type || -1 === this.params.boneIndex || (this._updateBoneRotation(), 1 === this.params.type && this._updateBonePosition(), this.bone.updateMatrixWorld(!0), 2 === this.params.type && this._setPositionFromBone()), this
                        }
                        _init() {
                            const t = this.manager,
                                e = this.params,
                                i = this.mesh.skeleton.bones,
                                r = -1 === e.boneIndex ? new n.$Kf : i[e.boneIndex],
                                s = function(t) {
                                    switch (t.shapeType) {
                                        case 0:
                                            return new Ammo.btSphereShape(t.width);
                                        case 1:
                                            return new Ammo.btBoxShape(new Ammo.btVector3(t.width, t.height, t.depth));
                                        case 2:
                                            return new Ammo.btCapsuleShape(t.width, t.height);
                                        default:
                                            throw new Error("unknown shape type " + t.shapeType)
                                    }
                                }(e),
                                a = 0 === e.type ? 0 : e.weight,
                                o = t.allocVector3();
                            o.setValue(0, 0, 0), 0 !== a && s.calculateLocalInertia(a, o);
                            const l = t.allocTransform();
                            t.setIdentity(l), t.setOriginFromArray3(l, e.position), t.setBasisFromArray3(l, e.rotation);
                            const h = t.allocThreeVector3(),
                                c = t.allocTransform();
                            t.setIdentity(c), t.setOriginFromThreeVector3(c, r.getWorldPosition(h));
                            const u = t.multiplyTransforms(c, l),
                                d = new Ammo.btDefaultMotionState(u),
                                p = new Ammo.btRigidBodyConstructionInfo(a, d, s, o);
                            p.set_m_friction(e.friction), p.set_m_restitution(e.restitution);
                            const m = new Ammo.btRigidBody(p);
                            0 === e.type && (m.setCollisionFlags(2 | m.getCollisionFlags()), m.setActivationState(4)), m.setDamping(e.positionDamping, e.rotationDamping), m.setSleepingThresholds(0, 0), this.world.addRigidBody(m, 1 << e.groupIndex, e.groupTarget), this.body = m, this.bone = r, this.boneOffsetForm = l, this.boneOffsetFormInverse = t.inverseTransform(l), t.freeVector3(o), t.freeTransform(u), t.freeTransform(c), t.freeThreeVector3(h)
                        }
                        _getBoneTransform() {
                            const t = this.manager,
                                e = t.allocThreeVector3(),
                                i = t.allocThreeQuaternion(),
                                n = t.allocThreeVector3();
                            this.bone.matrixWorld.decompose(e, i, n);
                            const r = t.allocTransform();
                            t.setOriginFromThreeVector3(r, e), t.setBasisFromThreeQuaternion(r, i);
                            const s = t.multiplyTransforms(r, this.boneOffsetForm);
                            return t.freeTransform(r), t.freeThreeVector3(n), t.freeThreeQuaternion(i), t.freeThreeVector3(e), s
                        }
                        _getWorldTransformForBone() {
                            const t = this.manager,
                                e = this.body.getCenterOfMassTransform();
                            return t.multiplyTransforms(e, this.boneOffsetFormInverse)
                        }
                        _setTransformFromBone() {
                            const t = this.manager,
                                e = this._getBoneTransform();
                            this.body.setCenterOfMassTransform(e), this.body.getMotionState().setWorldTransform(e), t.freeTransform(e)
                        }
                        _setPositionFromBone() {
                            const t = this.manager,
                                e = this._getBoneTransform(),
                                i = t.allocTransform();
                            this.body.getMotionState().getWorldTransform(i), t.copyOrigin(i, e), this.body.setCenterOfMassTransform(i), this.body.getMotionState().setWorldTransform(i), t.freeTransform(i), t.freeTransform(e)
                        }
                        _updateBoneRotation() {
                            const t = this.manager,
                                e = this._getWorldTransformForBone(),
                                i = t.getBasis(e),
                                n = t.allocThreeQuaternion(),
                                r = t.allocThreeQuaternion(),
                                s = t.allocThreeQuaternion();
                            n.set(i.x(), i.y(), i.z(), i.w()), r.setFromRotationMatrix(this.bone.matrixWorld), r.conjugate(), r.multiply(n), s.setFromRotationMatrix(this.bone.matrix), this.bone.quaternion.copy(r.multiply(s).normalize()), t.freeThreeQuaternion(n), t.freeThreeQuaternion(r), t.freeThreeQuaternion(s), t.freeQuaternion(i), t.freeTransform(e)
                        }
                        _updateBonePosition() {
                            const t = this.manager,
                                e = this._getWorldTransformForBone(),
                                i = t.allocThreeVector3(),
                                n = t.getOrigin(e);
                            i.set(n.x(), n.y(), n.z()), this.bone.parent && this.bone.parent.worldToLocal(i), this.bone.position.copy(i), t.freeThreeVector3(i), t.freeTransform(e)
                        }
                    }
                    class b {
                        constructor(t, e, i, n, r, s) {
                            this.mesh = t, this.world = e, this.bodyA = i, this.bodyB = n, this.params = r, this.manager = s, this.constraint = null, this._init()
                        }
                        _init() {
                            const t = this.manager,
                                e = this.params,
                                i = this.bodyA,
                                n = this.bodyB,
                                r = t.allocTransform();
                            t.setIdentity(r), t.setOriginFromArray3(r, e.position), t.setBasisFromArray3(r, e.rotation);
                            const s = t.allocTransform(),
                                a = t.allocTransform();
                            i.body.getMotionState().getWorldTransform(s), n.body.getMotionState().getWorldTransform(a);
                            const o = t.inverseTransform(s),
                                l = t.inverseTransform(a),
                                h = t.multiplyTransforms(o, r),
                                c = t.multiplyTransforms(l, r),
                                u = new Ammo.btGeneric6DofSpringConstraint(i.body, n.body, h, c, !0),
                                d = t.allocVector3(),
                                p = t.allocVector3(),
                                m = t.allocVector3(),
                                f = t.allocVector3();
                            d.setValue(e.translationLimitation1[0], e.translationLimitation1[1], e.translationLimitation1[2]), p.setValue(e.translationLimitation2[0], e.translationLimitation2[1], e.translationLimitation2[2]), m.setValue(e.rotationLimitation1[0], e.rotationLimitation1[1], e.rotationLimitation1[2]), f.setValue(e.rotationLimitation2[0], e.rotationLimitation2[1], e.rotationLimitation2[2]), u.setLinearLowerLimit(d), u.setLinearUpperLimit(p), u.setAngularLowerLimit(m), u.setAngularUpperLimit(f);
                            for (let t = 0; t < 3; t++) 0 !== e.springPosition[t] && (u.enableSpring(t, !0), u.setStiffness(t, e.springPosition[t]));
                            for (let t = 0; t < 3; t++) 0 !== e.springRotation[t] && (u.enableSpring(t + 3, !0), u.setStiffness(t + 3, e.springRotation[t]));
                            if (void 0 !== u.setParam)
                                for (let t = 0; t < 6; t++) u.setParam(2, .475, t);
                            this.world.addConstraint(u, !0), this.constraint = u, t.freeTransform(r), t.freeTransform(s), t.freeTransform(a), t.freeTransform(o), t.freeTransform(l), t.freeTransform(h), t.freeTransform(c), t.freeVector3(d), t.freeVector3(p), t.freeVector3(m), t.freeVector3(f)
                        }
                    }
                    const S = new n.Pq0,
                        w = new n.PTz,
                        A = new n.Pq0,
                        T = new n.kn4;
                    class E extends n.B69 {
                        constructor(t, e) {
                            super(), this.root = t, this.physics = e, this.matrix.copy(t.matrixWorld), this.matrixAutoUpdate = !1, this.materials = [], this.materials.push(new n.V9B({
                                color: new n.Q1f(16746632),
                                wireframe: !0,
                                depthTest: !1,
                                depthWrite: !1,
                                opacity: .25,
                                transparent: !0
                            })), this.materials.push(new n.V9B({
                                color: new n.Q1f(8978312),
                                wireframe: !0,
                                depthTest: !1,
                                depthWrite: !1,
                                opacity: .25,
                                transparent: !0
                            })), this.materials.push(new n.V9B({
                                color: new n.Q1f(8947967),
                                wireframe: !0,
                                depthTest: !1,
                                depthWrite: !1,
                                opacity: .25,
                                transparent: !0
                            })), this._init()
                        }
                        dispose() {
                            const t = this.materials,
                                e = this.children;
                            for (let e = 0; e < t.length; e++) t[e].dispose();
                            for (let t = 0; t < e.length; t++) {
                                const i = e[t];
                                i.isMesh && i.geometry.dispose()
                            }
                        }
                        updateMatrixWorld(t) {
                            var e = this.root;
                            if (this.visible) {
                                var i = this.physics.bodies;
                                T.copy(e.matrixWorld).decompose(S, w, A).compose(S, w, A.set(1, 1, 1)).invert();
                                for (var n = 0, r = i.length; n < r; n++) {
                                    var s = i[n].body,
                                        a = this.children[n],
                                        o = s.getCenterOfMassTransform(),
                                        l = o.getOrigin(),
                                        h = o.getRotation();
                                    a.position.set(l.x(), l.y(), l.z()).applyMatrix4(T), a.quaternion.setFromRotationMatrix(T).multiply(w.set(h.x(), h.y(), h.z(), h.w()))
                                }
                            }
                            this.matrix.copy(e.matrixWorld).decompose(S, w, A).compose(S, w, A.set(1, 1, 1)), super.updateMatrixWorld(t)
                        }
                        _init() {
                            var t = this.physics.bodies;

                            function e(t) {
                                switch (t.shapeType) {
                                    case 0:
                                        return new n.Gu$(t.width, 16, 8);
                                    case 1:
                                        return new n.iNn(2 * t.width, 2 * t.height, 2 * t.depth, 8, 8, 8);
                                    case 2:
                                        return new n.qU7(t.width, t.height, 8, 16);
                                    default:
                                        return null
                                }
                            }
                            for (var i = 0, r = t.length; i < r; i++) {
                                var s = t[i].params;
                                this.add(new n.eaF(e(s), this.materials[s.type]))
                            }
                        }
                    }
                    class C {
                        constructor(t = {}) {
                            this.meshes = [], this.camera = null, this.cameraTarget = new n.B69, this.cameraTarget.name = "target", this.audio = null, this.audioManager = null, this.objects = new WeakMap, this.configuration = {
                                sync: void 0 === t.sync || t.sync,
                                afterglow: void 0 !== t.afterglow ? t.afterglow : 0,
                                resetPhysicsOnLoop: void 0 === t.resetPhysicsOnLoop || t.resetPhysicsOnLoop,
                                pmxAnimation: void 0 !== t.pmxAnimation && t.pmxAnimation
                            }, this.enabled = {
                                animation: !0,
                                ik: !0,
                                grant: !0,
                                physics: !0,
                                cameraAnimation: !0
                            }, this.onBeforePhysics = function() {}, this.sharedPhysics = !1, this.masterPhysics = null
                        }
                        add(t, e = {}) {
                            if (t.isSkinnedMesh) this._addMesh(t, e);
                            else if (t.isCamera) this._setupCamera(t, e);
                            else {
                                if ("Audio" !== t.type) throw new Error("THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
                                this._setupAudio(t, e)
                            }
                            return this.configuration.sync && this._syncDuration(), this
                        }
                        remove(t) {
                            if (t.isSkinnedMesh) this._removeMesh(t);
                            else if (t.isCamera) this._clearCamera(t);
                            else {
                                if ("Audio" !== t.type) throw new Error("THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
                                this._clearAudio(t)
                            }
                            return this.configuration.sync && this._syncDuration(), this
                        }
                        update(t) {
                            null !== this.audioManager && this.audioManager.control(t);
                            for (let e = 0; e < this.meshes.length; e++) this._animateMesh(this.meshes[e], t);
                            return this.sharedPhysics && this._updateSharedPhysics(t), null !== this.camera && this._animateCamera(this.camera, t), this
                        }
                        pose(t, e, i = {}) {
                            !1 !== i.resetPose && t.pose();
                            const r = t.skeleton.bones,
                                s = e.bones,
                                a = {};
                            for (let t = 0, e = r.length; t < e; t++) a[r[t].name] = t;
                            const o = new n.Pq0,
                                l = new n.PTz;
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t],
                                    i = a[e.name];
                                if (void 0 === i) continue;
                                const n = r[i];
                                n.position.add(o.fromArray(e.translation)), n.quaternion.multiply(l.fromArray(e.quaternion))
                            }
                            if (t.updateMatrixWorld(!0), this.configuration.pmxAnimation && t.geometry.userData.MMD && "pmx" === t.geometry.userData.MMD.format) {
                                const e = this._sortBoneDataArray(t.geometry.userData.MMD.bones.slice()),
                                    n = !1 !== i.ik ? this._createCCDIKSolver(t) : null,
                                    r = !1 !== i.grant ? this.createGrantSolver(t) : null;
                                this._animatePMXMesh(t, e, n, r)
                            } else !1 !== i.ik && this._createCCDIKSolver(t).update(), !1 !== i.grant && this.createGrantSolver(t).update();
                            return this
                        }
                        enable(t, e) {
                            if (void 0 === this.enabled[t]) throw new Error("THREE.MMDAnimationHelper.enable: unknown key " + t);
                            if (this.enabled[t] = e, "physics" === t)
                                for (let t = 0, i = this.meshes.length; t < i; t++) this._optimizeIK(this.meshes[t], e);
                            return this
                        }
                        createGrantSolver(t) {
                            return new D(t, t.geometry.userData.MMD.grants)
                        }
                        _addMesh(t, e) {
                            if (this.meshes.indexOf(t) >= 0) throw new Error("THREE.MMDAnimationHelper._addMesh: SkinnedMesh '" + t.name + "' has already been added.");
                            return this.meshes.push(t), this.objects.set(t, {
                                looped: !1
                            }), this._setupMeshAnimation(t, e.animation), !1 !== e.physics && this._setupMeshPhysics(t, e), this
                        }
                        _setupCamera(t, e) {
                            if (this.camera === t) throw new Error("THREE.MMDAnimationHelper._setupCamera: Camera '" + t.name + "' has already been set.");
                            return this.camera && this.clearCamera(this.camera), this.camera = t, t.add(this.cameraTarget), this.objects.set(t, {}), void 0 !== e.animation && this._setupCameraAnimation(t, e.animation), this
                        }
                        _setupAudio(t, e) {
                            if (this.audio === t) throw new Error("THREE.MMDAnimationHelper._setupAudio: Audio '" + t.name + "' has already been set.");
                            return this.audio && this.clearAudio(this.audio), this.audio = t, this.audioManager = new U(t, e), this.objects.set(this.audioManager, {
                                duration: this.audioManager.duration
                            }), this
                        }
                        _removeMesh(t) {
                            let e = !1,
                                i = 0;
                            for (let n = 0, r = this.meshes.length; n < r; n++) this.meshes[n] !== t ? this.meshes[i++] = this.meshes[n] : (this.objects.delete(t), e = !0);
                            if (!e) throw new Error("THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '" + t.name + "' has not been added yet.");
                            return this.meshes.length = i, this
                        }
                        _clearCamera(t) {
                            if (t !== this.camera) throw new Error("THREE.MMDAnimationHelper._clearCamera: Camera '" + t.name + "' has not been set yet.");
                            return this.camera.remove(this.cameraTarget), this.objects.delete(this.camera), this.camera = null, this
                        }
                        _clearAudio(t) {
                            if (t !== this.audio) throw new Error("THREE.MMDAnimationHelper._clearAudio: Audio '" + t.name + "' has not been set yet.");
                            return this.objects.delete(this.audioManager), this.audio = null, this.audioManager = null, this
                        }
                        _setupMeshAnimation(t, e) {
                            const i = this.objects.get(t);
                            if (void 0 !== e) {
                                const r = Array.isArray(e) ? e : [e];
                                i.mixer = new n.Iw4(t);
                                for (let t = 0, e = r.length; t < e; t++) i.mixer.clipAction(r[t]).play();
                                i.mixer.addEventListener("loop", (function(t) {
                                    const e = t.action._clip.tracks;
                                    e.length > 0 && ".bones" !== e[0].name.slice(0, 6) || (i.looped = !0)
                                }))
                            }
                            return i.ikSolver = this._createCCDIKSolver(t), i.grantSolver = this.createGrantSolver(t), this
                        }
                        _setupCameraAnimation(t, e) {
                            const i = Array.isArray(e) ? e : [e],
                                r = this.objects.get(t);
                            r.mixer = new n.Iw4(t);
                            for (let t = 0, e = i.length; t < e; t++) r.mixer.clipAction(i[t]).play()
                        }
                        _setupMeshPhysics(t, e) {
                            const i = this.objects.get(t);
                            if (void 0 === e.world && this.sharedPhysics) {
                                const t = this._getMasterPhysics();
                                null !== t && (world = t.world)
                            }
                            i.physics = this._createMMDPhysics(t, e), i.mixer && !1 !== e.animationWarmup && (this._animateMesh(t, 0), i.physics.reset()), i.physics.warmup(void 0 !== e.warmup ? e.warmup : 60), this._optimizeIK(t, !0)
                        }
                        _animateMesh(t, e) {
                            const i = this.objects.get(t),
                                n = i.mixer,
                                r = i.ikSolver,
                                s = i.grantSolver,
                                a = i.physics,
                                o = i.looped;
                            n && this.enabled.animation && (this._restoreBones(t), n.update(e), this._saveBones(t), this.configuration.pmxAnimation && t.geometry.userData.MMD && "pmx" === t.geometry.userData.MMD.format ? (i.sortedBonesData || (i.sortedBonesData = this._sortBoneDataArray(t.geometry.userData.MMD.bones.slice())), this._animatePMXMesh(t, i.sortedBonesData, r && this.enabled.ik ? r : null, s && this.enabled.grant ? s : null)) : (r && this.enabled.ik && (t.updateMatrixWorld(!0), r.update()), s && this.enabled.grant && s.update())), !0 === o && this.enabled.physics && (a && this.configuration.resetPhysicsOnLoop && a.reset(), i.looped = !1), a && this.enabled.physics && !this.sharedPhysics && (this.onBeforePhysics(t), a.update(e))
                        }
                        _sortBoneDataArray(t) {
                            return t.sort((function(t, e) {
                                return t.transformationClass !== e.transformationClass ? t.transformationClass - e.transformationClass : t.index - e.index
                            }))
                        }
                        _animatePMXMesh(t, e, i, n) {
                            P = 0, I.clear();
                            for (let r = 0, s = e.length; r < s; r++) L(t, e[r].index, i, n);
                            return t.updateMatrixWorld(!0), this
                        }
                        _animateCamera(t, e) {
                            const i = this.objects.get(t).mixer;
                            i && this.enabled.cameraAnimation && (i.update(e), t.updateProjectionMatrix(), t.up.set(0, 1, 0), t.up.applyQuaternion(t.quaternion), t.lookAt(this.cameraTarget.position))
                        }
                        _optimizeIK(t, e) {
                            const i = t.geometry.userData.MMD.iks,
                                n = t.geometry.userData.MMD.bones;
                            for (let t = 0, r = i.length; t < r; t++) {
                                const r = i[t].links;
                                for (let t = 0, i = r.length; t < i; t++) {
                                    const i = r[t];
                                    i.enabled = !0 !== e || !(n[i.index].rigidBodyType > 0)
                                }
                            }
                        }
                        _createCCDIKSolver(t) {
                            if (void 0 === f) throw new Error("THREE.MMDAnimationHelper: Import CCDIKSolver.");
                            return new f(t, t.geometry.userData.MMD.iks)
                        }
                        _createMMDPhysics(t, e) {
                            if (void 0 === y) throw new Error("THREE.MMDPhysics: Import MMDPhysics.");
                            return new y(t, t.geometry.userData.MMD.rigidBodies, t.geometry.userData.MMD.constraints, e)
                        }
                        _syncDuration() {
                            let t = 0;
                            const e = this.objects,
                                i = this.meshes,
                                n = this.camera,
                                r = this.audioManager;
                            for (let n = 0, r = i.length; n < r; n++) {
                                const r = this.objects.get(i[n]).mixer;
                                if (void 0 !== r)
                                    for (let i = 0; i < r._actions.length; i++) {
                                        const n = r._actions[i]._clip;
                                        e.has(n) || e.set(n, {
                                            duration: n.duration
                                        }), t = Math.max(t, e.get(n).duration)
                                    }
                            }
                            if (null !== n) {
                                const i = this.objects.get(n).mixer;
                                if (void 0 !== i)
                                    for (let n = 0, r = i._actions.length; n < r; n++) {
                                        const r = i._actions[n]._clip;
                                        e.has(r) || e.set(r, {
                                            duration: r.duration
                                        }), t = Math.max(t, e.get(r).duration)
                                    }
                            }
                            null !== r && (t = Math.max(t, e.get(r).duration)), t += this.configuration.afterglow;
                            for (let e = 0, i = this.meshes.length; e < i; e++) {
                                const i = this.objects.get(this.meshes[e]).mixer;
                                if (void 0 !== i)
                                    for (let e = 0, n = i._actions.length; e < n; e++) i._actions[e]._clip.duration = t
                            }
                            if (null !== n) {
                                const e = this.objects.get(n).mixer;
                                if (void 0 !== e)
                                    for (let i = 0, n = e._actions.length; i < n; i++) e._actions[i]._clip.duration = t
                            }
                            null !== r && (r.duration = t)
                        }
                        _updatePropertyMixersBuffer(t) {
                            const e = this.objects.get(t).mixer,
                                i = e._bindings,
                                n = e._accuIndex;
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t],
                                    r = e.buffer,
                                    s = (n + 1) * e.valueSize;
                                e.binding.getValue(r, s)
                            }
                        }
                        _saveBones(t) {
                            const e = this.objects.get(t),
                                i = t.skeleton.bones;
                            let n = e.backupBones;
                            void 0 === n && (n = new Float32Array(7 * i.length), e.backupBones = n);
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t];
                                e.position.toArray(n, 7 * t), e.quaternion.toArray(n, 7 * t + 3)
                            }
                        }
                        _restoreBones(t) {
                            const e = this.objects.get(t).backupBones;
                            if (void 0 === e) return;
                            const i = t.skeleton.bones;
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = i[t];
                                n.position.fromArray(e, 7 * t), n.quaternion.fromArray(e, 7 * t + 3)
                            }
                        }
                        _getMasterPhysics() {
                            if (null !== this.masterPhysics) return this.masterPhysics;
                            for (let t = 0, e = this.meshes.length; t < e; t++) {
                                const e = this.meshes[t].physics;
                                if (null != e) return this.masterPhysics = e, this.masterPhysics
                            }
                            return null
                        }
                        _updateSharedPhysics(t) {
                            if (0 === this.meshes.length || !this.enabled.physics || !this.sharedPhysics) return;
                            const e = this._getMasterPhysics();
                            if (null !== e) {
                                for (let t = 0, e = this.meshes.length; t < e; t++) {
                                    const e = this.meshes[t].physics;
                                    null != e && e.updateRigidBodies()
                                }
                                e.stepSimulation(t);
                                for (let t = 0, e = this.meshes.length; t < e; t++) {
                                    const e = this.meshes[t].physics;
                                    null != e && e.updateBones()
                                }
                            }
                        }
                    }
                    const R = [];
                    let P = 0;
                    const I = new Map;

                    function L(t, e, i, r) {
                        const s = t.skeleton.bones,
                            a = t.geometry.userData.MMD.bones[e],
                            o = s[e];
                        if (I.has(e)) return;
                        const l = (P >= R.length && R.push(new n.PTz), R[P++]);
                        if (I.set(e, l.copy(o.quaternion)), r && a.grant && !a.grant.isLocal && a.grant.affectRotation) {
                            const e = a.grant.parentIndex,
                                n = a.grant.ratio;
                            I.has(e) || L(t, e, i, r), r.addGrantRotation(o, I.get(e), n)
                        }
                        if (i && a.ik) {
                            t.updateMatrixWorld(!0), i.updateOne(a.ik);
                            const e = a.ik.links;
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                if (!1 === i.enabled) continue;
                                const n = i.index;
                                I.has(n) && I.set(n, I.get(n).copy(s[n].quaternion))
                            }
                        }
                        l.copy(o.quaternion)
                    }
                    class U {
                        constructor(t, e = {}) {
                            this.audio = t, this.elapsedTime = 0, this.currentTime = 0, this.delayTime = void 0 !== e.delayTime ? e.delayTime : 0, this.audioDuration = this.audio.buffer.duration, this.duration = this.audioDuration + this.delayTime
                        }
                        control(t) {
                            return this.elapsed += t, this.currentTime += t, this._shouldStopAudio() && this.audio.stop(), this._shouldStartAudio() && this.audio.play(), this
                        }
                        _shouldStartAudio() {
                            if (this.audio.isPlaying) return !1;
                            for (; this.currentTime >= this.duration;) this.currentTime -= this.duration;
                            return !(this.currentTime < this.delayTime || this.currentTime - this.delayTime > this.audioDuration)
                        }
                        _shouldStopAudio() {
                            return this.audio.isPlaying && this.currentTime >= this.duration
                        }
                    }
                    const N = new n.PTz;
                    class D {
                        constructor(t, e = []) {
                            this.mesh = t, this.grants = e
                        }
                        update() {
                            const t = this.grants;
                            for (let e = 0, i = t.length; e < i; e++) this.updateOne(t[e]);
                            return this
                        }
                        updateOne(t) {
                            const e = this.mesh.skeleton.bones,
                                i = e[t.index],
                                n = e[t.parentIndex];
                            return t.isLocal ? (t.affectPosition, t.affectRotation) : (t.affectPosition, t.affectRotation && this.addGrantRotation(i, n.quaternion, t.ratio)), this
                        }
                        addGrantRotation(t, e, i) {
                            return N.set(0, 0, 0, 1), N.slerp(e, i), t.quaternion.multiply(N), this
                        }
                    }
                },
                489: (t, e, i) => {
                    "use strict";
                    i.d(e, {
                        s: () => r
                    });
                    var n = i(979);
                    class r {
                        constructor(t, e = {}) {
                            this.enabled = !0;
                            const i = void 0 !== e.defaultThickness ? e.defaultThickness : .003,
                                r = (new n.Q1f).fromArray(void 0 !== e.defaultColor ? e.defaultColor : [0, 0, 0]),
                                s = void 0 !== e.defaultAlpha ? e.defaultAlpha : 1,
                                a = void 0 !== e.defaultKeepAlive && e.defaultKeepAlive,
                                o = {},
                                l = {},
                                h = {},
                                c = {
                                    outlineThickness: {
                                        value: i
                                    },
                                    outlineColor: {
                                        value: r
                                    },
                                    outlineAlpha: {
                                        value: s
                                    }
                                },
                                u = ["#include <common>", "#include <uv_pars_vertex>", "#include <displacementmap_pars_vertex>", "#include <fog_pars_vertex>", "#include <morphtarget_pars_vertex>", "#include <skinning_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "#include <clipping_planes_pars_vertex>", "uniform float outlineThickness;", "vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {", "\tfloat thickness = outlineThickness;", "\tconst float ratio = 1.0;", "\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );", "\tvec4 norm = normalize( pos - pos2 );", "\treturn pos + norm * thickness * pos.w * ratio;", "}", "void main() {", "\t#include <uv_vertex>", "\t#include <beginnormal_vertex>", "\t#include <morphnormal_vertex>", "\t#include <skinbase_vertex>", "\t#include <skinnormal_vertex>", "\t#include <begin_vertex>", "\t#include <morphtarget_vertex>", "\t#include <skinning_vertex>", "\t#include <displacementmap_vertex>", "\t#include <project_vertex>", "\tvec3 outlineNormal = - objectNormal;", "\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );", "\t#include <logdepthbuf_vertex>", "\t#include <clipping_planes_vertex>", "\t#include <fog_vertex>", "}"].join("\n"),
                                d = ["#include <common>", "#include <fog_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "#include <clipping_planes_pars_fragment>", "uniform vec3 outlineColor;", "uniform float outlineAlpha;", "void main() {", "\t#include <clipping_planes_fragment>", "\t#include <logdepthbuf_fragment>", "\tgl_FragColor = vec4( outlineColor, outlineAlpha );", "\t#include <tonemapping_fragment>", "\t#include <colorspace_fragment>", "\t#include <fog_fragment>", "\t#include <premultiplied_alpha_fragment>", "}"].join("\n");

                            function p(t) {
                                const e = function(t) {
                                    let e = o[t.uuid];
                                    return void 0 === e && (e = {
                                        material: new n.BKk({
                                            type: "OutlineEffect",
                                            uniforms: n.LlO.merge([n.fCn.fog, n.fCn.displacementmap, c]),
                                            vertexShader: u,
                                            fragmentShader: d,
                                            side: n.hsX
                                        }),
                                        used: !0,
                                        keepAlive: a,
                                        count: 0
                                    }, o[t.uuid] = e), e.used = !0, e.material
                                }(t);
                                return l[e.uuid] = t,
                                    function(t, e) {
                                        if ("invisible" === t.name) return;
                                        const i = e.userData.outlineParameters;
                                        t.fog = e.fog, t.toneMapped = e.toneMapped, t.premultipliedAlpha = e.premultipliedAlpha, t.displacementMap = e.displacementMap, void 0 !== i ? (!1 === e.visible ? t.visible = !1 : t.visible = void 0 === i.visible || i.visible, t.transparent = void 0 !== i.alpha && i.alpha < 1 || e.transparent, void 0 !== i.keepAlive && (o[e.uuid].keepAlive = i.keepAlive)) : (t.transparent = e.transparent, t.visible = e.visible), !0 !== e.wireframe && !1 !== e.depthTest || (t.visible = !1), e.clippingPlanes && (t.clipping = !0, t.clippingPlanes = e.clippingPlanes, t.clipIntersection = e.clipIntersection, t.clipShadows = e.clipShadows), t.version = e.version
                                    }(e, t), e
                            }

                            function m(t) {
                                const e = t.geometry,
                                    i = void 0 !== e && void 0 !== e.attributes.normal;
                                return !0 === t.isMesh && void 0 !== t.material && !0 === i
                            }

                            function f(t) {
                                if (!1 !== m(t)) {
                                    if (Array.isArray(t.material))
                                        for (let e = 0, i = t.material.length; e < i; e++) t.material[e] = p(t.material[e]);
                                    else t.material = p(t.material);
                                    h[t.uuid] = t.onBeforeRender, t.onBeforeRender = v
                                }
                            }

                            function g(t) {
                                if (!1 !== m(t)) {
                                    if (Array.isArray(t.material))
                                        for (let e = 0, i = t.material.length; e < i; e++) t.material[e] = l[t.material[e].uuid];
                                    else t.material = l[t.material.uuid];
                                    t.onBeforeRender = h[t.uuid]
                                }
                            }

                            function v(t, e, i, n, r) {
                                const s = l[r.uuid];
                                void 0 !== s && function(t, e) {
                                    const i = e.userData.outlineParameters;
                                    t.uniforms.outlineAlpha.value = e.opacity, void 0 !== i && (void 0 !== i.thickness && (t.uniforms.outlineThickness.value = i.thickness), void 0 !== i.color && t.uniforms.outlineColor.value.fromArray(i.color), void 0 !== i.alpha && (t.uniforms.outlineAlpha.value = i.alpha)), e.displacementMap && (t.uniforms.displacementMap.value = e.displacementMap, t.uniforms.displacementScale.value = e.displacementScale, t.uniforms.displacementBias.value = e.displacementBias)
                                }(r, s)
                            }
                            this.render = function(e, i) {
                                // console.log("sence");
                                // console.log(e);
                                // console.log("camera");
                                // console.log(i);
                                // i.position.set(0,-10,0)
                                // i.lookAt(0,1,0);
                                if (!1 === this.enabled) return void t.render(e, i);
                                const n = t.autoClear;
                                t.autoClear = this.autoClear, t.render(e, i), t.autoClear = n, this.renderOutline(e, i)
                            }, this.renderOutline = function(e, i) {
                                const n = t.autoClear,
                                    r = e.matrixWorldAutoUpdate,
                                    s = e.background,
                                    a = t.shadowMap.enabled;
                                e.matrixWorldAutoUpdate = !1, e.background = null, t.autoClear = !1, t.shadowMap.enabled = !1, e.traverse(f), t.render(e, i), e.traverse(g),
                                    function() {
                                        let t;
                                        t = Object.keys(l);
                                        for (let e = 0, i = t.length; e < i; e++) l[t[e]] = void 0;
                                        t = Object.keys(h);
                                        for (let e = 0, i = t.length; e < i; e++) h[t[e]] = void 0;
                                        t = Object.keys(o);
                                        for (let e = 0, i = t.length; e < i; e++) {
                                            const i = t[e];
                                            !1 === o[i].used ? (o[i].count++, !1 === o[i].keepAlive && o[i].count > 60 && delete o[i]) : (o[i].used = !1, o[i].count = 0)
                                        }
                                    }(), e.matrixWorldAutoUpdate = r, e.background = s, t.autoClear = n, t.shadowMap.enabled = a
                            }, this.autoClear = t.autoClear, this.domElement = t.domElement, this.shadowMap = t.shadowMap, this.clear = function(e, i, n) {
                                t.clear(e, i, n)
                            }, this.getPixelRatio = function() {
                                return t.getPixelRatio()
                            }, this.setPixelRatio = function(e) {
                                t.setPixelRatio(e)
                            }, this.getSize = function(e) {
                                return t.getSize(e)
                            }, this.setSize = function(e, i, n) {
                                t.setSize(e, i, n)
                            }, this.setViewport = function(e, i, n, r) {
                                t.setViewport(e, i, n, r)
                            }, this.setScissor = function(e, i, n, r) {
                                t.setScissor(e, i, n, r)
                            }, this.setScissorTest = function(e) {
                                t.setScissorTest(e)
                            }, this.setRenderTarget = function(e) {
                                t.setRenderTarget(e)
                            }
                        }
                    }
                },
                520: (t, e, i) => {
                    "use strict";
                    i.d(e, {
                        a: () => u
                    });
                    var n = i(979);
                    const r = {
                        name: "MMDToonShader",
                        defines: {
                            TOON: !0,
                            MATCAP: !0,
                            MATCAP_BLENDING_ADD: !0
                        },
                        uniforms: n.LlO.merge([n.zkh.toon.uniforms, n.zkh.phong.uniforms, n.zkh.matcap.uniforms]),
                        vertexShader: n.zkh.phong.vertexShader.replace("#include <envmap_pars_vertex>", "").replace("#include <envmap_vertex>", ""),
                        fragmentShader: n.zkh.phong.fragmentShader.replace("#include <common>", "\n\t\t\t\t\t#ifdef USE_MATCAP\n\t\t\t\t\t\tuniform sampler2D matcap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <common>\n\t\t\t\t").replace("#include <envmap_common_pars_fragment>", "\n\t\t\t\t\t#include <gradientmap_pars_fragment>\n\t\t\t\t").replace("#include <envmap_pars_fragment>", "").replace("#include <lights_phong_pars_fragment>", "\nvarying vec3 vViewPosition;\n\nstruct BlinnPhongMaterial {\n\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n").replace("#include <envmap_fragment>", "\n\t\t\t\t\t\n#ifdef USE_MATCAP\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\tvec4 matcapColor = texture2D( matcap, uv );\n\n\t#ifdef MATCAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight *= matcapColor.rgb;\n\n\t#elif defined( MATCAP_BLENDING_ADD )\n\n\t\toutgoingLight += matcapColor.rgb;\n\n\t#endif\n\n#endif\n\n\t\t\t\t")
                    };
                    class s extends n.BRH {
                        constructor(t) {
                            super(t)
                        }
                        parse(t) {
                            if (t.length < 19) throw new Error("THREE.TGALoader: Not enough data to contain header.");
                            let e = 0;
                            const i = new Uint8Array(t),
                                r = {
                                    id_length: i[e++],
                                    colormap_type: i[e++],
                                    image_type: i[e++],
                                    colormap_index: i[e++] | i[e++] << 8,
                                    colormap_length: i[e++] | i[e++] << 8,
                                    colormap_size: i[e++],
                                    origin: [i[e++] | i[e++] << 8, i[e++] | i[e++] << 8],
                                    width: i[e++] | i[e++] << 8,
                                    height: i[e++] | i[e++] << 8,
                                    pixel_size: i[e++],
                                    flags: i[e++]
                                };
                            if (function(t) {
                                    switch (t.image_type) {
                                        case 1:
                                        case 9:
                                            if (t.colormap_length > 256 || 24 !== t.colormap_size || 1 !== t.colormap_type) throw new Error("THREE.TGALoader: Invalid type colormap data for indexed type.");
                                            break;
                                        case 2:
                                        case 3:
                                        case 10:
                                        case 11:
                                            if (t.colormap_type) throw new Error("THREE.TGALoader: Invalid type colormap data for colormap type.");
                                            break;
                                        case 0:
                                            throw new Error("THREE.TGALoader: No data.");
                                        default:
                                            throw new Error("THREE.TGALoader: Invalid type " + t.image_type)
                                    }
                                    if (t.width <= 0 || t.height <= 0) throw new Error("THREE.TGALoader: Invalid image size.");
                                    if (8 !== t.pixel_size && 16 !== t.pixel_size && 24 !== t.pixel_size && 32 !== t.pixel_size) throw new Error("THREE.TGALoader: Invalid pixel size " + t.pixel_size)
                                }(r), r.id_length + e > t.length) throw new Error("THREE.TGALoader: No data.");
                            e += r.id_length;
                            let s = !1,
                                a = !1,
                                o = !1;
                            switch (r.image_type) {
                                case 9:
                                    s = !0, a = !0;
                                    break;
                                case 1:
                                    a = !0;
                                    break;
                                case 10:
                                    s = !0;
                                    break;
                                case 2:
                                    break;
                                case 11:
                                    s = !0, o = !0;
                                    break;
                                case 3:
                                    o = !0
                            }
                            const l = new Uint8Array(r.width * r.height * 4),
                                h = function(t, e, i, n, r) {
                                    let s, a;
                                    const o = i.pixel_size >> 3,
                                        l = i.width * i.height * o;
                                    if (e && (a = r.subarray(n, n += i.colormap_length * (i.colormap_size >> 3))), t) {
                                        let t, e, i;
                                        s = new Uint8Array(l);
                                        let a = 0;
                                        const h = new Uint8Array(o);
                                        for (; a < l;)
                                            if (t = r[n++], e = 1 + (127 & t), 128 & t) {
                                                for (i = 0; i < o; ++i) h[i] = r[n++];
                                                for (i = 0; i < e; ++i) s.set(h, a + i * o);
                                                a += o * e
                                            } else {
                                                for (e *= o, i = 0; i < e; ++i) s[a + i] = r[n++];
                                                a += e
                                            }
                                    } else s = r.subarray(n, n += e ? i.width * i.height : l);
                                    return {
                                        pixel_data: s,
                                        palettes: a
                                    }
                                }(s, a, r, e, i);
                            return function(t, e, i, n, s) {
                                let a, l, h, c, u, d;
                                switch ((48 & r.flags) >> 4) {
                                    default:
                                    case 2:
                                        a = 0, h = 1, u = e, l = 0, c = 1, d = i;
                                        break;
                                    case 0:
                                        a = 0, h = 1, u = e, l = i - 1, c = -1, d = -1;
                                        break;
                                    case 3:
                                        a = e - 1, h = -1, u = -1, l = 0, c = 1, d = i;
                                        break;
                                    case 1:
                                        a = e - 1, h = -1, u = -1, l = i - 1, c = -1, d = -1
                                }
                                if (o) switch (r.pixel_size) {
                                    case 8:
                                        ! function(t, e, i, n, s, a, o, l) {
                                            let h, c, u, d = 0;
                                            const p = r.width;
                                            for (u = e; u !== n; u += i)
                                                for (c = s; c !== o; c += a, d++) h = l[d], t[4 * (c + p * u) + 0] = h, t[4 * (c + p * u) + 1] = h, t[4 * (c + p * u) + 2] = h, t[4 * (c + p * u) + 3] = 255
                                        }(t, l, c, d, a, h, u, n);
                                        break;
                                    case 16:
                                        ! function(t, e, i, n, s, a, o, l) {
                                            let h, c, u = 0;
                                            const d = r.width;
                                            for (c = e; c !== n; c += i)
                                                for (h = s; h !== o; h += a, u += 2) t[4 * (h + d * c) + 0] = l[u + 0], t[4 * (h + d * c) + 1] = l[u + 0], t[4 * (h + d * c) + 2] = l[u + 0], t[4 * (h + d * c) + 3] = l[u + 1]
                                        }(t, l, c, d, a, h, u, n);
                                        break;
                                    default:
                                        throw new Error("THREE.TGALoader: Format not supported.")
                                } else switch (r.pixel_size) {
                                    case 8:
                                        ! function(t, e, i, n, s, a, o, l, h) {
                                            const c = h;
                                            let u, d, p, m = 0;
                                            const f = r.width;
                                            for (p = e; p !== n; p += i)
                                                for (d = s; d !== o; d += a, m++) u = l[m], t[4 * (d + f * p) + 3] = 255, t[4 * (d + f * p) + 2] = c[3 * u + 0], t[4 * (d + f * p) + 1] = c[3 * u + 1], t[4 * (d + f * p) + 0] = c[3 * u + 2]
                                        }(t, l, c, d, a, h, u, n, s);
                                        break;
                                    case 16:
                                        ! function(t, e, i, n, s, a, o, l) {
                                            let h, c, u, d = 0;
                                            const p = r.width;
                                            for (u = e; u !== n; u += i)
                                                for (c = s; c !== o; c += a, d += 2) h = l[d + 0] + (l[d + 1] << 8), t[4 * (c + p * u) + 0] = (31744 & h) >> 7, t[4 * (c + p * u) + 1] = (992 & h) >> 2, t[4 * (c + p * u) + 2] = (31 & h) << 3, t[4 * (c + p * u) + 3] = 32768 & h ? 0 : 255
                                        }(t, l, c, d, a, h, u, n);
                                        break;
                                    case 24:
                                        ! function(t, e, i, n, s, a, o, l) {
                                            let h, c, u = 0;
                                            const d = r.width;
                                            for (c = e; c !== n; c += i)
                                                for (h = s; h !== o; h += a, u += 3) t[4 * (h + d * c) + 3] = 255, t[4 * (h + d * c) + 2] = l[u + 0], t[4 * (h + d * c) + 1] = l[u + 1], t[4 * (h + d * c) + 0] = l[u + 2]
                                        }(t, l, c, d, a, h, u, n);
                                        break;
                                    case 32:
                                        ! function(t, e, i, n, s, a, o, l) {
                                            let h, c, u = 0;
                                            const d = r.width;
                                            for (c = e; c !== n; c += i)
                                                for (h = s; h !== o; h += a, u += 4) t[4 * (h + d * c) + 2] = l[u + 0], t[4 * (h + d * c) + 1] = l[u + 1], t[4 * (h + d * c) + 0] = l[u + 2], t[4 * (h + d * c) + 3] = l[u + 3]
                                        }(t, l, c, d, a, h, u, n);
                                        break;
                                    default:
                                        throw new Error("THREE.TGALoader: Format not supported.")
                                }
                            }(l, r.width, r.height, h.pixel_data, h.palettes), {
                                data: l,
                                width: r.width,
                                height: r.height,
                                flipY: !0,
                                generateMipmaps: !0,
                                minFilter: n.$_I
                            }
                        }
                    }

                    function a() {}

                    function o(t, e) {
                        this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e, this.encoder = new a
                    }

                    function l() {}

                    function h() {}
                    a.prototype.s2u = function(t) {
                        for (var e = this.s2uTable, i = "", n = 0; n < t.length;) {
                            var r = t[n++];
                            if (!(r >= 0 && r <= 126 || r >= 161 && r <= 223) && n < t.length && (r = r << 8 | t[n++]), void 0 === e[r]) return console.error("unknown char code " + r + "."), i;
                            i += String.fromCharCode(e[r])
                        }
                        return i
                    }, a.prototype.s2uTable = {
                        0: 0,
                        1: 1,
                        2: 2,
                        3: 3,
                        4: 4,
                        5: 5,
                        6: 6,
                        7: 7,
                        8: 8,
                        9: 9,
                        10: 10,
                        11: 11,
                        12: 12,
                        13: 13,
                        14: 14,
                        15: 15,
                        16: 16,
                        17: 17,
                        18: 18,
                        19: 19,
                        20: 20,
                        21: 21,
                        22: 22,
                        23: 23,
                        24: 24,
                        25: 25,
                        26: 26,
                        27: 27,
                        28: 28,
                        29: 29,
                        30: 30,
                        31: 31,
                        32: 32,
                        33: 33,
                        34: 34,
                        35: 35,
                        36: 36,
                        37: 37,
                        38: 38,
                        39: 39,
                        40: 40,
                        41: 41,
                        42: 42,
                        43: 43,
                        44: 44,
                        45: 45,
                        46: 46,
                        47: 47,
                        48: 48,
                        49: 49,
                        50: 50,
                        51: 51,
                        52: 52,
                        53: 53,
                        54: 54,
                        55: 55,
                        56: 56,
                        57: 57,
                        58: 58,
                        59: 59,
                        60: 60,
                        61: 61,
                        62: 62,
                        63: 63,
                        64: 64,
                        65: 65,
                        66: 66,
                        67: 67,
                        68: 68,
                        69: 69,
                        70: 70,
                        71: 71,
                        72: 72,
                        73: 73,
                        74: 74,
                        75: 75,
                        76: 76,
                        77: 77,
                        78: 78,
                        79: 79,
                        80: 80,
                        81: 81,
                        82: 82,
                        83: 83,
                        84: 84,
                        85: 85,
                        86: 86,
                        87: 87,
                        88: 88,
                        89: 89,
                        90: 90,
                        91: 91,
                        92: 92,
                        93: 93,
                        94: 94,
                        95: 95,
                        96: 96,
                        97: 97,
                        98: 98,
                        99: 99,
                        100: 100,
                        101: 101,
                        102: 102,
                        103: 103,
                        104: 104,
                        105: 105,
                        106: 106,
                        107: 107,
                        108: 108,
                        109: 109,
                        110: 110,
                        111: 111,
                        112: 112,
                        113: 113,
                        114: 114,
                        115: 115,
                        116: 116,
                        117: 117,
                        118: 118,
                        119: 119,
                        120: 120,
                        121: 121,
                        122: 122,
                        123: 123,
                        124: 124,
                        125: 125,
                        126: 126,
                        161: 65377,
                        162: 65378,
                        163: 65379,
                        164: 65380,
                        165: 65381,
                        166: 65382,
                        167: 65383,
                        168: 65384,
                        169: 65385,
                        170: 65386,
                        171: 65387,
                        172: 65388,
                        173: 65389,
                        174: 65390,
                        175: 65391,
                        176: 65392,
                        177: 65393,
                        178: 65394,
                        179: 65395,
                        180: 65396,
                        181: 65397,
                        182: 65398,
                        183: 65399,
                        184: 65400,
                        185: 65401,
                        186: 65402,
                        187: 65403,
                        188: 65404,
                        189: 65405,
                        190: 65406,
                        191: 65407,
                        192: 65408,
                        193: 65409,
                        194: 65410,
                        195: 65411,
                        196: 65412,
                        197: 65413,
                        198: 65414,
                        199: 65415,
                        200: 65416,
                        201: 65417,
                        202: 65418,
                        203: 65419,
                        204: 65420,
                        205: 65421,
                        206: 65422,
                        207: 65423,
                        208: 65424,
                        209: 65425,
                        210: 65426,
                        211: 65427,
                        212: 65428,
                        213: 65429,
                        214: 65430,
                        215: 65431,
                        216: 65432,
                        217: 65433,
                        218: 65434,
                        219: 65435,
                        220: 65436,
                        221: 65437,
                        222: 65438,
                        223: 65439,
                        33088: 12288,
                        33089: 12289,
                        33090: 12290,
                        33091: 65292,
                        33092: 65294,
                        33093: 12539,
                        33094: 65306,
                        33095: 65307,
                        33096: 65311,
                        33097: 65281,
                        33098: 12443,
                        33099: 12444,
                        33100: 180,
                        33101: 65344,
                        33102: 168,
                        33103: 65342,
                        33104: 65507,
                        33105: 65343,
                        33106: 12541,
                        33107: 12542,
                        33108: 12445,
                        33109: 12446,
                        33110: 12291,
                        33111: 20189,
                        33112: 12293,
                        33113: 12294,
                        33114: 12295,
                        33115: 12540,
                        33116: 8213,
                        33117: 8208,
                        33118: 65295,
                        33119: 65340,
                        33120: 65374,
                        33121: 8741,
                        33122: 65372,
                        33123: 8230,
                        33124: 8229,
                        33125: 8216,
                        33126: 8217,
                        33127: 8220,
                        33128: 8221,
                        33129: 65288,
                        33130: 65289,
                        33131: 12308,
                        33132: 12309,
                        33133: 65339,
                        33134: 65341,
                        33135: 65371,
                        33136: 65373,
                        33137: 12296,
                        33138: 12297,
                        33139: 12298,
                        33140: 12299,
                        33141: 12300,
                        33142: 12301,
                        33143: 12302,
                        33144: 12303,
                        33145: 12304,
                        33146: 12305,
                        33147: 65291,
                        33148: 65293,
                        33149: 177,
                        33150: 215,
                        33152: 247,
                        33153: 65309,
                        33154: 8800,
                        33155: 65308,
                        33156: 65310,
                        33157: 8806,
                        33158: 8807,
                        33159: 8734,
                        33160: 8756,
                        33161: 9794,
                        33162: 9792,
                        33163: 176,
                        33164: 8242,
                        33165: 8243,
                        33166: 8451,
                        33167: 65509,
                        33168: 65284,
                        33169: 65504,
                        33170: 65505,
                        33171: 65285,
                        33172: 65283,
                        33173: 65286,
                        33174: 65290,
                        33175: 65312,
                        33176: 167,
                        33177: 9734,
                        33178: 9733,
                        33179: 9675,
                        33180: 9679,
                        33181: 9678,
                        33182: 9671,
                        33183: 9670,
                        33184: 9633,
                        33185: 9632,
                        33186: 9651,
                        33187: 9650,
                        33188: 9661,
                        33189: 9660,
                        33190: 8251,
                        33191: 12306,
                        33192: 8594,
                        33193: 8592,
                        33194: 8593,
                        33195: 8595,
                        33196: 12307,
                        33208: 8712,
                        33209: 8715,
                        33210: 8838,
                        33211: 8839,
                        33212: 8834,
                        33213: 8835,
                        33214: 8746,
                        33215: 8745,
                        33224: 8743,
                        33225: 8744,
                        33226: 65506,
                        33227: 8658,
                        33228: 8660,
                        33229: 8704,
                        33230: 8707,
                        33242: 8736,
                        33243: 8869,
                        33244: 8978,
                        33245: 8706,
                        33246: 8711,
                        33247: 8801,
                        33248: 8786,
                        33249: 8810,
                        33250: 8811,
                        33251: 8730,
                        33252: 8765,
                        33253: 8733,
                        33254: 8757,
                        33255: 8747,
                        33256: 8748,
                        33264: 8491,
                        33265: 8240,
                        33266: 9839,
                        33267: 9837,
                        33268: 9834,
                        33269: 8224,
                        33270: 8225,
                        33271: 182,
                        33276: 9711,
                        33359: 65296,
                        33360: 65297,
                        33361: 65298,
                        33362: 65299,
                        33363: 65300,
                        33364: 65301,
                        33365: 65302,
                        33366: 65303,
                        33367: 65304,
                        33368: 65305,
                        33376: 65313,
                        33377: 65314,
                        33378: 65315,
                        33379: 65316,
                        33380: 65317,
                        33381: 65318,
                        33382: 65319,
                        33383: 65320,
                        33384: 65321,
                        33385: 65322,
                        33386: 65323,
                        33387: 65324,
                        33388: 65325,
                        33389: 65326,
                        33390: 65327,
                        33391: 65328,
                        33392: 65329,
                        33393: 65330,
                        33394: 65331,
                        33395: 65332,
                        33396: 65333,
                        33397: 65334,
                        33398: 65335,
                        33399: 65336,
                        33400: 65337,
                        33401: 65338,
                        33409: 65345,
                        33410: 65346,
                        33411: 65347,
                        33412: 65348,
                        33413: 65349,
                        33414: 65350,
                        33415: 65351,
                        33416: 65352,
                        33417: 65353,
                        33418: 65354,
                        33419: 65355,
                        33420: 65356,
                        33421: 65357,
                        33422: 65358,
                        33423: 65359,
                        33424: 65360,
                        33425: 65361,
                        33426: 65362,
                        33427: 65363,
                        33428: 65364,
                        33429: 65365,
                        33430: 65366,
                        33431: 65367,
                        33432: 65368,
                        33433: 65369,
                        33434: 65370,
                        33439: 12353,
                        33440: 12354,
                        33441: 12355,
                        33442: 12356,
                        33443: 12357,
                        33444: 12358,
                        33445: 12359,
                        33446: 12360,
                        33447: 12361,
                        33448: 12362,
                        33449: 12363,
                        33450: 12364,
                        33451: 12365,
                        33452: 12366,
                        33453: 12367,
                        33454: 12368,
                        33455: 12369,
                        33456: 12370,
                        33457: 12371,
                        33458: 12372,
                        33459: 12373,
                        33460: 12374,
                        33461: 12375,
                        33462: 12376,
                        33463: 12377,
                        33464: 12378,
                        33465: 12379,
                        33466: 12380,
                        33467: 12381,
                        33468: 12382,
                        33469: 12383,
                        33470: 12384,
                        33471: 12385,
                        33472: 12386,
                        33473: 12387,
                        33474: 12388,
                        33475: 12389,
                        33476: 12390,
                        33477: 12391,
                        33478: 12392,
                        33479: 12393,
                        33480: 12394,
                        33481: 12395,
                        33482: 12396,
                        33483: 12397,
                        33484: 12398,
                        33485: 12399,
                        33486: 12400,
                        33487: 12401,
                        33488: 12402,
                        33489: 12403,
                        33490: 12404,
                        33491: 12405,
                        33492: 12406,
                        33493: 12407,
                        33494: 12408,
                        33495: 12409,
                        33496: 12410,
                        33497: 12411,
                        33498: 12412,
                        33499: 12413,
                        33500: 12414,
                        33501: 12415,
                        33502: 12416,
                        33503: 12417,
                        33504: 12418,
                        33505: 12419,
                        33506: 12420,
                        33507: 12421,
                        33508: 12422,
                        33509: 12423,
                        33510: 12424,
                        33511: 12425,
                        33512: 12426,
                        33513: 12427,
                        33514: 12428,
                        33515: 12429,
                        33516: 12430,
                        33517: 12431,
                        33518: 12432,
                        33519: 12433,
                        33520: 12434,
                        33521: 12435,
                        33600: 12449,
                        33601: 12450,
                        33602: 12451,
                        33603: 12452,
                        33604: 12453,
                        33605: 12454,
                        33606: 12455,
                        33607: 12456,
                        33608: 12457,
                        33609: 12458,
                        33610: 12459,
                        33611: 12460,
                        33612: 12461,
                        33613: 12462,
                        33614: 12463,
                        33615: 12464,
                        33616: 12465,
                        33617: 12466,
                        33618: 12467,
                        33619: 12468,
                        33620: 12469,
                        33621: 12470,
                        33622: 12471,
                        33623: 12472,
                        33624: 12473,
                        33625: 12474,
                        33626: 12475,
                        33627: 12476,
                        33628: 12477,
                        33629: 12478,
                        33630: 12479,
                        33631: 12480,
                        33632: 12481,
                        33633: 12482,
                        33634: 12483,
                        33635: 12484,
                        33636: 12485,
                        33637: 12486,
                        33638: 12487,
                        33639: 12488,
                        33640: 12489,
                        33641: 12490,
                        33642: 12491,
                        33643: 12492,
                        33644: 12493,
                        33645: 12494,
                        33646: 12495,
                        33647: 12496,
                        33648: 12497,
                        33649: 12498,
                        33650: 12499,
                        33651: 12500,
                        33652: 12501,
                        33653: 12502,
                        33654: 12503,
                        33655: 12504,
                        33656: 12505,
                        33657: 12506,
                        33658: 12507,
                        33659: 12508,
                        33660: 12509,
                        33661: 12510,
                        33662: 12511,
                        33664: 12512,
                        33665: 12513,
                        33666: 12514,
                        33667: 12515,
                        33668: 12516,
                        33669: 12517,
                        33670: 12518,
                        33671: 12519,
                        33672: 12520,
                        33673: 12521,
                        33674: 12522,
                        33675: 12523,
                        33676: 12524,
                        33677: 12525,
                        33678: 12526,
                        33679: 12527,
                        33680: 12528,
                        33681: 12529,
                        33682: 12530,
                        33683: 12531,
                        33684: 12532,
                        33685: 12533,
                        33686: 12534,
                        33695: 913,
                        33696: 914,
                        33697: 915,
                        33698: 916,
                        33699: 917,
                        33700: 918,
                        33701: 919,
                        33702: 920,
                        33703: 921,
                        33704: 922,
                        33705: 923,
                        33706: 924,
                        33707: 925,
                        33708: 926,
                        33709: 927,
                        33710: 928,
                        33711: 929,
                        33712: 931,
                        33713: 932,
                        33714: 933,
                        33715: 934,
                        33716: 935,
                        33717: 936,
                        33718: 937,
                        33727: 945,
                        33728: 946,
                        33729: 947,
                        33730: 948,
                        33731: 949,
                        33732: 950,
                        33733: 951,
                        33734: 952,
                        33735: 953,
                        33736: 954,
                        33737: 955,
                        33738: 956,
                        33739: 957,
                        33740: 958,
                        33741: 959,
                        33742: 960,
                        33743: 961,
                        33744: 963,
                        33745: 964,
                        33746: 965,
                        33747: 966,
                        33748: 967,
                        33749: 968,
                        33750: 969,
                        33856: 1040,
                        33857: 1041,
                        33858: 1042,
                        33859: 1043,
                        33860: 1044,
                        33861: 1045,
                        33862: 1025,
                        33863: 1046,
                        33864: 1047,
                        33865: 1048,
                        33866: 1049,
                        33867: 1050,
                        33868: 1051,
                        33869: 1052,
                        33870: 1053,
                        33871: 1054,
                        33872: 1055,
                        33873: 1056,
                        33874: 1057,
                        33875: 1058,
                        33876: 1059,
                        33877: 1060,
                        33878: 1061,
                        33879: 1062,
                        33880: 1063,
                        33881: 1064,
                        33882: 1065,
                        33883: 1066,
                        33884: 1067,
                        33885: 1068,
                        33886: 1069,
                        33887: 1070,
                        33888: 1071,
                        33904: 1072,
                        33905: 1073,
                        33906: 1074,
                        33907: 1075,
                        33908: 1076,
                        33909: 1077,
                        33910: 1105,
                        33911: 1078,
                        33912: 1079,
                        33913: 1080,
                        33914: 1081,
                        33915: 1082,
                        33916: 1083,
                        33917: 1084,
                        33918: 1085,
                        33920: 1086,
                        33921: 1087,
                        33922: 1088,
                        33923: 1089,
                        33924: 1090,
                        33925: 1091,
                        33926: 1092,
                        33927: 1093,
                        33928: 1094,
                        33929: 1095,
                        33930: 1096,
                        33931: 1097,
                        33932: 1098,
                        33933: 1099,
                        33934: 1100,
                        33935: 1101,
                        33936: 1102,
                        33937: 1103,
                        33951: 9472,
                        33952: 9474,
                        33953: 9484,
                        33954: 9488,
                        33955: 9496,
                        33956: 9492,
                        33957: 9500,
                        33958: 9516,
                        33959: 9508,
                        33960: 9524,
                        33961: 9532,
                        33962: 9473,
                        33963: 9475,
                        33964: 9487,
                        33965: 9491,
                        33966: 9499,
                        33967: 9495,
                        33968: 9507,
                        33969: 9523,
                        33970: 9515,
                        33971: 9531,
                        33972: 9547,
                        33973: 9504,
                        33974: 9519,
                        33975: 9512,
                        33976: 9527,
                        33977: 9535,
                        33978: 9501,
                        33979: 9520,
                        33980: 9509,
                        33981: 9528,
                        33982: 9538,
                        34624: 9312,
                        34625: 9313,
                        34626: 9314,
                        34627: 9315,
                        34628: 9316,
                        34629: 9317,
                        34630: 9318,
                        34631: 9319,
                        34632: 9320,
                        34633: 9321,
                        34634: 9322,
                        34635: 9323,
                        34636: 9324,
                        34637: 9325,
                        34638: 9326,
                        34639: 9327,
                        34640: 9328,
                        34641: 9329,
                        34642: 9330,
                        34643: 9331,
                        34644: 8544,
                        34645: 8545,
                        34646: 8546,
                        34647: 8547,
                        34648: 8548,
                        34649: 8549,
                        34650: 8550,
                        34651: 8551,
                        34652: 8552,
                        34653: 8553,
                        34655: 13129,
                        34656: 13076,
                        34657: 13090,
                        34658: 13133,
                        34659: 13080,
                        34660: 13095,
                        34661: 13059,
                        34662: 13110,
                        34663: 13137,
                        34664: 13143,
                        34665: 13069,
                        34666: 13094,
                        34667: 13091,
                        34668: 13099,
                        34669: 13130,
                        34670: 13115,
                        34671: 13212,
                        34672: 13213,
                        34673: 13214,
                        34674: 13198,
                        34675: 13199,
                        34676: 13252,
                        34677: 13217,
                        34686: 13179,
                        34688: 12317,
                        34689: 12319,
                        34690: 8470,
                        34691: 13261,
                        34692: 8481,
                        34693: 12964,
                        34694: 12965,
                        34695: 12966,
                        34696: 12967,
                        34697: 12968,
                        34698: 12849,
                        34699: 12850,
                        34700: 12857,
                        34701: 13182,
                        34702: 13181,
                        34703: 13180,
                        34704: 8786,
                        34705: 8801,
                        34706: 8747,
                        34707: 8750,
                        34708: 8721,
                        34709: 8730,
                        34710: 8869,
                        34711: 8736,
                        34712: 8735,
                        34713: 8895,
                        34714: 8757,
                        34715: 8745,
                        34716: 8746,
                        34975: 20124,
                        34976: 21782,
                        34977: 23043,
                        34978: 38463,
                        34979: 21696,
                        34980: 24859,
                        34981: 25384,
                        34982: 23030,
                        34983: 36898,
                        34984: 33909,
                        34985: 33564,
                        34986: 31312,
                        34987: 24746,
                        34988: 25569,
                        34989: 28197,
                        34990: 26093,
                        34991: 33894,
                        34992: 33446,
                        34993: 39925,
                        34994: 26771,
                        34995: 22311,
                        34996: 26017,
                        34997: 25201,
                        34998: 23451,
                        34999: 22992,
                        35e3: 34427,
                        35001: 39156,
                        35002: 32098,
                        35003: 32190,
                        35004: 39822,
                        35005: 25110,
                        35006: 31903,
                        35007: 34999,
                        35008: 23433,
                        35009: 24245,
                        35010: 25353,
                        35011: 26263,
                        35012: 26696,
                        35013: 38343,
                        35014: 38797,
                        35015: 26447,
                        35016: 20197,
                        35017: 20234,
                        35018: 20301,
                        35019: 20381,
                        35020: 20553,
                        35021: 22258,
                        35022: 22839,
                        35023: 22996,
                        35024: 23041,
                        35025: 23561,
                        35026: 24799,
                        35027: 24847,
                        35028: 24944,
                        35029: 26131,
                        35030: 26885,
                        35031: 28858,
                        35032: 30031,
                        35033: 30064,
                        35034: 31227,
                        35035: 32173,
                        35036: 32239,
                        35037: 32963,
                        35038: 33806,
                        35039: 34915,
                        35040: 35586,
                        35041: 36949,
                        35042: 36986,
                        35043: 21307,
                        35044: 20117,
                        35045: 20133,
                        35046: 22495,
                        35047: 32946,
                        35048: 37057,
                        35049: 30959,
                        35050: 19968,
                        35051: 22769,
                        35052: 28322,
                        35053: 36920,
                        35054: 31282,
                        35055: 33576,
                        35056: 33419,
                        35057: 39983,
                        35058: 20801,
                        35059: 21360,
                        35060: 21693,
                        35061: 21729,
                        35062: 22240,
                        35063: 23035,
                        35064: 24341,
                        35065: 39154,
                        35066: 28139,
                        35067: 32996,
                        35068: 34093,
                        35136: 38498,
                        35137: 38512,
                        35138: 38560,
                        35139: 38907,
                        35140: 21515,
                        35141: 21491,
                        35142: 23431,
                        35143: 28879,
                        35144: 32701,
                        35145: 36802,
                        35146: 38632,
                        35147: 21359,
                        35148: 40284,
                        35149: 31418,
                        35150: 19985,
                        35151: 30867,
                        35152: 33276,
                        35153: 28198,
                        35154: 22040,
                        35155: 21764,
                        35156: 27421,
                        35157: 34074,
                        35158: 39995,
                        35159: 23013,
                        35160: 21417,
                        35161: 28006,
                        35162: 29916,
                        35163: 38287,
                        35164: 22082,
                        35165: 20113,
                        35166: 36939,
                        35167: 38642,
                        35168: 33615,
                        35169: 39180,
                        35170: 21473,
                        35171: 21942,
                        35172: 23344,
                        35173: 24433,
                        35174: 26144,
                        35175: 26355,
                        35176: 26628,
                        35177: 27704,
                        35178: 27891,
                        35179: 27945,
                        35180: 29787,
                        35181: 30408,
                        35182: 31310,
                        35183: 38964,
                        35184: 33521,
                        35185: 34907,
                        35186: 35424,
                        35187: 37613,
                        35188: 28082,
                        35189: 30123,
                        35190: 30410,
                        35191: 39365,
                        35192: 24742,
                        35193: 35585,
                        35194: 36234,
                        35195: 38322,
                        35196: 27022,
                        35197: 21421,
                        35198: 20870,
                        35200: 22290,
                        35201: 22576,
                        35202: 22852,
                        35203: 23476,
                        35204: 24310,
                        35205: 24616,
                        35206: 25513,
                        35207: 25588,
                        35208: 27839,
                        35209: 28436,
                        35210: 28814,
                        35211: 28948,
                        35212: 29017,
                        35213: 29141,
                        35214: 29503,
                        35215: 32257,
                        35216: 33398,
                        35217: 33489,
                        35218: 34199,
                        35219: 36960,
                        35220: 37467,
                        35221: 40219,
                        35222: 22633,
                        35223: 26044,
                        35224: 27738,
                        35225: 29989,
                        35226: 20985,
                        35227: 22830,
                        35228: 22885,
                        35229: 24448,
                        35230: 24540,
                        35231: 25276,
                        35232: 26106,
                        35233: 27178,
                        35234: 27431,
                        35235: 27572,
                        35236: 29579,
                        35237: 32705,
                        35238: 35158,
                        35239: 40236,
                        35240: 40206,
                        35241: 40644,
                        35242: 23713,
                        35243: 27798,
                        35244: 33659,
                        35245: 20740,
                        35246: 23627,
                        35247: 25014,
                        35248: 33222,
                        35249: 26742,
                        35250: 29281,
                        35251: 20057,
                        35252: 20474,
                        35253: 21368,
                        35254: 24681,
                        35255: 28201,
                        35256: 31311,
                        35257: 38899,
                        35258: 19979,
                        35259: 21270,
                        35260: 20206,
                        35261: 20309,
                        35262: 20285,
                        35263: 20385,
                        35264: 20339,
                        35265: 21152,
                        35266: 21487,
                        35267: 22025,
                        35268: 22799,
                        35269: 23233,
                        35270: 23478,
                        35271: 23521,
                        35272: 31185,
                        35273: 26247,
                        35274: 26524,
                        35275: 26550,
                        35276: 27468,
                        35277: 27827,
                        35278: 28779,
                        35279: 29634,
                        35280: 31117,
                        35281: 31166,
                        35282: 31292,
                        35283: 31623,
                        35284: 33457,
                        35285: 33499,
                        35286: 33540,
                        35287: 33655,
                        35288: 33775,
                        35289: 33747,
                        35290: 34662,
                        35291: 35506,
                        35292: 22057,
                        35293: 36008,
                        35294: 36838,
                        35295: 36942,
                        35296: 38686,
                        35297: 34442,
                        35298: 20420,
                        35299: 23784,
                        35300: 25105,
                        35301: 29273,
                        35302: 30011,
                        35303: 33253,
                        35304: 33469,
                        35305: 34558,
                        35306: 36032,
                        35307: 38597,
                        35308: 39187,
                        35309: 39381,
                        35310: 20171,
                        35311: 20250,
                        35312: 35299,
                        35313: 22238,
                        35314: 22602,
                        35315: 22730,
                        35316: 24315,
                        35317: 24555,
                        35318: 24618,
                        35319: 24724,
                        35320: 24674,
                        35321: 25040,
                        35322: 25106,
                        35323: 25296,
                        35324: 25913,
                        35392: 39745,
                        35393: 26214,
                        35394: 26800,
                        35395: 28023,
                        35396: 28784,
                        35397: 30028,
                        35398: 30342,
                        35399: 32117,
                        35400: 33445,
                        35401: 34809,
                        35402: 38283,
                        35403: 38542,
                        35404: 35997,
                        35405: 20977,
                        35406: 21182,
                        35407: 22806,
                        35408: 21683,
                        35409: 23475,
                        35410: 23830,
                        35411: 24936,
                        35412: 27010,
                        35413: 28079,
                        35414: 30861,
                        35415: 33995,
                        35416: 34903,
                        35417: 35442,
                        35418: 37799,
                        35419: 39608,
                        35420: 28012,
                        35421: 39336,
                        35422: 34521,
                        35423: 22435,
                        35424: 26623,
                        35425: 34510,
                        35426: 37390,
                        35427: 21123,
                        35428: 22151,
                        35429: 21508,
                        35430: 24275,
                        35431: 25313,
                        35432: 25785,
                        35433: 26684,
                        35434: 26680,
                        35435: 27579,
                        35436: 29554,
                        35437: 30906,
                        35438: 31339,
                        35439: 35226,
                        35440: 35282,
                        35441: 36203,
                        35442: 36611,
                        35443: 37101,
                        35444: 38307,
                        35445: 38548,
                        35446: 38761,
                        35447: 23398,
                        35448: 23731,
                        35449: 27005,
                        35450: 38989,
                        35451: 38990,
                        35452: 25499,
                        35453: 31520,
                        35454: 27179,
                        35456: 27263,
                        35457: 26806,
                        35458: 39949,
                        35459: 28511,
                        35460: 21106,
                        35461: 21917,
                        35462: 24688,
                        35463: 25324,
                        35464: 27963,
                        35465: 28167,
                        35466: 28369,
                        35467: 33883,
                        35468: 35088,
                        35469: 36676,
                        35470: 19988,
                        35471: 39993,
                        35472: 21494,
                        35473: 26907,
                        35474: 27194,
                        35475: 38788,
                        35476: 26666,
                        35477: 20828,
                        35478: 31427,
                        35479: 33970,
                        35480: 37340,
                        35481: 37772,
                        35482: 22107,
                        35483: 40232,
                        35484: 26658,
                        35485: 33541,
                        35486: 33841,
                        35487: 31909,
                        35488: 21e3,
                        35489: 33477,
                        35490: 29926,
                        35491: 20094,
                        35492: 20355,
                        35493: 20896,
                        35494: 23506,
                        35495: 21002,
                        35496: 21208,
                        35497: 21223,
                        35498: 24059,
                        35499: 21914,
                        35500: 22570,
                        35501: 23014,
                        35502: 23436,
                        35503: 23448,
                        35504: 23515,
                        35505: 24178,
                        35506: 24185,
                        35507: 24739,
                        35508: 24863,
                        35509: 24931,
                        35510: 25022,
                        35511: 25563,
                        35512: 25954,
                        35513: 26577,
                        35514: 26707,
                        35515: 26874,
                        35516: 27454,
                        35517: 27475,
                        35518: 27735,
                        35519: 28450,
                        35520: 28567,
                        35521: 28485,
                        35522: 29872,
                        35523: 29976,
                        35524: 30435,
                        35525: 30475,
                        35526: 31487,
                        35527: 31649,
                        35528: 31777,
                        35529: 32233,
                        35530: 32566,
                        35531: 32752,
                        35532: 32925,
                        35533: 33382,
                        35534: 33694,
                        35535: 35251,
                        35536: 35532,
                        35537: 36011,
                        35538: 36996,
                        35539: 37969,
                        35540: 38291,
                        35541: 38289,
                        35542: 38306,
                        35543: 38501,
                        35544: 38867,
                        35545: 39208,
                        35546: 33304,
                        35547: 20024,
                        35548: 21547,
                        35549: 23736,
                        35550: 24012,
                        35551: 29609,
                        35552: 30284,
                        35553: 30524,
                        35554: 23721,
                        35555: 32747,
                        35556: 36107,
                        35557: 38593,
                        35558: 38929,
                        35559: 38996,
                        35560: 39e3,
                        35561: 20225,
                        35562: 20238,
                        35563: 21361,
                        35564: 21916,
                        35565: 22120,
                        35566: 22522,
                        35567: 22855,
                        35568: 23305,
                        35569: 23492,
                        35570: 23696,
                        35571: 24076,
                        35572: 24190,
                        35573: 24524,
                        35574: 25582,
                        35575: 26426,
                        35576: 26071,
                        35577: 26082,
                        35578: 26399,
                        35579: 26827,
                        35580: 26820,
                        35648: 27231,
                        35649: 24112,
                        35650: 27589,
                        35651: 27671,
                        35652: 27773,
                        35653: 30079,
                        35654: 31048,
                        35655: 23395,
                        35656: 31232,
                        35657: 32e3,
                        35658: 24509,
                        35659: 35215,
                        35660: 35352,
                        35661: 36020,
                        35662: 36215,
                        35663: 36556,
                        35664: 36637,
                        35665: 39138,
                        35666: 39438,
                        35667: 39740,
                        35668: 20096,
                        35669: 20605,
                        35670: 20736,
                        35671: 22931,
                        35672: 23452,
                        35673: 25135,
                        35674: 25216,
                        35675: 25836,
                        35676: 27450,
                        35677: 29344,
                        35678: 30097,
                        35679: 31047,
                        35680: 32681,
                        35681: 34811,
                        35682: 35516,
                        35683: 35696,
                        35684: 25516,
                        35685: 33738,
                        35686: 38816,
                        35687: 21513,
                        35688: 21507,
                        35689: 21931,
                        35690: 26708,
                        35691: 27224,
                        35692: 35440,
                        35693: 30759,
                        35694: 26485,
                        35695: 40653,
                        35696: 21364,
                        35697: 23458,
                        35698: 33050,
                        35699: 34384,
                        35700: 36870,
                        35701: 19992,
                        35702: 20037,
                        35703: 20167,
                        35704: 20241,
                        35705: 21450,
                        35706: 21560,
                        35707: 23470,
                        35708: 24339,
                        35709: 24613,
                        35710: 25937,
                        35712: 26429,
                        35713: 27714,
                        35714: 27762,
                        35715: 27875,
                        35716: 28792,
                        35717: 29699,
                        35718: 31350,
                        35719: 31406,
                        35720: 31496,
                        35721: 32026,
                        35722: 31998,
                        35723: 32102,
                        35724: 26087,
                        35725: 29275,
                        35726: 21435,
                        35727: 23621,
                        35728: 24040,
                        35729: 25298,
                        35730: 25312,
                        35731: 25369,
                        35732: 28192,
                        35733: 34394,
                        35734: 35377,
                        35735: 36317,
                        35736: 37624,
                        35737: 28417,
                        35738: 31142,
                        35739: 39770,
                        35740: 20136,
                        35741: 20139,
                        35742: 20140,
                        35743: 20379,
                        35744: 20384,
                        35745: 20689,
                        35746: 20807,
                        35747: 31478,
                        35748: 20849,
                        35749: 20982,
                        35750: 21332,
                        35751: 21281,
                        35752: 21375,
                        35753: 21483,
                        35754: 21932,
                        35755: 22659,
                        35756: 23777,
                        35757: 24375,
                        35758: 24394,
                        35759: 24623,
                        35760: 24656,
                        35761: 24685,
                        35762: 25375,
                        35763: 25945,
                        35764: 27211,
                        35765: 27841,
                        35766: 29378,
                        35767: 29421,
                        35768: 30703,
                        35769: 33016,
                        35770: 33029,
                        35771: 33288,
                        35772: 34126,
                        35773: 37111,
                        35774: 37857,
                        35775: 38911,
                        35776: 39255,
                        35777: 39514,
                        35778: 20208,
                        35779: 20957,
                        35780: 23597,
                        35781: 26241,
                        35782: 26989,
                        35783: 23616,
                        35784: 26354,
                        35785: 26997,
                        35786: 29577,
                        35787: 26704,
                        35788: 31873,
                        35789: 20677,
                        35790: 21220,
                        35791: 22343,
                        35792: 24062,
                        35793: 37670,
                        35794: 26020,
                        35795: 27427,
                        35796: 27453,
                        35797: 29748,
                        35798: 31105,
                        35799: 31165,
                        35800: 31563,
                        35801: 32202,
                        35802: 33465,
                        35803: 33740,
                        35804: 34943,
                        35805: 35167,
                        35806: 35641,
                        35807: 36817,
                        35808: 37329,
                        35809: 21535,
                        35810: 37504,
                        35811: 20061,
                        35812: 20534,
                        35813: 21477,
                        35814: 21306,
                        35815: 29399,
                        35816: 29590,
                        35817: 30697,
                        35818: 33510,
                        35819: 36527,
                        35820: 39366,
                        35821: 39368,
                        35822: 39378,
                        35823: 20855,
                        35824: 24858,
                        35825: 34398,
                        35826: 21936,
                        35827: 31354,
                        35828: 20598,
                        35829: 23507,
                        35830: 36935,
                        35831: 38533,
                        35832: 20018,
                        35833: 27355,
                        35834: 37351,
                        35835: 23633,
                        35836: 23624,
                        35904: 25496,
                        35905: 31391,
                        35906: 27795,
                        35907: 38772,
                        35908: 36705,
                        35909: 31402,
                        35910: 29066,
                        35911: 38536,
                        35912: 31874,
                        35913: 26647,
                        35914: 32368,
                        35915: 26705,
                        35916: 37740,
                        35917: 21234,
                        35918: 21531,
                        35919: 34219,
                        35920: 35347,
                        35921: 32676,
                        35922: 36557,
                        35923: 37089,
                        35924: 21350,
                        35925: 34952,
                        35926: 31041,
                        35927: 20418,
                        35928: 20670,
                        35929: 21009,
                        35930: 20804,
                        35931: 21843,
                        35932: 22317,
                        35933: 29674,
                        35934: 22411,
                        35935: 22865,
                        35936: 24418,
                        35937: 24452,
                        35938: 24693,
                        35939: 24950,
                        35940: 24935,
                        35941: 25001,
                        35942: 25522,
                        35943: 25658,
                        35944: 25964,
                        35945: 26223,
                        35946: 26690,
                        35947: 28179,
                        35948: 30054,
                        35949: 31293,
                        35950: 31995,
                        35951: 32076,
                        35952: 32153,
                        35953: 32331,
                        35954: 32619,
                        35955: 33550,
                        35956: 33610,
                        35957: 34509,
                        35958: 35336,
                        35959: 35427,
                        35960: 35686,
                        35961: 36605,
                        35962: 38938,
                        35963: 40335,
                        35964: 33464,
                        35965: 36814,
                        35966: 39912,
                        35968: 21127,
                        35969: 25119,
                        35970: 25731,
                        35971: 28608,
                        35972: 38553,
                        35973: 26689,
                        35974: 20625,
                        35975: 27424,
                        35976: 27770,
                        35977: 28500,
                        35978: 31348,
                        35979: 32080,
                        35980: 34880,
                        35981: 35363,
                        35982: 26376,
                        35983: 20214,
                        35984: 20537,
                        35985: 20518,
                        35986: 20581,
                        35987: 20860,
                        35988: 21048,
                        35989: 21091,
                        35990: 21927,
                        35991: 22287,
                        35992: 22533,
                        35993: 23244,
                        35994: 24314,
                        35995: 25010,
                        35996: 25080,
                        35997: 25331,
                        35998: 25458,
                        35999: 26908,
                        36e3: 27177,
                        36001: 29309,
                        36002: 29356,
                        36003: 29486,
                        36004: 30740,
                        36005: 30831,
                        36006: 32121,
                        36007: 30476,
                        36008: 32937,
                        36009: 35211,
                        36010: 35609,
                        36011: 36066,
                        36012: 36562,
                        36013: 36963,
                        36014: 37749,
                        36015: 38522,
                        36016: 38997,
                        36017: 39443,
                        36018: 40568,
                        36019: 20803,
                        36020: 21407,
                        36021: 21427,
                        36022: 24187,
                        36023: 24358,
                        36024: 28187,
                        36025: 28304,
                        36026: 29572,
                        36027: 29694,
                        36028: 32067,
                        36029: 33335,
                        36030: 35328,
                        36031: 35578,
                        36032: 38480,
                        36033: 20046,
                        36034: 20491,
                        36035: 21476,
                        36036: 21628,
                        36037: 22266,
                        36038: 22993,
                        36039: 23396,
                        36040: 24049,
                        36041: 24235,
                        36042: 24359,
                        36043: 25144,
                        36044: 25925,
                        36045: 26543,
                        36046: 28246,
                        36047: 29392,
                        36048: 31946,
                        36049: 34996,
                        36050: 32929,
                        36051: 32993,
                        36052: 33776,
                        36053: 34382,
                        36054: 35463,
                        36055: 36328,
                        36056: 37431,
                        36057: 38599,
                        36058: 39015,
                        36059: 40723,
                        36060: 20116,
                        36061: 20114,
                        36062: 20237,
                        36063: 21320,
                        36064: 21577,
                        36065: 21566,
                        36066: 23087,
                        36067: 24460,
                        36068: 24481,
                        36069: 24735,
                        36070: 26791,
                        36071: 27278,
                        36072: 29786,
                        36073: 30849,
                        36074: 35486,
                        36075: 35492,
                        36076: 35703,
                        36077: 37264,
                        36078: 20062,
                        36079: 39881,
                        36080: 20132,
                        36081: 20348,
                        36082: 20399,
                        36083: 20505,
                        36084: 20502,
                        36085: 20809,
                        36086: 20844,
                        36087: 21151,
                        36088: 21177,
                        36089: 21246,
                        36090: 21402,
                        36091: 21475,
                        36092: 21521,
                        36160: 21518,
                        36161: 21897,
                        36162: 22353,
                        36163: 22434,
                        36164: 22909,
                        36165: 23380,
                        36166: 23389,
                        36167: 23439,
                        36168: 24037,
                        36169: 24039,
                        36170: 24055,
                        36171: 24184,
                        36172: 24195,
                        36173: 24218,
                        36174: 24247,
                        36175: 24344,
                        36176: 24658,
                        36177: 24908,
                        36178: 25239,
                        36179: 25304,
                        36180: 25511,
                        36181: 25915,
                        36182: 26114,
                        36183: 26179,
                        36184: 26356,
                        36185: 26477,
                        36186: 26657,
                        36187: 26775,
                        36188: 27083,
                        36189: 27743,
                        36190: 27946,
                        36191: 28009,
                        36192: 28207,
                        36193: 28317,
                        36194: 30002,
                        36195: 30343,
                        36196: 30828,
                        36197: 31295,
                        36198: 31968,
                        36199: 32005,
                        36200: 32024,
                        36201: 32094,
                        36202: 32177,
                        36203: 32789,
                        36204: 32771,
                        36205: 32943,
                        36206: 32945,
                        36207: 33108,
                        36208: 33167,
                        36209: 33322,
                        36210: 33618,
                        36211: 34892,
                        36212: 34913,
                        36213: 35611,
                        36214: 36002,
                        36215: 36092,
                        36216: 37066,
                        36217: 37237,
                        36218: 37489,
                        36219: 30783,
                        36220: 37628,
                        36221: 38308,
                        36222: 38477,
                        36224: 38917,
                        36225: 39321,
                        36226: 39640,
                        36227: 40251,
                        36228: 21083,
                        36229: 21163,
                        36230: 21495,
                        36231: 21512,
                        36232: 22741,
                        36233: 25335,
                        36234: 28640,
                        36235: 35946,
                        36236: 36703,
                        36237: 40633,
                        36238: 20811,
                        36239: 21051,
                        36240: 21578,
                        36241: 22269,
                        36242: 31296,
                        36243: 37239,
                        36244: 40288,
                        36245: 40658,
                        36246: 29508,
                        36247: 28425,
                        36248: 33136,
                        36249: 29969,
                        36250: 24573,
                        36251: 24794,
                        36252: 39592,
                        36253: 29403,
                        36254: 36796,
                        36255: 27492,
                        36256: 38915,
                        36257: 20170,
                        36258: 22256,
                        36259: 22372,
                        36260: 22718,
                        36261: 23130,
                        36262: 24680,
                        36263: 25031,
                        36264: 26127,
                        36265: 26118,
                        36266: 26681,
                        36267: 26801,
                        36268: 28151,
                        36269: 30165,
                        36270: 32058,
                        36271: 33390,
                        36272: 39746,
                        36273: 20123,
                        36274: 20304,
                        36275: 21449,
                        36276: 21766,
                        36277: 23919,
                        36278: 24038,
                        36279: 24046,
                        36280: 26619,
                        36281: 27801,
                        36282: 29811,
                        36283: 30722,
                        36284: 35408,
                        36285: 37782,
                        36286: 35039,
                        36287: 22352,
                        36288: 24231,
                        36289: 25387,
                        36290: 20661,
                        36291: 20652,
                        36292: 20877,
                        36293: 26368,
                        36294: 21705,
                        36295: 22622,
                        36296: 22971,
                        36297: 23472,
                        36298: 24425,
                        36299: 25165,
                        36300: 25505,
                        36301: 26685,
                        36302: 27507,
                        36303: 28168,
                        36304: 28797,
                        36305: 37319,
                        36306: 29312,
                        36307: 30741,
                        36308: 30758,
                        36309: 31085,
                        36310: 25998,
                        36311: 32048,
                        36312: 33756,
                        36313: 35009,
                        36314: 36617,
                        36315: 38555,
                        36316: 21092,
                        36317: 22312,
                        36318: 26448,
                        36319: 32618,
                        36320: 36001,
                        36321: 20916,
                        36322: 22338,
                        36323: 38442,
                        36324: 22586,
                        36325: 27018,
                        36326: 32948,
                        36327: 21682,
                        36328: 23822,
                        36329: 22524,
                        36330: 30869,
                        36331: 40442,
                        36332: 20316,
                        36333: 21066,
                        36334: 21643,
                        36335: 25662,
                        36336: 26152,
                        36337: 26388,
                        36338: 26613,
                        36339: 31364,
                        36340: 31574,
                        36341: 32034,
                        36342: 37679,
                        36343: 26716,
                        36344: 39853,
                        36345: 31545,
                        36346: 21273,
                        36347: 20874,
                        36348: 21047,
                        36416: 23519,
                        36417: 25334,
                        36418: 25774,
                        36419: 25830,
                        36420: 26413,
                        36421: 27578,
                        36422: 34217,
                        36423: 38609,
                        36424: 30352,
                        36425: 39894,
                        36426: 25420,
                        36427: 37638,
                        36428: 39851,
                        36429: 30399,
                        36430: 26194,
                        36431: 19977,
                        36432: 20632,
                        36433: 21442,
                        36434: 23665,
                        36435: 24808,
                        36436: 25746,
                        36437: 25955,
                        36438: 26719,
                        36439: 29158,
                        36440: 29642,
                        36441: 29987,
                        36442: 31639,
                        36443: 32386,
                        36444: 34453,
                        36445: 35715,
                        36446: 36059,
                        36447: 37240,
                        36448: 39184,
                        36449: 26028,
                        36450: 26283,
                        36451: 27531,
                        36452: 20181,
                        36453: 20180,
                        36454: 20282,
                        36455: 20351,
                        36456: 21050,
                        36457: 21496,
                        36458: 21490,
                        36459: 21987,
                        36460: 22235,
                        36461: 22763,
                        36462: 22987,
                        36463: 22985,
                        36464: 23039,
                        36465: 23376,
                        36466: 23629,
                        36467: 24066,
                        36468: 24107,
                        36469: 24535,
                        36470: 24605,
                        36471: 25351,
                        36472: 25903,
                        36473: 23388,
                        36474: 26031,
                        36475: 26045,
                        36476: 26088,
                        36477: 26525,
                        36478: 27490,
                        36480: 27515,
                        36481: 27663,
                        36482: 29509,
                        36483: 31049,
                        36484: 31169,
                        36485: 31992,
                        36486: 32025,
                        36487: 32043,
                        36488: 32930,
                        36489: 33026,
                        36490: 33267,
                        36491: 35222,
                        36492: 35422,
                        36493: 35433,
                        36494: 35430,
                        36495: 35468,
                        36496: 35566,
                        36497: 36039,
                        36498: 36060,
                        36499: 38604,
                        36500: 39164,
                        36501: 27503,
                        36502: 20107,
                        36503: 20284,
                        36504: 20365,
                        36505: 20816,
                        36506: 23383,
                        36507: 23546,
                        36508: 24904,
                        36509: 25345,
                        36510: 26178,
                        36511: 27425,
                        36512: 28363,
                        36513: 27835,
                        36514: 29246,
                        36515: 29885,
                        36516: 30164,
                        36517: 30913,
                        36518: 31034,
                        36519: 32780,
                        36520: 32819,
                        36521: 33258,
                        36522: 33940,
                        36523: 36766,
                        36524: 27728,
                        36525: 40575,
                        36526: 24335,
                        36527: 35672,
                        36528: 40235,
                        36529: 31482,
                        36530: 36600,
                        36531: 23437,
                        36532: 38635,
                        36533: 19971,
                        36534: 21489,
                        36535: 22519,
                        36536: 22833,
                        36537: 23241,
                        36538: 23460,
                        36539: 24713,
                        36540: 28287,
                        36541: 28422,
                        36542: 30142,
                        36543: 36074,
                        36544: 23455,
                        36545: 34048,
                        36546: 31712,
                        36547: 20594,
                        36548: 26612,
                        36549: 33437,
                        36550: 23649,
                        36551: 34122,
                        36552: 32286,
                        36553: 33294,
                        36554: 20889,
                        36555: 23556,
                        36556: 25448,
                        36557: 36198,
                        36558: 26012,
                        36559: 29038,
                        36560: 31038,
                        36561: 32023,
                        36562: 32773,
                        36563: 35613,
                        36564: 36554,
                        36565: 36974,
                        36566: 34503,
                        36567: 37034,
                        36568: 20511,
                        36569: 21242,
                        36570: 23610,
                        36571: 26451,
                        36572: 28796,
                        36573: 29237,
                        36574: 37196,
                        36575: 37320,
                        36576: 37675,
                        36577: 33509,
                        36578: 23490,
                        36579: 24369,
                        36580: 24825,
                        36581: 20027,
                        36582: 21462,
                        36583: 23432,
                        36584: 25163,
                        36585: 26417,
                        36586: 27530,
                        36587: 29417,
                        36588: 29664,
                        36589: 31278,
                        36590: 33131,
                        36591: 36259,
                        36592: 37202,
                        36593: 39318,
                        36594: 20754,
                        36595: 21463,
                        36596: 21610,
                        36597: 23551,
                        36598: 25480,
                        36599: 27193,
                        36600: 32172,
                        36601: 38656,
                        36602: 22234,
                        36603: 21454,
                        36604: 21608,
                        36672: 23447,
                        36673: 23601,
                        36674: 24030,
                        36675: 20462,
                        36676: 24833,
                        36677: 25342,
                        36678: 27954,
                        36679: 31168,
                        36680: 31179,
                        36681: 32066,
                        36682: 32333,
                        36683: 32722,
                        36684: 33261,
                        36685: 33311,
                        36686: 33936,
                        36687: 34886,
                        36688: 35186,
                        36689: 35728,
                        36690: 36468,
                        36691: 36655,
                        36692: 36913,
                        36693: 37195,
                        36694: 37228,
                        36695: 38598,
                        36696: 37276,
                        36697: 20160,
                        36698: 20303,
                        36699: 20805,
                        36700: 21313,
                        36701: 24467,
                        36702: 25102,
                        36703: 26580,
                        36704: 27713,
                        36705: 28171,
                        36706: 29539,
                        36707: 32294,
                        36708: 37325,
                        36709: 37507,
                        36710: 21460,
                        36711: 22809,
                        36712: 23487,
                        36713: 28113,
                        36714: 31069,
                        36715: 32302,
                        36716: 31899,
                        36717: 22654,
                        36718: 29087,
                        36719: 20986,
                        36720: 34899,
                        36721: 36848,
                        36722: 20426,
                        36723: 23803,
                        36724: 26149,
                        36725: 30636,
                        36726: 31459,
                        36727: 33308,
                        36728: 39423,
                        36729: 20934,
                        36730: 24490,
                        36731: 26092,
                        36732: 26991,
                        36733: 27529,
                        36734: 28147,
                        36736: 28310,
                        36737: 28516,
                        36738: 30462,
                        36739: 32020,
                        36740: 24033,
                        36741: 36981,
                        36742: 37255,
                        36743: 38918,
                        36744: 20966,
                        36745: 21021,
                        36746: 25152,
                        36747: 26257,
                        36748: 26329,
                        36749: 28186,
                        36750: 24246,
                        36751: 32210,
                        36752: 32626,
                        36753: 26360,
                        36754: 34223,
                        36755: 34295,
                        36756: 35576,
                        36757: 21161,
                        36758: 21465,
                        36759: 22899,
                        36760: 24207,
                        36761: 24464,
                        36762: 24661,
                        36763: 37604,
                        36764: 38500,
                        36765: 20663,
                        36766: 20767,
                        36767: 21213,
                        36768: 21280,
                        36769: 21319,
                        36770: 21484,
                        36771: 21736,
                        36772: 21830,
                        36773: 21809,
                        36774: 22039,
                        36775: 22888,
                        36776: 22974,
                        36777: 23100,
                        36778: 23477,
                        36779: 23558,
                        36780: 23567,
                        36781: 23569,
                        36782: 23578,
                        36783: 24196,
                        36784: 24202,
                        36785: 24288,
                        36786: 24432,
                        36787: 25215,
                        36788: 25220,
                        36789: 25307,
                        36790: 25484,
                        36791: 25463,
                        36792: 26119,
                        36793: 26124,
                        36794: 26157,
                        36795: 26230,
                        36796: 26494,
                        36797: 26786,
                        36798: 27167,
                        36799: 27189,
                        36800: 27836,
                        36801: 28040,
                        36802: 28169,
                        36803: 28248,
                        36804: 28988,
                        36805: 28966,
                        36806: 29031,
                        36807: 30151,
                        36808: 30465,
                        36809: 30813,
                        36810: 30977,
                        36811: 31077,
                        36812: 31216,
                        36813: 31456,
                        36814: 31505,
                        36815: 31911,
                        36816: 32057,
                        36817: 32918,
                        36818: 33750,
                        36819: 33931,
                        36820: 34121,
                        36821: 34909,
                        36822: 35059,
                        36823: 35359,
                        36824: 35388,
                        36825: 35412,
                        36826: 35443,
                        36827: 35937,
                        36828: 36062,
                        36829: 37284,
                        36830: 37478,
                        36831: 37758,
                        36832: 37912,
                        36833: 38556,
                        36834: 38808,
                        36835: 19978,
                        36836: 19976,
                        36837: 19998,
                        36838: 20055,
                        36839: 20887,
                        36840: 21104,
                        36841: 22478,
                        36842: 22580,
                        36843: 22732,
                        36844: 23330,
                        36845: 24120,
                        36846: 24773,
                        36847: 25854,
                        36848: 26465,
                        36849: 26454,
                        36850: 27972,
                        36851: 29366,
                        36852: 30067,
                        36853: 31331,
                        36854: 33976,
                        36855: 35698,
                        36856: 37304,
                        36857: 37664,
                        36858: 22065,
                        36859: 22516,
                        36860: 39166,
                        36928: 25325,
                        36929: 26893,
                        36930: 27542,
                        36931: 29165,
                        36932: 32340,
                        36933: 32887,
                        36934: 33394,
                        36935: 35302,
                        36936: 39135,
                        36937: 34645,
                        36938: 36785,
                        36939: 23611,
                        36940: 20280,
                        36941: 20449,
                        36942: 20405,
                        36943: 21767,
                        36944: 23072,
                        36945: 23517,
                        36946: 23529,
                        36947: 24515,
                        36948: 24910,
                        36949: 25391,
                        36950: 26032,
                        36951: 26187,
                        36952: 26862,
                        36953: 27035,
                        36954: 28024,
                        36955: 28145,
                        36956: 30003,
                        36957: 30137,
                        36958: 30495,
                        36959: 31070,
                        36960: 31206,
                        36961: 32051,
                        36962: 33251,
                        36963: 33455,
                        36964: 34218,
                        36965: 35242,
                        36966: 35386,
                        36967: 36523,
                        36968: 36763,
                        36969: 36914,
                        36970: 37341,
                        36971: 38663,
                        36972: 20154,
                        36973: 20161,
                        36974: 20995,
                        36975: 22645,
                        36976: 22764,
                        36977: 23563,
                        36978: 29978,
                        36979: 23613,
                        36980: 33102,
                        36981: 35338,
                        36982: 36805,
                        36983: 38499,
                        36984: 38765,
                        36985: 31525,
                        36986: 35535,
                        36987: 38920,
                        36988: 37218,
                        36989: 22259,
                        36990: 21416,
                        36992: 36887,
                        36993: 21561,
                        36994: 22402,
                        36995: 24101,
                        36996: 25512,
                        36997: 27700,
                        36998: 28810,
                        36999: 30561,
                        37e3: 31883,
                        37001: 32736,
                        37002: 34928,
                        37003: 36930,
                        37004: 37204,
                        37005: 37648,
                        37006: 37656,
                        37007: 38543,
                        37008: 29790,
                        37009: 39620,
                        37010: 23815,
                        37011: 23913,
                        37012: 25968,
                        37013: 26530,
                        37014: 36264,
                        37015: 38619,
                        37016: 25454,
                        37017: 26441,
                        37018: 26905,
                        37019: 33733,
                        37020: 38935,
                        37021: 38592,
                        37022: 35070,
                        37023: 28548,
                        37024: 25722,
                        37025: 23544,
                        37026: 19990,
                        37027: 28716,
                        37028: 30045,
                        37029: 26159,
                        37030: 20932,
                        37031: 21046,
                        37032: 21218,
                        37033: 22995,
                        37034: 24449,
                        37035: 24615,
                        37036: 25104,
                        37037: 25919,
                        37038: 25972,
                        37039: 26143,
                        37040: 26228,
                        37041: 26866,
                        37042: 26646,
                        37043: 27491,
                        37044: 28165,
                        37045: 29298,
                        37046: 29983,
                        37047: 30427,
                        37048: 31934,
                        37049: 32854,
                        37050: 22768,
                        37051: 35069,
                        37052: 35199,
                        37053: 35488,
                        37054: 35475,
                        37055: 35531,
                        37056: 36893,
                        37057: 37266,
                        37058: 38738,
                        37059: 38745,
                        37060: 25993,
                        37061: 31246,
                        37062: 33030,
                        37063: 38587,
                        37064: 24109,
                        37065: 24796,
                        37066: 25114,
                        37067: 26021,
                        37068: 26132,
                        37069: 26512,
                        37070: 30707,
                        37071: 31309,
                        37072: 31821,
                        37073: 32318,
                        37074: 33034,
                        37075: 36012,
                        37076: 36196,
                        37077: 36321,
                        37078: 36447,
                        37079: 30889,
                        37080: 20999,
                        37081: 25305,
                        37082: 25509,
                        37083: 25666,
                        37084: 25240,
                        37085: 35373,
                        37086: 31363,
                        37087: 31680,
                        37088: 35500,
                        37089: 38634,
                        37090: 32118,
                        37091: 33292,
                        37092: 34633,
                        37093: 20185,
                        37094: 20808,
                        37095: 21315,
                        37096: 21344,
                        37097: 23459,
                        37098: 23554,
                        37099: 23574,
                        37100: 24029,
                        37101: 25126,
                        37102: 25159,
                        37103: 25776,
                        37104: 26643,
                        37105: 26676,
                        37106: 27849,
                        37107: 27973,
                        37108: 27927,
                        37109: 26579,
                        37110: 28508,
                        37111: 29006,
                        37112: 29053,
                        37113: 26059,
                        37114: 31359,
                        37115: 31661,
                        37116: 32218,
                        37184: 32330,
                        37185: 32680,
                        37186: 33146,
                        37187: 33307,
                        37188: 33337,
                        37189: 34214,
                        37190: 35438,
                        37191: 36046,
                        37192: 36341,
                        37193: 36984,
                        37194: 36983,
                        37195: 37549,
                        37196: 37521,
                        37197: 38275,
                        37198: 39854,
                        37199: 21069,
                        37200: 21892,
                        37201: 28472,
                        37202: 28982,
                        37203: 20840,
                        37204: 31109,
                        37205: 32341,
                        37206: 33203,
                        37207: 31950,
                        37208: 22092,
                        37209: 22609,
                        37210: 23720,
                        37211: 25514,
                        37212: 26366,
                        37213: 26365,
                        37214: 26970,
                        37215: 29401,
                        37216: 30095,
                        37217: 30094,
                        37218: 30990,
                        37219: 31062,
                        37220: 31199,
                        37221: 31895,
                        37222: 32032,
                        37223: 32068,
                        37224: 34311,
                        37225: 35380,
                        37226: 38459,
                        37227: 36961,
                        37228: 40736,
                        37229: 20711,
                        37230: 21109,
                        37231: 21452,
                        37232: 21474,
                        37233: 20489,
                        37234: 21930,
                        37235: 22766,
                        37236: 22863,
                        37237: 29245,
                        37238: 23435,
                        37239: 23652,
                        37240: 21277,
                        37241: 24803,
                        37242: 24819,
                        37243: 25436,
                        37244: 25475,
                        37245: 25407,
                        37246: 25531,
                        37248: 25805,
                        37249: 26089,
                        37250: 26361,
                        37251: 24035,
                        37252: 27085,
                        37253: 27133,
                        37254: 28437,
                        37255: 29157,
                        37256: 20105,
                        37257: 30185,
                        37258: 30456,
                        37259: 31379,
                        37260: 31967,
                        37261: 32207,
                        37262: 32156,
                        37263: 32865,
                        37264: 33609,
                        37265: 33624,
                        37266: 33900,
                        37267: 33980,
                        37268: 34299,
                        37269: 35013,
                        37270: 36208,
                        37271: 36865,
                        37272: 36973,
                        37273: 37783,
                        37274: 38684,
                        37275: 39442,
                        37276: 20687,
                        37277: 22679,
                        37278: 24974,
                        37279: 33235,
                        37280: 34101,
                        37281: 36104,
                        37282: 36896,
                        37283: 20419,
                        37284: 20596,
                        37285: 21063,
                        37286: 21363,
                        37287: 24687,
                        37288: 25417,
                        37289: 26463,
                        37290: 28204,
                        37291: 36275,
                        37292: 36895,
                        37293: 20439,
                        37294: 23646,
                        37295: 36042,
                        37296: 26063,
                        37297: 32154,
                        37298: 21330,
                        37299: 34966,
                        37300: 20854,
                        37301: 25539,
                        37302: 23384,
                        37303: 23403,
                        37304: 23562,
                        37305: 25613,
                        37306: 26449,
                        37307: 36956,
                        37308: 20182,
                        37309: 22810,
                        37310: 22826,
                        37311: 27760,
                        37312: 35409,
                        37313: 21822,
                        37314: 22549,
                        37315: 22949,
                        37316: 24816,
                        37317: 25171,
                        37318: 26561,
                        37319: 33333,
                        37320: 26965,
                        37321: 38464,
                        37322: 39364,
                        37323: 39464,
                        37324: 20307,
                        37325: 22534,
                        37326: 23550,
                        37327: 32784,
                        37328: 23729,
                        37329: 24111,
                        37330: 24453,
                        37331: 24608,
                        37332: 24907,
                        37333: 25140,
                        37334: 26367,
                        37335: 27888,
                        37336: 28382,
                        37337: 32974,
                        37338: 33151,
                        37339: 33492,
                        37340: 34955,
                        37341: 36024,
                        37342: 36864,
                        37343: 36910,
                        37344: 38538,
                        37345: 40667,
                        37346: 39899,
                        37347: 20195,
                        37348: 21488,
                        37349: 22823,
                        37350: 31532,
                        37351: 37261,
                        37352: 38988,
                        37353: 40441,
                        37354: 28381,
                        37355: 28711,
                        37356: 21331,
                        37357: 21828,
                        37358: 23429,
                        37359: 25176,
                        37360: 25246,
                        37361: 25299,
                        37362: 27810,
                        37363: 28655,
                        37364: 29730,
                        37365: 35351,
                        37366: 37944,
                        37367: 28609,
                        37368: 35582,
                        37369: 33592,
                        37370: 20967,
                        37371: 34552,
                        37372: 21482,
                        37440: 21481,
                        37441: 20294,
                        37442: 36948,
                        37443: 36784,
                        37444: 22890,
                        37445: 33073,
                        37446: 24061,
                        37447: 31466,
                        37448: 36799,
                        37449: 26842,
                        37450: 35895,
                        37451: 29432,
                        37452: 40008,
                        37453: 27197,
                        37454: 35504,
                        37455: 20025,
                        37456: 21336,
                        37457: 22022,
                        37458: 22374,
                        37459: 25285,
                        37460: 25506,
                        37461: 26086,
                        37462: 27470,
                        37463: 28129,
                        37464: 28251,
                        37465: 28845,
                        37466: 30701,
                        37467: 31471,
                        37468: 31658,
                        37469: 32187,
                        37470: 32829,
                        37471: 32966,
                        37472: 34507,
                        37473: 35477,
                        37474: 37723,
                        37475: 22243,
                        37476: 22727,
                        37477: 24382,
                        37478: 26029,
                        37479: 26262,
                        37480: 27264,
                        37481: 27573,
                        37482: 30007,
                        37483: 35527,
                        37484: 20516,
                        37485: 30693,
                        37486: 22320,
                        37487: 24347,
                        37488: 24677,
                        37489: 26234,
                        37490: 27744,
                        37491: 30196,
                        37492: 31258,
                        37493: 32622,
                        37494: 33268,
                        37495: 34584,
                        37496: 36933,
                        37497: 39347,
                        37498: 31689,
                        37499: 30044,
                        37500: 31481,
                        37501: 31569,
                        37502: 33988,
                        37504: 36880,
                        37505: 31209,
                        37506: 31378,
                        37507: 33590,
                        37508: 23265,
                        37509: 30528,
                        37510: 20013,
                        37511: 20210,
                        37512: 23449,
                        37513: 24544,
                        37514: 25277,
                        37515: 26172,
                        37516: 26609,
                        37517: 27880,
                        37518: 34411,
                        37519: 34935,
                        37520: 35387,
                        37521: 37198,
                        37522: 37619,
                        37523: 39376,
                        37524: 27159,
                        37525: 28710,
                        37526: 29482,
                        37527: 33511,
                        37528: 33879,
                        37529: 36015,
                        37530: 19969,
                        37531: 20806,
                        37532: 20939,
                        37533: 21899,
                        37534: 23541,
                        37535: 24086,
                        37536: 24115,
                        37537: 24193,
                        37538: 24340,
                        37539: 24373,
                        37540: 24427,
                        37541: 24500,
                        37542: 25074,
                        37543: 25361,
                        37544: 26274,
                        37545: 26397,
                        37546: 28526,
                        37547: 29266,
                        37548: 30010,
                        37549: 30522,
                        37550: 32884,
                        37551: 33081,
                        37552: 33144,
                        37553: 34678,
                        37554: 35519,
                        37555: 35548,
                        37556: 36229,
                        37557: 36339,
                        37558: 37530,
                        37559: 38263,
                        37560: 38914,
                        37561: 40165,
                        37562: 21189,
                        37563: 25431,
                        37564: 30452,
                        37565: 26389,
                        37566: 27784,
                        37567: 29645,
                        37568: 36035,
                        37569: 37806,
                        37570: 38515,
                        37571: 27941,
                        37572: 22684,
                        37573: 26894,
                        37574: 27084,
                        37575: 36861,
                        37576: 37786,
                        37577: 30171,
                        37578: 36890,
                        37579: 22618,
                        37580: 26626,
                        37581: 25524,
                        37582: 27131,
                        37583: 20291,
                        37584: 28460,
                        37585: 26584,
                        37586: 36795,
                        37587: 34086,
                        37588: 32180,
                        37589: 37716,
                        37590: 26943,
                        37591: 28528,
                        37592: 22378,
                        37593: 22775,
                        37594: 23340,
                        37595: 32044,
                        37596: 29226,
                        37597: 21514,
                        37598: 37347,
                        37599: 40372,
                        37600: 20141,
                        37601: 20302,
                        37602: 20572,
                        37603: 20597,
                        37604: 21059,
                        37605: 35998,
                        37606: 21576,
                        37607: 22564,
                        37608: 23450,
                        37609: 24093,
                        37610: 24213,
                        37611: 24237,
                        37612: 24311,
                        37613: 24351,
                        37614: 24716,
                        37615: 25269,
                        37616: 25402,
                        37617: 25552,
                        37618: 26799,
                        37619: 27712,
                        37620: 30855,
                        37621: 31118,
                        37622: 31243,
                        37623: 32224,
                        37624: 33351,
                        37625: 35330,
                        37626: 35558,
                        37627: 36420,
                        37628: 36883,
                        37696: 37048,
                        37697: 37165,
                        37698: 37336,
                        37699: 40718,
                        37700: 27877,
                        37701: 25688,
                        37702: 25826,
                        37703: 25973,
                        37704: 28404,
                        37705: 30340,
                        37706: 31515,
                        37707: 36969,
                        37708: 37841,
                        37709: 28346,
                        37710: 21746,
                        37711: 24505,
                        37712: 25764,
                        37713: 36685,
                        37714: 36845,
                        37715: 37444,
                        37716: 20856,
                        37717: 22635,
                        37718: 22825,
                        37719: 23637,
                        37720: 24215,
                        37721: 28155,
                        37722: 32399,
                        37723: 29980,
                        37724: 36028,
                        37725: 36578,
                        37726: 39003,
                        37727: 28857,
                        37728: 20253,
                        37729: 27583,
                        37730: 28593,
                        37731: 3e4,
                        37732: 38651,
                        37733: 20814,
                        37734: 21520,
                        37735: 22581,
                        37736: 22615,
                        37737: 22956,
                        37738: 23648,
                        37739: 24466,
                        37740: 26007,
                        37741: 26460,
                        37742: 28193,
                        37743: 30331,
                        37744: 33759,
                        37745: 36077,
                        37746: 36884,
                        37747: 37117,
                        37748: 37709,
                        37749: 30757,
                        37750: 30778,
                        37751: 21162,
                        37752: 24230,
                        37753: 22303,
                        37754: 22900,
                        37755: 24594,
                        37756: 20498,
                        37757: 20826,
                        37758: 20908,
                        37760: 20941,
                        37761: 20992,
                        37762: 21776,
                        37763: 22612,
                        37764: 22616,
                        37765: 22871,
                        37766: 23445,
                        37767: 23798,
                        37768: 23947,
                        37769: 24764,
                        37770: 25237,
                        37771: 25645,
                        37772: 26481,
                        37773: 26691,
                        37774: 26812,
                        37775: 26847,
                        37776: 30423,
                        37777: 28120,
                        37778: 28271,
                        37779: 28059,
                        37780: 28783,
                        37781: 29128,
                        37782: 24403,
                        37783: 30168,
                        37784: 31095,
                        37785: 31561,
                        37786: 31572,
                        37787: 31570,
                        37788: 31958,
                        37789: 32113,
                        37790: 21040,
                        37791: 33891,
                        37792: 34153,
                        37793: 34276,
                        37794: 35342,
                        37795: 35588,
                        37796: 35910,
                        37797: 36367,
                        37798: 36867,
                        37799: 36879,
                        37800: 37913,
                        37801: 38518,
                        37802: 38957,
                        37803: 39472,
                        37804: 38360,
                        37805: 20685,
                        37806: 21205,
                        37807: 21516,
                        37808: 22530,
                        37809: 23566,
                        37810: 24999,
                        37811: 25758,
                        37812: 27934,
                        37813: 30643,
                        37814: 31461,
                        37815: 33012,
                        37816: 33796,
                        37817: 36947,
                        37818: 37509,
                        37819: 23776,
                        37820: 40199,
                        37821: 21311,
                        37822: 24471,
                        37823: 24499,
                        37824: 28060,
                        37825: 29305,
                        37826: 30563,
                        37827: 31167,
                        37828: 31716,
                        37829: 27602,
                        37830: 29420,
                        37831: 35501,
                        37832: 26627,
                        37833: 27233,
                        37834: 20984,
                        37835: 31361,
                        37836: 26932,
                        37837: 23626,
                        37838: 40182,
                        37839: 33515,
                        37840: 23493,
                        37841: 37193,
                        37842: 28702,
                        37843: 22136,
                        37844: 23663,
                        37845: 24775,
                        37846: 25958,
                        37847: 27788,
                        37848: 35930,
                        37849: 36929,
                        37850: 38931,
                        37851: 21585,
                        37852: 26311,
                        37853: 37389,
                        37854: 22856,
                        37855: 37027,
                        37856: 20869,
                        37857: 20045,
                        37858: 20970,
                        37859: 34201,
                        37860: 35598,
                        37861: 28760,
                        37862: 25466,
                        37863: 37707,
                        37864: 26978,
                        37865: 39348,
                        37866: 32260,
                        37867: 30071,
                        37868: 21335,
                        37869: 26976,
                        37870: 36575,
                        37871: 38627,
                        37872: 27741,
                        37873: 20108,
                        37874: 23612,
                        37875: 24336,
                        37876: 36841,
                        37877: 21250,
                        37878: 36049,
                        37879: 32905,
                        37880: 34425,
                        37881: 24319,
                        37882: 26085,
                        37883: 20083,
                        37884: 20837,
                        37952: 22914,
                        37953: 23615,
                        37954: 38894,
                        37955: 20219,
                        37956: 22922,
                        37957: 24525,
                        37958: 35469,
                        37959: 28641,
                        37960: 31152,
                        37961: 31074,
                        37962: 23527,
                        37963: 33905,
                        37964: 29483,
                        37965: 29105,
                        37966: 24180,
                        37967: 24565,
                        37968: 25467,
                        37969: 25754,
                        37970: 29123,
                        37971: 31896,
                        37972: 20035,
                        37973: 24316,
                        37974: 20043,
                        37975: 22492,
                        37976: 22178,
                        37977: 24745,
                        37978: 28611,
                        37979: 32013,
                        37980: 33021,
                        37981: 33075,
                        37982: 33215,
                        37983: 36786,
                        37984: 35223,
                        37985: 34468,
                        37986: 24052,
                        37987: 25226,
                        37988: 25773,
                        37989: 35207,
                        37990: 26487,
                        37991: 27874,
                        37992: 27966,
                        37993: 29750,
                        37994: 30772,
                        37995: 23110,
                        37996: 32629,
                        37997: 33453,
                        37998: 39340,
                        37999: 20467,
                        38e3: 24259,
                        38001: 25309,
                        38002: 25490,
                        38003: 25943,
                        38004: 26479,
                        38005: 30403,
                        38006: 29260,
                        38007: 32972,
                        38008: 32954,
                        38009: 36649,
                        38010: 37197,
                        38011: 20493,
                        38012: 22521,
                        38013: 23186,
                        38014: 26757,
                        38016: 26995,
                        38017: 29028,
                        38018: 29437,
                        38019: 36023,
                        38020: 22770,
                        38021: 36064,
                        38022: 38506,
                        38023: 36889,
                        38024: 34687,
                        38025: 31204,
                        38026: 30695,
                        38027: 33833,
                        38028: 20271,
                        38029: 21093,
                        38030: 21338,
                        38031: 25293,
                        38032: 26575,
                        38033: 27850,
                        38034: 30333,
                        38035: 31636,
                        38036: 31893,
                        38037: 33334,
                        38038: 34180,
                        38039: 36843,
                        38040: 26333,
                        38041: 28448,
                        38042: 29190,
                        38043: 32283,
                        38044: 33707,
                        38045: 39361,
                        38046: 40614,
                        38047: 20989,
                        38048: 31665,
                        38049: 30834,
                        38050: 31672,
                        38051: 32903,
                        38052: 31560,
                        38053: 27368,
                        38054: 24161,
                        38055: 32908,
                        38056: 30033,
                        38057: 30048,
                        38058: 20843,
                        38059: 37474,
                        38060: 28300,
                        38061: 30330,
                        38062: 37271,
                        38063: 39658,
                        38064: 20240,
                        38065: 32624,
                        38066: 25244,
                        38067: 31567,
                        38068: 38309,
                        38069: 40169,
                        38070: 22138,
                        38071: 22617,
                        38072: 34532,
                        38073: 38588,
                        38074: 20276,
                        38075: 21028,
                        38076: 21322,
                        38077: 21453,
                        38078: 21467,
                        38079: 24070,
                        38080: 25644,
                        38081: 26001,
                        38082: 26495,
                        38083: 27710,
                        38084: 27726,
                        38085: 29256,
                        38086: 29359,
                        38087: 29677,
                        38088: 30036,
                        38089: 32321,
                        38090: 33324,
                        38091: 34281,
                        38092: 36009,
                        38093: 31684,
                        38094: 37318,
                        38095: 29033,
                        38096: 38930,
                        38097: 39151,
                        38098: 25405,
                        38099: 26217,
                        38100: 30058,
                        38101: 30436,
                        38102: 30928,
                        38103: 34115,
                        38104: 34542,
                        38105: 21290,
                        38106: 21329,
                        38107: 21542,
                        38108: 22915,
                        38109: 24199,
                        38110: 24444,
                        38111: 24754,
                        38112: 25161,
                        38113: 25209,
                        38114: 25259,
                        38115: 26e3,
                        38116: 27604,
                        38117: 27852,
                        38118: 30130,
                        38119: 30382,
                        38120: 30865,
                        38121: 31192,
                        38122: 32203,
                        38123: 32631,
                        38124: 32933,
                        38125: 34987,
                        38126: 35513,
                        38127: 36027,
                        38128: 36991,
                        38129: 38750,
                        38130: 39131,
                        38131: 27147,
                        38132: 31800,
                        38133: 20633,
                        38134: 23614,
                        38135: 24494,
                        38136: 26503,
                        38137: 27608,
                        38138: 29749,
                        38139: 30473,
                        38140: 32654,
                        38208: 40763,
                        38209: 26570,
                        38210: 31255,
                        38211: 21305,
                        38212: 30091,
                        38213: 39661,
                        38214: 24422,
                        38215: 33181,
                        38216: 33777,
                        38217: 32920,
                        38218: 24380,
                        38219: 24517,
                        38220: 30050,
                        38221: 31558,
                        38222: 36924,
                        38223: 26727,
                        38224: 23019,
                        38225: 23195,
                        38226: 32016,
                        38227: 30334,
                        38228: 35628,
                        38229: 20469,
                        38230: 24426,
                        38231: 27161,
                        38232: 27703,
                        38233: 28418,
                        38234: 29922,
                        38235: 31080,
                        38236: 34920,
                        38237: 35413,
                        38238: 35961,
                        38239: 24287,
                        38240: 25551,
                        38241: 30149,
                        38242: 31186,
                        38243: 33495,
                        38244: 37672,
                        38245: 37618,
                        38246: 33948,
                        38247: 34541,
                        38248: 39981,
                        38249: 21697,
                        38250: 24428,
                        38251: 25996,
                        38252: 27996,
                        38253: 28693,
                        38254: 36007,
                        38255: 36051,
                        38256: 38971,
                        38257: 25935,
                        38258: 29942,
                        38259: 19981,
                        38260: 20184,
                        38261: 22496,
                        38262: 22827,
                        38263: 23142,
                        38264: 23500,
                        38265: 20904,
                        38266: 24067,
                        38267: 24220,
                        38268: 24598,
                        38269: 25206,
                        38270: 25975,
                        38272: 26023,
                        38273: 26222,
                        38274: 28014,
                        38275: 29238,
                        38276: 31526,
                        38277: 33104,
                        38278: 33178,
                        38279: 33433,
                        38280: 35676,
                        38281: 36e3,
                        38282: 36070,
                        38283: 36212,
                        38284: 38428,
                        38285: 38468,
                        38286: 20398,
                        38287: 25771,
                        38288: 27494,
                        38289: 33310,
                        38290: 33889,
                        38291: 34154,
                        38292: 37096,
                        38293: 23553,
                        38294: 26963,
                        38295: 39080,
                        38296: 33914,
                        38297: 34135,
                        38298: 20239,
                        38299: 21103,
                        38300: 24489,
                        38301: 24133,
                        38302: 26381,
                        38303: 31119,
                        38304: 33145,
                        38305: 35079,
                        38306: 35206,
                        38307: 28149,
                        38308: 24343,
                        38309: 25173,
                        38310: 27832,
                        38311: 20175,
                        38312: 29289,
                        38313: 39826,
                        38314: 20998,
                        38315: 21563,
                        38316: 22132,
                        38317: 22707,
                        38318: 24996,
                        38319: 25198,
                        38320: 28954,
                        38321: 22894,
                        38322: 31881,
                        38323: 31966,
                        38324: 32027,
                        38325: 38640,
                        38326: 25991,
                        38327: 32862,
                        38328: 19993,
                        38329: 20341,
                        38330: 20853,
                        38331: 22592,
                        38332: 24163,
                        38333: 24179,
                        38334: 24330,
                        38335: 26564,
                        38336: 20006,
                        38337: 34109,
                        38338: 38281,
                        38339: 38491,
                        38340: 31859,
                        38341: 38913,
                        38342: 20731,
                        38343: 22721,
                        38344: 30294,
                        38345: 30887,
                        38346: 21029,
                        38347: 30629,
                        38348: 34065,
                        38349: 31622,
                        38350: 20559,
                        38351: 22793,
                        38352: 29255,
                        38353: 31687,
                        38354: 32232,
                        38355: 36794,
                        38356: 36820,
                        38357: 36941,
                        38358: 20415,
                        38359: 21193,
                        38360: 23081,
                        38361: 24321,
                        38362: 38829,
                        38363: 20445,
                        38364: 33303,
                        38365: 37610,
                        38366: 22275,
                        38367: 25429,
                        38368: 27497,
                        38369: 29995,
                        38370: 35036,
                        38371: 36628,
                        38372: 31298,
                        38373: 21215,
                        38374: 22675,
                        38375: 24917,
                        38376: 25098,
                        38377: 26286,
                        38378: 27597,
                        38379: 31807,
                        38380: 33769,
                        38381: 20515,
                        38382: 20472,
                        38383: 21253,
                        38384: 21574,
                        38385: 22577,
                        38386: 22857,
                        38387: 23453,
                        38388: 23792,
                        38389: 23791,
                        38390: 23849,
                        38391: 24214,
                        38392: 25265,
                        38393: 25447,
                        38394: 25918,
                        38395: 26041,
                        38396: 26379,
                        38464: 27861,
                        38465: 27873,
                        38466: 28921,
                        38467: 30770,
                        38468: 32299,
                        38469: 32990,
                        38470: 33459,
                        38471: 33804,
                        38472: 34028,
                        38473: 34562,
                        38474: 35090,
                        38475: 35370,
                        38476: 35914,
                        38477: 37030,
                        38478: 37586,
                        38479: 39165,
                        38480: 40179,
                        38481: 40300,
                        38482: 20047,
                        38483: 20129,
                        38484: 20621,
                        38485: 21078,
                        38486: 22346,
                        38487: 22952,
                        38488: 24125,
                        38489: 24536,
                        38490: 24537,
                        38491: 25151,
                        38492: 26292,
                        38493: 26395,
                        38494: 26576,
                        38495: 26834,
                        38496: 20882,
                        38497: 32033,
                        38498: 32938,
                        38499: 33192,
                        38500: 35584,
                        38501: 35980,
                        38502: 36031,
                        38503: 37502,
                        38504: 38450,
                        38505: 21536,
                        38506: 38956,
                        38507: 21271,
                        38508: 20693,
                        38509: 21340,
                        38510: 22696,
                        38511: 25778,
                        38512: 26420,
                        38513: 29287,
                        38514: 30566,
                        38515: 31302,
                        38516: 37350,
                        38517: 21187,
                        38518: 27809,
                        38519: 27526,
                        38520: 22528,
                        38521: 24140,
                        38522: 22868,
                        38523: 26412,
                        38524: 32763,
                        38525: 20961,
                        38526: 30406,
                        38528: 25705,
                        38529: 30952,
                        38530: 39764,
                        38531: 40635,
                        38532: 22475,
                        38533: 22969,
                        38534: 26151,
                        38535: 26522,
                        38536: 27598,
                        38537: 21737,
                        38538: 27097,
                        38539: 24149,
                        38540: 33180,
                        38541: 26517,
                        38542: 39850,
                        38543: 26622,
                        38544: 40018,
                        38545: 26717,
                        38546: 20134,
                        38547: 20451,
                        38548: 21448,
                        38549: 25273,
                        38550: 26411,
                        38551: 27819,
                        38552: 36804,
                        38553: 20397,
                        38554: 32365,
                        38555: 40639,
                        38556: 19975,
                        38557: 24930,
                        38558: 28288,
                        38559: 28459,
                        38560: 34067,
                        38561: 21619,
                        38562: 26410,
                        38563: 39749,
                        38564: 24051,
                        38565: 31637,
                        38566: 23724,
                        38567: 23494,
                        38568: 34588,
                        38569: 28234,
                        38570: 34001,
                        38571: 31252,
                        38572: 33032,
                        38573: 22937,
                        38574: 31885,
                        38575: 27665,
                        38576: 30496,
                        38577: 21209,
                        38578: 22818,
                        38579: 28961,
                        38580: 29279,
                        38581: 30683,
                        38582: 38695,
                        38583: 40289,
                        38584: 26891,
                        38585: 23167,
                        38586: 23064,
                        38587: 20901,
                        38588: 21517,
                        38589: 21629,
                        38590: 26126,
                        38591: 30431,
                        38592: 36855,
                        38593: 37528,
                        38594: 40180,
                        38595: 23018,
                        38596: 29277,
                        38597: 28357,
                        38598: 20813,
                        38599: 26825,
                        38600: 32191,
                        38601: 32236,
                        38602: 38754,
                        38603: 40634,
                        38604: 25720,
                        38605: 27169,
                        38606: 33538,
                        38607: 22916,
                        38608: 23391,
                        38609: 27611,
                        38610: 29467,
                        38611: 30450,
                        38612: 32178,
                        38613: 32791,
                        38614: 33945,
                        38615: 20786,
                        38616: 26408,
                        38617: 40665,
                        38618: 30446,
                        38619: 26466,
                        38620: 21247,
                        38621: 39173,
                        38622: 23588,
                        38623: 25147,
                        38624: 31870,
                        38625: 36016,
                        38626: 21839,
                        38627: 24758,
                        38628: 32011,
                        38629: 38272,
                        38630: 21249,
                        38631: 20063,
                        38632: 20918,
                        38633: 22812,
                        38634: 29242,
                        38635: 32822,
                        38636: 37326,
                        38637: 24357,
                        38638: 30690,
                        38639: 21380,
                        38640: 24441,
                        38641: 32004,
                        38642: 34220,
                        38643: 35379,
                        38644: 36493,
                        38645: 38742,
                        38646: 26611,
                        38647: 34222,
                        38648: 37971,
                        38649: 24841,
                        38650: 24840,
                        38651: 27833,
                        38652: 30290,
                        38720: 35565,
                        38721: 36664,
                        38722: 21807,
                        38723: 20305,
                        38724: 20778,
                        38725: 21191,
                        38726: 21451,
                        38727: 23461,
                        38728: 24189,
                        38729: 24736,
                        38730: 24962,
                        38731: 25558,
                        38732: 26377,
                        38733: 26586,
                        38734: 28263,
                        38735: 28044,
                        38736: 29494,
                        38737: 29495,
                        38738: 30001,
                        38739: 31056,
                        38740: 35029,
                        38741: 35480,
                        38742: 36938,
                        38743: 37009,
                        38744: 37109,
                        38745: 38596,
                        38746: 34701,
                        38747: 22805,
                        38748: 20104,
                        38749: 20313,
                        38750: 19982,
                        38751: 35465,
                        38752: 36671,
                        38753: 38928,
                        38754: 20653,
                        38755: 24188,
                        38756: 22934,
                        38757: 23481,
                        38758: 24248,
                        38759: 25562,
                        38760: 25594,
                        38761: 25793,
                        38762: 26332,
                        38763: 26954,
                        38764: 27096,
                        38765: 27915,
                        38766: 28342,
                        38767: 29076,
                        38768: 29992,
                        38769: 31407,
                        38770: 32650,
                        38771: 32768,
                        38772: 33865,
                        38773: 33993,
                        38774: 35201,
                        38775: 35617,
                        38776: 36362,
                        38777: 36965,
                        38778: 38525,
                        38779: 39178,
                        38780: 24958,
                        38781: 25233,
                        38782: 27442,
                        38784: 27779,
                        38785: 28020,
                        38786: 32716,
                        38787: 32764,
                        38788: 28096,
                        38789: 32645,
                        38790: 34746,
                        38791: 35064,
                        38792: 26469,
                        38793: 33713,
                        38794: 38972,
                        38795: 38647,
                        38796: 27931,
                        38797: 32097,
                        38798: 33853,
                        38799: 37226,
                        38800: 20081,
                        38801: 21365,
                        38802: 23888,
                        38803: 27396,
                        38804: 28651,
                        38805: 34253,
                        38806: 34349,
                        38807: 35239,
                        38808: 21033,
                        38809: 21519,
                        38810: 23653,
                        38811: 26446,
                        38812: 26792,
                        38813: 29702,
                        38814: 29827,
                        38815: 30178,
                        38816: 35023,
                        38817: 35041,
                        38818: 37324,
                        38819: 38626,
                        38820: 38520,
                        38821: 24459,
                        38822: 29575,
                        38823: 31435,
                        38824: 33870,
                        38825: 25504,
                        38826: 30053,
                        38827: 21129,
                        38828: 27969,
                        38829: 28316,
                        38830: 29705,
                        38831: 30041,
                        38832: 30827,
                        38833: 31890,
                        38834: 38534,
                        38835: 31452,
                        38836: 40845,
                        38837: 20406,
                        38838: 24942,
                        38839: 26053,
                        38840: 34396,
                        38841: 20102,
                        38842: 20142,
                        38843: 20698,
                        38844: 20001,
                        38845: 20940,
                        38846: 23534,
                        38847: 26009,
                        38848: 26753,
                        38849: 28092,
                        38850: 29471,
                        38851: 30274,
                        38852: 30637,
                        38853: 31260,
                        38854: 31975,
                        38855: 33391,
                        38856: 35538,
                        38857: 36988,
                        38858: 37327,
                        38859: 38517,
                        38860: 38936,
                        38861: 21147,
                        38862: 32209,
                        38863: 20523,
                        38864: 21400,
                        38865: 26519,
                        38866: 28107,
                        38867: 29136,
                        38868: 29747,
                        38869: 33256,
                        38870: 36650,
                        38871: 38563,
                        38872: 40023,
                        38873: 40607,
                        38874: 29792,
                        38875: 22593,
                        38876: 28057,
                        38877: 32047,
                        38878: 39006,
                        38879: 20196,
                        38880: 20278,
                        38881: 20363,
                        38882: 20919,
                        38883: 21169,
                        38884: 23994,
                        38885: 24604,
                        38886: 29618,
                        38887: 31036,
                        38888: 33491,
                        38889: 37428,
                        38890: 38583,
                        38891: 38646,
                        38892: 38666,
                        38893: 40599,
                        38894: 40802,
                        38895: 26278,
                        38896: 27508,
                        38897: 21015,
                        38898: 21155,
                        38899: 28872,
                        38900: 35010,
                        38901: 24265,
                        38902: 24651,
                        38903: 24976,
                        38904: 28451,
                        38905: 29001,
                        38906: 31806,
                        38907: 32244,
                        38908: 32879,
                        38976: 34030,
                        38977: 36899,
                        38978: 37676,
                        38979: 21570,
                        38980: 39791,
                        38981: 27347,
                        38982: 28809,
                        38983: 36034,
                        38984: 36335,
                        38985: 38706,
                        38986: 21172,
                        38987: 23105,
                        38988: 24266,
                        38989: 24324,
                        38990: 26391,
                        38991: 27004,
                        38992: 27028,
                        38993: 28010,
                        38994: 28431,
                        38995: 29282,
                        38996: 29436,
                        38997: 31725,
                        38998: 32769,
                        38999: 32894,
                        39e3: 34635,
                        39001: 37070,
                        39002: 20845,
                        39003: 40595,
                        39004: 31108,
                        39005: 32907,
                        39006: 37682,
                        39007: 35542,
                        39008: 20525,
                        39009: 21644,
                        39010: 35441,
                        39011: 27498,
                        39012: 36036,
                        39013: 33031,
                        39014: 24785,
                        39015: 26528,
                        39016: 40434,
                        39017: 20121,
                        39018: 20120,
                        39019: 39952,
                        39020: 35435,
                        39021: 34241,
                        39022: 34152,
                        39023: 26880,
                        39024: 28286,
                        39025: 30871,
                        39026: 33109,
                        39071: 24332,
                        39072: 19984,
                        39073: 19989,
                        39074: 20010,
                        39075: 20017,
                        39076: 20022,
                        39077: 20028,
                        39078: 20031,
                        39079: 20034,
                        39080: 20054,
                        39081: 20056,
                        39082: 20098,
                        39083: 20101,
                        39084: 35947,
                        39085: 20106,
                        39086: 33298,
                        39087: 24333,
                        39088: 20110,
                        39089: 20126,
                        39090: 20127,
                        39091: 20128,
                        39092: 20130,
                        39093: 20144,
                        39094: 20147,
                        39095: 20150,
                        39096: 20174,
                        39097: 20173,
                        39098: 20164,
                        39099: 20166,
                        39100: 20162,
                        39101: 20183,
                        39102: 20190,
                        39103: 20205,
                        39104: 20191,
                        39105: 20215,
                        39106: 20233,
                        39107: 20314,
                        39108: 20272,
                        39109: 20315,
                        39110: 20317,
                        39111: 20311,
                        39112: 20295,
                        39113: 20342,
                        39114: 20360,
                        39115: 20367,
                        39116: 20376,
                        39117: 20347,
                        39118: 20329,
                        39119: 20336,
                        39120: 20369,
                        39121: 20335,
                        39122: 20358,
                        39123: 20374,
                        39124: 20760,
                        39125: 20436,
                        39126: 20447,
                        39127: 20430,
                        39128: 20440,
                        39129: 20443,
                        39130: 20433,
                        39131: 20442,
                        39132: 20432,
                        39133: 20452,
                        39134: 20453,
                        39135: 20506,
                        39136: 20520,
                        39137: 20500,
                        39138: 20522,
                        39139: 20517,
                        39140: 20485,
                        39141: 20252,
                        39142: 20470,
                        39143: 20513,
                        39144: 20521,
                        39145: 20524,
                        39146: 20478,
                        39147: 20463,
                        39148: 20497,
                        39149: 20486,
                        39150: 20547,
                        39151: 20551,
                        39152: 26371,
                        39153: 20565,
                        39154: 20560,
                        39155: 20552,
                        39156: 20570,
                        39157: 20566,
                        39158: 20588,
                        39159: 20600,
                        39160: 20608,
                        39161: 20634,
                        39162: 20613,
                        39163: 20660,
                        39164: 20658,
                        39232: 20681,
                        39233: 20682,
                        39234: 20659,
                        39235: 20674,
                        39236: 20694,
                        39237: 20702,
                        39238: 20709,
                        39239: 20717,
                        39240: 20707,
                        39241: 20718,
                        39242: 20729,
                        39243: 20725,
                        39244: 20745,
                        39245: 20737,
                        39246: 20738,
                        39247: 20758,
                        39248: 20757,
                        39249: 20756,
                        39250: 20762,
                        39251: 20769,
                        39252: 20794,
                        39253: 20791,
                        39254: 20796,
                        39255: 20795,
                        39256: 20799,
                        39257: 20800,
                        39258: 20818,
                        39259: 20812,
                        39260: 20820,
                        39261: 20834,
                        39262: 31480,
                        39263: 20841,
                        39264: 20842,
                        39265: 20846,
                        39266: 20864,
                        39267: 20866,
                        39268: 22232,
                        39269: 20876,
                        39270: 20873,
                        39271: 20879,
                        39272: 20881,
                        39273: 20883,
                        39274: 20885,
                        39275: 20886,
                        39276: 20900,
                        39277: 20902,
                        39278: 20898,
                        39279: 20905,
                        39280: 20906,
                        39281: 20907,
                        39282: 20915,
                        39283: 20913,
                        39284: 20914,
                        39285: 20912,
                        39286: 20917,
                        39287: 20925,
                        39288: 20933,
                        39289: 20937,
                        39290: 20955,
                        39291: 20960,
                        39292: 34389,
                        39293: 20969,
                        39294: 20973,
                        39296: 20976,
                        39297: 20981,
                        39298: 20990,
                        39299: 20996,
                        39300: 21003,
                        39301: 21012,
                        39302: 21006,
                        39303: 21031,
                        39304: 21034,
                        39305: 21038,
                        39306: 21043,
                        39307: 21049,
                        39308: 21071,
                        39309: 21060,
                        39310: 21067,
                        39311: 21068,
                        39312: 21086,
                        39313: 21076,
                        39314: 21098,
                        39315: 21108,
                        39316: 21097,
                        39317: 21107,
                        39318: 21119,
                        39319: 21117,
                        39320: 21133,
                        39321: 21140,
                        39322: 21138,
                        39323: 21105,
                        39324: 21128,
                        39325: 21137,
                        39326: 36776,
                        39327: 36775,
                        39328: 21164,
                        39329: 21165,
                        39330: 21180,
                        39331: 21173,
                        39332: 21185,
                        39333: 21197,
                        39334: 21207,
                        39335: 21214,
                        39336: 21219,
                        39337: 21222,
                        39338: 39149,
                        39339: 21216,
                        39340: 21235,
                        39341: 21237,
                        39342: 21240,
                        39343: 21241,
                        39344: 21254,
                        39345: 21256,
                        39346: 30008,
                        39347: 21261,
                        39348: 21264,
                        39349: 21263,
                        39350: 21269,
                        39351: 21274,
                        39352: 21283,
                        39353: 21295,
                        39354: 21297,
                        39355: 21299,
                        39356: 21304,
                        39357: 21312,
                        39358: 21318,
                        39359: 21317,
                        39360: 19991,
                        39361: 21321,
                        39362: 21325,
                        39363: 20950,
                        39364: 21342,
                        39365: 21353,
                        39366: 21358,
                        39367: 22808,
                        39368: 21371,
                        39369: 21367,
                        39370: 21378,
                        39371: 21398,
                        39372: 21408,
                        39373: 21414,
                        39374: 21413,
                        39375: 21422,
                        39376: 21424,
                        39377: 21430,
                        39378: 21443,
                        39379: 31762,
                        39380: 38617,
                        39381: 21471,
                        39382: 26364,
                        39383: 29166,
                        39384: 21486,
                        39385: 21480,
                        39386: 21485,
                        39387: 21498,
                        39388: 21505,
                        39389: 21565,
                        39390: 21568,
                        39391: 21548,
                        39392: 21549,
                        39393: 21564,
                        39394: 21550,
                        39395: 21558,
                        39396: 21545,
                        39397: 21533,
                        39398: 21582,
                        39399: 21647,
                        39400: 21621,
                        39401: 21646,
                        39402: 21599,
                        39403: 21617,
                        39404: 21623,
                        39405: 21616,
                        39406: 21650,
                        39407: 21627,
                        39408: 21632,
                        39409: 21622,
                        39410: 21636,
                        39411: 21648,
                        39412: 21638,
                        39413: 21703,
                        39414: 21666,
                        39415: 21688,
                        39416: 21669,
                        39417: 21676,
                        39418: 21700,
                        39419: 21704,
                        39420: 21672,
                        39488: 21675,
                        39489: 21698,
                        39490: 21668,
                        39491: 21694,
                        39492: 21692,
                        39493: 21720,
                        39494: 21733,
                        39495: 21734,
                        39496: 21775,
                        39497: 21780,
                        39498: 21757,
                        39499: 21742,
                        39500: 21741,
                        39501: 21754,
                        39502: 21730,
                        39503: 21817,
                        39504: 21824,
                        39505: 21859,
                        39506: 21836,
                        39507: 21806,
                        39508: 21852,
                        39509: 21829,
                        39510: 21846,
                        39511: 21847,
                        39512: 21816,
                        39513: 21811,
                        39514: 21853,
                        39515: 21913,
                        39516: 21888,
                        39517: 21679,
                        39518: 21898,
                        39519: 21919,
                        39520: 21883,
                        39521: 21886,
                        39522: 21912,
                        39523: 21918,
                        39524: 21934,
                        39525: 21884,
                        39526: 21891,
                        39527: 21929,
                        39528: 21895,
                        39529: 21928,
                        39530: 21978,
                        39531: 21957,
                        39532: 21983,
                        39533: 21956,
                        39534: 21980,
                        39535: 21988,
                        39536: 21972,
                        39537: 22036,
                        39538: 22007,
                        39539: 22038,
                        39540: 22014,
                        39541: 22013,
                        39542: 22043,
                        39543: 22009,
                        39544: 22094,
                        39545: 22096,
                        39546: 29151,
                        39547: 22068,
                        39548: 22070,
                        39549: 22066,
                        39550: 22072,
                        39552: 22123,
                        39553: 22116,
                        39554: 22063,
                        39555: 22124,
                        39556: 22122,
                        39557: 22150,
                        39558: 22144,
                        39559: 22154,
                        39560: 22176,
                        39561: 22164,
                        39562: 22159,
                        39563: 22181,
                        39564: 22190,
                        39565: 22198,
                        39566: 22196,
                        39567: 22210,
                        39568: 22204,
                        39569: 22209,
                        39570: 22211,
                        39571: 22208,
                        39572: 22216,
                        39573: 22222,
                        39574: 22225,
                        39575: 22227,
                        39576: 22231,
                        39577: 22254,
                        39578: 22265,
                        39579: 22272,
                        39580: 22271,
                        39581: 22276,
                        39582: 22281,
                        39583: 22280,
                        39584: 22283,
                        39585: 22285,
                        39586: 22291,
                        39587: 22296,
                        39588: 22294,
                        39589: 21959,
                        39590: 22300,
                        39591: 22310,
                        39592: 22327,
                        39593: 22328,
                        39594: 22350,
                        39595: 22331,
                        39596: 22336,
                        39597: 22351,
                        39598: 22377,
                        39599: 22464,
                        39600: 22408,
                        39601: 22369,
                        39602: 22399,
                        39603: 22409,
                        39604: 22419,
                        39605: 22432,
                        39606: 22451,
                        39607: 22436,
                        39608: 22442,
                        39609: 22448,
                        39610: 22467,
                        39611: 22470,
                        39612: 22484,
                        39613: 22482,
                        39614: 22483,
                        39615: 22538,
                        39616: 22486,
                        39617: 22499,
                        39618: 22539,
                        39619: 22553,
                        39620: 22557,
                        39621: 22642,
                        39622: 22561,
                        39623: 22626,
                        39624: 22603,
                        39625: 22640,
                        39626: 27584,
                        39627: 22610,
                        39628: 22589,
                        39629: 22649,
                        39630: 22661,
                        39631: 22713,
                        39632: 22687,
                        39633: 22699,
                        39634: 22714,
                        39635: 22750,
                        39636: 22715,
                        39637: 22712,
                        39638: 22702,
                        39639: 22725,
                        39640: 22739,
                        39641: 22737,
                        39642: 22743,
                        39643: 22745,
                        39644: 22744,
                        39645: 22757,
                        39646: 22748,
                        39647: 22756,
                        39648: 22751,
                        39649: 22767,
                        39650: 22778,
                        39651: 22777,
                        39652: 22779,
                        39653: 22780,
                        39654: 22781,
                        39655: 22786,
                        39656: 22794,
                        39657: 22800,
                        39658: 22811,
                        39659: 26790,
                        39660: 22821,
                        39661: 22828,
                        39662: 22829,
                        39663: 22834,
                        39664: 22840,
                        39665: 22846,
                        39666: 31442,
                        39667: 22869,
                        39668: 22864,
                        39669: 22862,
                        39670: 22874,
                        39671: 22872,
                        39672: 22882,
                        39673: 22880,
                        39674: 22887,
                        39675: 22892,
                        39676: 22889,
                        39744: 22904,
                        39745: 22913,
                        39746: 22941,
                        39747: 20318,
                        39748: 20395,
                        39749: 22947,
                        39750: 22962,
                        39751: 22982,
                        39752: 23016,
                        39753: 23004,
                        39754: 22925,
                        39755: 23001,
                        39756: 23002,
                        39757: 23077,
                        39758: 23071,
                        39759: 23057,
                        39760: 23068,
                        39761: 23049,
                        39762: 23066,
                        39763: 23104,
                        39764: 23148,
                        39765: 23113,
                        39766: 23093,
                        39767: 23094,
                        39768: 23138,
                        39769: 23146,
                        39770: 23194,
                        39771: 23228,
                        39772: 23230,
                        39773: 23243,
                        39774: 23234,
                        39775: 23229,
                        39776: 23267,
                        39777: 23255,
                        39778: 23270,
                        39779: 23273,
                        39780: 23254,
                        39781: 23290,
                        39782: 23291,
                        39783: 23308,
                        39784: 23307,
                        39785: 23318,
                        39786: 23346,
                        39787: 23248,
                        39788: 23338,
                        39789: 23350,
                        39790: 23358,
                        39791: 23363,
                        39792: 23365,
                        39793: 23360,
                        39794: 23377,
                        39795: 23381,
                        39796: 23386,
                        39797: 23387,
                        39798: 23397,
                        39799: 23401,
                        39800: 23408,
                        39801: 23411,
                        39802: 23413,
                        39803: 23416,
                        39804: 25992,
                        39805: 23418,
                        39806: 23424,
                        39808: 23427,
                        39809: 23462,
                        39810: 23480,
                        39811: 23491,
                        39812: 23495,
                        39813: 23497,
                        39814: 23508,
                        39815: 23504,
                        39816: 23524,
                        39817: 23526,
                        39818: 23522,
                        39819: 23518,
                        39820: 23525,
                        39821: 23531,
                        39822: 23536,
                        39823: 23542,
                        39824: 23539,
                        39825: 23557,
                        39826: 23559,
                        39827: 23560,
                        39828: 23565,
                        39829: 23571,
                        39830: 23584,
                        39831: 23586,
                        39832: 23592,
                        39833: 23608,
                        39834: 23609,
                        39835: 23617,
                        39836: 23622,
                        39837: 23630,
                        39838: 23635,
                        39839: 23632,
                        39840: 23631,
                        39841: 23409,
                        39842: 23660,
                        39843: 23662,
                        39844: 20066,
                        39845: 23670,
                        39846: 23673,
                        39847: 23692,
                        39848: 23697,
                        39849: 23700,
                        39850: 22939,
                        39851: 23723,
                        39852: 23739,
                        39853: 23734,
                        39854: 23740,
                        39855: 23735,
                        39856: 23749,
                        39857: 23742,
                        39858: 23751,
                        39859: 23769,
                        39860: 23785,
                        39861: 23805,
                        39862: 23802,
                        39863: 23789,
                        39864: 23948,
                        39865: 23786,
                        39866: 23819,
                        39867: 23829,
                        39868: 23831,
                        39869: 23900,
                        39870: 23839,
                        39871: 23835,
                        39872: 23825,
                        39873: 23828,
                        39874: 23842,
                        39875: 23834,
                        39876: 23833,
                        39877: 23832,
                        39878: 23884,
                        39879: 23890,
                        39880: 23886,
                        39881: 23883,
                        39882: 23916,
                        39883: 23923,
                        39884: 23926,
                        39885: 23943,
                        39886: 23940,
                        39887: 23938,
                        39888: 23970,
                        39889: 23965,
                        39890: 23980,
                        39891: 23982,
                        39892: 23997,
                        39893: 23952,
                        39894: 23991,
                        39895: 23996,
                        39896: 24009,
                        39897: 24013,
                        39898: 24019,
                        39899: 24018,
                        39900: 24022,
                        39901: 24027,
                        39902: 24043,
                        39903: 24050,
                        39904: 24053,
                        39905: 24075,
                        39906: 24090,
                        39907: 24089,
                        39908: 24081,
                        39909: 24091,
                        39910: 24118,
                        39911: 24119,
                        39912: 24132,
                        39913: 24131,
                        39914: 24128,
                        39915: 24142,
                        39916: 24151,
                        39917: 24148,
                        39918: 24159,
                        39919: 24162,
                        39920: 24164,
                        39921: 24135,
                        39922: 24181,
                        39923: 24182,
                        39924: 24186,
                        39925: 40636,
                        39926: 24191,
                        39927: 24224,
                        39928: 24257,
                        39929: 24258,
                        39930: 24264,
                        39931: 24272,
                        39932: 24271,
                        4e4: 24278,
                        40001: 24291,
                        40002: 24285,
                        40003: 24282,
                        40004: 24283,
                        40005: 24290,
                        40006: 24289,
                        40007: 24296,
                        40008: 24297,
                        40009: 24300,
                        40010: 24305,
                        40011: 24307,
                        40012: 24304,
                        40013: 24308,
                        40014: 24312,
                        40015: 24318,
                        40016: 24323,
                        40017: 24329,
                        40018: 24413,
                        40019: 24412,
                        40020: 24331,
                        40021: 24337,
                        40022: 24342,
                        40023: 24361,
                        40024: 24365,
                        40025: 24376,
                        40026: 24385,
                        40027: 24392,
                        40028: 24396,
                        40029: 24398,
                        40030: 24367,
                        40031: 24401,
                        40032: 24406,
                        40033: 24407,
                        40034: 24409,
                        40035: 24417,
                        40036: 24429,
                        40037: 24435,
                        40038: 24439,
                        40039: 24451,
                        40040: 24450,
                        40041: 24447,
                        40042: 24458,
                        40043: 24456,
                        40044: 24465,
                        40045: 24455,
                        40046: 24478,
                        40047: 24473,
                        40048: 24472,
                        40049: 24480,
                        40050: 24488,
                        40051: 24493,
                        40052: 24508,
                        40053: 24534,
                        40054: 24571,
                        40055: 24548,
                        40056: 24568,
                        40057: 24561,
                        40058: 24541,
                        40059: 24755,
                        40060: 24575,
                        40061: 24609,
                        40062: 24672,
                        40064: 24601,
                        40065: 24592,
                        40066: 24617,
                        40067: 24590,
                        40068: 24625,
                        40069: 24603,
                        40070: 24597,
                        40071: 24619,
                        40072: 24614,
                        40073: 24591,
                        40074: 24634,
                        40075: 24666,
                        40076: 24641,
                        40077: 24682,
                        40078: 24695,
                        40079: 24671,
                        40080: 24650,
                        40081: 24646,
                        40082: 24653,
                        40083: 24675,
                        40084: 24643,
                        40085: 24676,
                        40086: 24642,
                        40087: 24684,
                        40088: 24683,
                        40089: 24665,
                        40090: 24705,
                        40091: 24717,
                        40092: 24807,
                        40093: 24707,
                        40094: 24730,
                        40095: 24708,
                        40096: 24731,
                        40097: 24726,
                        40098: 24727,
                        40099: 24722,
                        40100: 24743,
                        40101: 24715,
                        40102: 24801,
                        40103: 24760,
                        40104: 24800,
                        40105: 24787,
                        40106: 24756,
                        40107: 24560,
                        40108: 24765,
                        40109: 24774,
                        40110: 24757,
                        40111: 24792,
                        40112: 24909,
                        40113: 24853,
                        40114: 24838,
                        40115: 24822,
                        40116: 24823,
                        40117: 24832,
                        40118: 24820,
                        40119: 24826,
                        40120: 24835,
                        40121: 24865,
                        40122: 24827,
                        40123: 24817,
                        40124: 24845,
                        40125: 24846,
                        40126: 24903,
                        40127: 24894,
                        40128: 24872,
                        40129: 24871,
                        40130: 24906,
                        40131: 24895,
                        40132: 24892,
                        40133: 24876,
                        40134: 24884,
                        40135: 24893,
                        40136: 24898,
                        40137: 24900,
                        40138: 24947,
                        40139: 24951,
                        40140: 24920,
                        40141: 24921,
                        40142: 24922,
                        40143: 24939,
                        40144: 24948,
                        40145: 24943,
                        40146: 24933,
                        40147: 24945,
                        40148: 24927,
                        40149: 24925,
                        40150: 24915,
                        40151: 24949,
                        40152: 24985,
                        40153: 24982,
                        40154: 24967,
                        40155: 25004,
                        40156: 24980,
                        40157: 24986,
                        40158: 24970,
                        40159: 24977,
                        40160: 25003,
                        40161: 25006,
                        40162: 25036,
                        40163: 25034,
                        40164: 25033,
                        40165: 25079,
                        40166: 25032,
                        40167: 25027,
                        40168: 25030,
                        40169: 25018,
                        40170: 25035,
                        40171: 32633,
                        40172: 25037,
                        40173: 25062,
                        40174: 25059,
                        40175: 25078,
                        40176: 25082,
                        40177: 25076,
                        40178: 25087,
                        40179: 25085,
                        40180: 25084,
                        40181: 25086,
                        40182: 25088,
                        40183: 25096,
                        40184: 25097,
                        40185: 25101,
                        40186: 25100,
                        40187: 25108,
                        40188: 25115,
                        40256: 25118,
                        40257: 25121,
                        40258: 25130,
                        40259: 25134,
                        40260: 25136,
                        40261: 25138,
                        40262: 25139,
                        40263: 25153,
                        40264: 25166,
                        40265: 25182,
                        40266: 25187,
                        40267: 25179,
                        40268: 25184,
                        40269: 25192,
                        40270: 25212,
                        40271: 25218,
                        40272: 25225,
                        40273: 25214,
                        40274: 25234,
                        40275: 25235,
                        40276: 25238,
                        40277: 25300,
                        40278: 25219,
                        40279: 25236,
                        40280: 25303,
                        40281: 25297,
                        40282: 25275,
                        40283: 25295,
                        40284: 25343,
                        40285: 25286,
                        40286: 25812,
                        40287: 25288,
                        40288: 25308,
                        40289: 25292,
                        40290: 25290,
                        40291: 25282,
                        40292: 25287,
                        40293: 25243,
                        40294: 25289,
                        40295: 25356,
                        40296: 25326,
                        40297: 25329,
                        40298: 25383,
                        40299: 25346,
                        40300: 25352,
                        40301: 25327,
                        40302: 25333,
                        40303: 25424,
                        40304: 25406,
                        40305: 25421,
                        40306: 25628,
                        40307: 25423,
                        40308: 25494,
                        40309: 25486,
                        40310: 25472,
                        40311: 25515,
                        40312: 25462,
                        40313: 25507,
                        40314: 25487,
                        40315: 25481,
                        40316: 25503,
                        40317: 25525,
                        40318: 25451,
                        40320: 25449,
                        40321: 25534,
                        40322: 25577,
                        40323: 25536,
                        40324: 25542,
                        40325: 25571,
                        40326: 25545,
                        40327: 25554,
                        40328: 25590,
                        40329: 25540,
                        40330: 25622,
                        40331: 25652,
                        40332: 25606,
                        40333: 25619,
                        40334: 25638,
                        40335: 25654,
                        40336: 25885,
                        40337: 25623,
                        40338: 25640,
                        40339: 25615,
                        40340: 25703,
                        40341: 25711,
                        40342: 25718,
                        40343: 25678,
                        40344: 25898,
                        40345: 25749,
                        40346: 25747,
                        40347: 25765,
                        40348: 25769,
                        40349: 25736,
                        40350: 25788,
                        40351: 25818,
                        40352: 25810,
                        40353: 25797,
                        40354: 25799,
                        40355: 25787,
                        40356: 25816,
                        40357: 25794,
                        40358: 25841,
                        40359: 25831,
                        40360: 33289,
                        40361: 25824,
                        40362: 25825,
                        40363: 25260,
                        40364: 25827,
                        40365: 25839,
                        40366: 25900,
                        40367: 25846,
                        40368: 25844,
                        40369: 25842,
                        40370: 25850,
                        40371: 25856,
                        40372: 25853,
                        40373: 25880,
                        40374: 25884,
                        40375: 25861,
                        40376: 25892,
                        40377: 25891,
                        40378: 25899,
                        40379: 25908,
                        40380: 25909,
                        40381: 25911,
                        40382: 25910,
                        40383: 25912,
                        40384: 30027,
                        40385: 25928,
                        40386: 25942,
                        40387: 25941,
                        40388: 25933,
                        40389: 25944,
                        40390: 25950,
                        40391: 25949,
                        40392: 25970,
                        40393: 25976,
                        40394: 25986,
                        40395: 25987,
                        40396: 35722,
                        40397: 26011,
                        40398: 26015,
                        40399: 26027,
                        40400: 26039,
                        40401: 26051,
                        40402: 26054,
                        40403: 26049,
                        40404: 26052,
                        40405: 26060,
                        40406: 26066,
                        40407: 26075,
                        40408: 26073,
                        40409: 26080,
                        40410: 26081,
                        40411: 26097,
                        40412: 26482,
                        40413: 26122,
                        40414: 26115,
                        40415: 26107,
                        40416: 26483,
                        40417: 26165,
                        40418: 26166,
                        40419: 26164,
                        40420: 26140,
                        40421: 26191,
                        40422: 26180,
                        40423: 26185,
                        40424: 26177,
                        40425: 26206,
                        40426: 26205,
                        40427: 26212,
                        40428: 26215,
                        40429: 26216,
                        40430: 26207,
                        40431: 26210,
                        40432: 26224,
                        40433: 26243,
                        40434: 26248,
                        40435: 26254,
                        40436: 26249,
                        40437: 26244,
                        40438: 26264,
                        40439: 26269,
                        40440: 26305,
                        40441: 26297,
                        40442: 26313,
                        40443: 26302,
                        40444: 26300,
                        40512: 26308,
                        40513: 26296,
                        40514: 26326,
                        40515: 26330,
                        40516: 26336,
                        40517: 26175,
                        40518: 26342,
                        40519: 26345,
                        40520: 26352,
                        40521: 26357,
                        40522: 26359,
                        40523: 26383,
                        40524: 26390,
                        40525: 26398,
                        40526: 26406,
                        40527: 26407,
                        40528: 38712,
                        40529: 26414,
                        40530: 26431,
                        40531: 26422,
                        40532: 26433,
                        40533: 26424,
                        40534: 26423,
                        40535: 26438,
                        40536: 26462,
                        40537: 26464,
                        40538: 26457,
                        40539: 26467,
                        40540: 26468,
                        40541: 26505,
                        40542: 26480,
                        40543: 26537,
                        40544: 26492,
                        40545: 26474,
                        40546: 26508,
                        40547: 26507,
                        40548: 26534,
                        40549: 26529,
                        40550: 26501,
                        40551: 26551,
                        40552: 26607,
                        40553: 26548,
                        40554: 26604,
                        40555: 26547,
                        40556: 26601,
                        40557: 26552,
                        40558: 26596,
                        40559: 26590,
                        40560: 26589,
                        40561: 26594,
                        40562: 26606,
                        40563: 26553,
                        40564: 26574,
                        40565: 26566,
                        40566: 26599,
                        40567: 27292,
                        40568: 26654,
                        40569: 26694,
                        40570: 26665,
                        40571: 26688,
                        40572: 26701,
                        40573: 26674,
                        40574: 26702,
                        40576: 26803,
                        40577: 26667,
                        40578: 26713,
                        40579: 26723,
                        40580: 26743,
                        40581: 26751,
                        40582: 26783,
                        40583: 26767,
                        40584: 26797,
                        40585: 26772,
                        40586: 26781,
                        40587: 26779,
                        40588: 26755,
                        40589: 27310,
                        40590: 26809,
                        40591: 26740,
                        40592: 26805,
                        40593: 26784,
                        40594: 26810,
                        40595: 26895,
                        40596: 26765,
                        40597: 26750,
                        40598: 26881,
                        40599: 26826,
                        40600: 26888,
                        40601: 26840,
                        40602: 26914,
                        40603: 26918,
                        40604: 26849,
                        40605: 26892,
                        40606: 26829,
                        40607: 26836,
                        40608: 26855,
                        40609: 26837,
                        40610: 26934,
                        40611: 26898,
                        40612: 26884,
                        40613: 26839,
                        40614: 26851,
                        40615: 26917,
                        40616: 26873,
                        40617: 26848,
                        40618: 26863,
                        40619: 26920,
                        40620: 26922,
                        40621: 26906,
                        40622: 26915,
                        40623: 26913,
                        40624: 26822,
                        40625: 27001,
                        40626: 26999,
                        40627: 26972,
                        40628: 27e3,
                        40629: 26987,
                        40630: 26964,
                        40631: 27006,
                        40632: 26990,
                        40633: 26937,
                        40634: 26996,
                        40635: 26941,
                        40636: 26969,
                        40637: 26928,
                        40638: 26977,
                        40639: 26974,
                        40640: 26973,
                        40641: 27009,
                        40642: 26986,
                        40643: 27058,
                        40644: 27054,
                        40645: 27088,
                        40646: 27071,
                        40647: 27073,
                        40648: 27091,
                        40649: 27070,
                        40650: 27086,
                        40651: 23528,
                        40652: 27082,
                        40653: 27101,
                        40654: 27067,
                        40655: 27075,
                        40656: 27047,
                        40657: 27182,
                        40658: 27025,
                        40659: 27040,
                        40660: 27036,
                        40661: 27029,
                        40662: 27060,
                        40663: 27102,
                        40664: 27112,
                        40665: 27138,
                        40666: 27163,
                        40667: 27135,
                        40668: 27402,
                        40669: 27129,
                        40670: 27122,
                        40671: 27111,
                        40672: 27141,
                        40673: 27057,
                        40674: 27166,
                        40675: 27117,
                        40676: 27156,
                        40677: 27115,
                        40678: 27146,
                        40679: 27154,
                        40680: 27329,
                        40681: 27171,
                        40682: 27155,
                        40683: 27204,
                        40684: 27148,
                        40685: 27250,
                        40686: 27190,
                        40687: 27256,
                        40688: 27207,
                        40689: 27234,
                        40690: 27225,
                        40691: 27238,
                        40692: 27208,
                        40693: 27192,
                        40694: 27170,
                        40695: 27280,
                        40696: 27277,
                        40697: 27296,
                        40698: 27268,
                        40699: 27298,
                        40700: 27299,
                        40768: 27287,
                        40769: 34327,
                        40770: 27323,
                        40771: 27331,
                        40772: 27330,
                        40773: 27320,
                        40774: 27315,
                        40775: 27308,
                        40776: 27358,
                        40777: 27345,
                        40778: 27359,
                        40779: 27306,
                        40780: 27354,
                        40781: 27370,
                        40782: 27387,
                        40783: 27397,
                        40784: 34326,
                        40785: 27386,
                        40786: 27410,
                        40787: 27414,
                        40788: 39729,
                        40789: 27423,
                        40790: 27448,
                        40791: 27447,
                        40792: 30428,
                        40793: 27449,
                        40794: 39150,
                        40795: 27463,
                        40796: 27459,
                        40797: 27465,
                        40798: 27472,
                        40799: 27481,
                        40800: 27476,
                        40801: 27483,
                        40802: 27487,
                        40803: 27489,
                        40804: 27512,
                        40805: 27513,
                        40806: 27519,
                        40807: 27520,
                        40808: 27524,
                        40809: 27523,
                        40810: 27533,
                        40811: 27544,
                        40812: 27541,
                        40813: 27550,
                        40814: 27556,
                        40815: 27562,
                        40816: 27563,
                        40817: 27567,
                        40818: 27570,
                        40819: 27569,
                        40820: 27571,
                        40821: 27575,
                        40822: 27580,
                        40823: 27590,
                        40824: 27595,
                        40825: 27603,
                        40826: 27615,
                        40827: 27628,
                        40828: 27627,
                        40829: 27635,
                        40830: 27631,
                        40832: 40638,
                        40833: 27656,
                        40834: 27667,
                        40835: 27668,
                        40836: 27675,
                        40837: 27684,
                        40838: 27683,
                        40839: 27742,
                        40840: 27733,
                        40841: 27746,
                        40842: 27754,
                        40843: 27778,
                        40844: 27789,
                        40845: 27802,
                        40846: 27777,
                        40847: 27803,
                        40848: 27774,
                        40849: 27752,
                        40850: 27763,
                        40851: 27794,
                        40852: 27792,
                        40853: 27844,
                        40854: 27889,
                        40855: 27859,
                        40856: 27837,
                        40857: 27863,
                        40858: 27845,
                        40859: 27869,
                        40860: 27822,
                        40861: 27825,
                        40862: 27838,
                        40863: 27834,
                        40864: 27867,
                        40865: 27887,
                        40866: 27865,
                        40867: 27882,
                        40868: 27935,
                        40869: 34893,
                        40870: 27958,
                        40871: 27947,
                        40872: 27965,
                        40873: 27960,
                        40874: 27929,
                        40875: 27957,
                        40876: 27955,
                        40877: 27922,
                        40878: 27916,
                        40879: 28003,
                        40880: 28051,
                        40881: 28004,
                        40882: 27994,
                        40883: 28025,
                        40884: 27993,
                        40885: 28046,
                        40886: 28053,
                        40887: 28644,
                        40888: 28037,
                        40889: 28153,
                        40890: 28181,
                        40891: 28170,
                        40892: 28085,
                        40893: 28103,
                        40894: 28134,
                        40895: 28088,
                        40896: 28102,
                        40897: 28140,
                        40898: 28126,
                        40899: 28108,
                        40900: 28136,
                        40901: 28114,
                        40902: 28101,
                        40903: 28154,
                        40904: 28121,
                        40905: 28132,
                        40906: 28117,
                        40907: 28138,
                        40908: 28142,
                        40909: 28205,
                        40910: 28270,
                        40911: 28206,
                        40912: 28185,
                        40913: 28274,
                        40914: 28255,
                        40915: 28222,
                        40916: 28195,
                        40917: 28267,
                        40918: 28203,
                        40919: 28278,
                        40920: 28237,
                        40921: 28191,
                        40922: 28227,
                        40923: 28218,
                        40924: 28238,
                        40925: 28196,
                        40926: 28415,
                        40927: 28189,
                        40928: 28216,
                        40929: 28290,
                        40930: 28330,
                        40931: 28312,
                        40932: 28361,
                        40933: 28343,
                        40934: 28371,
                        40935: 28349,
                        40936: 28335,
                        40937: 28356,
                        40938: 28338,
                        40939: 28372,
                        40940: 28373,
                        40941: 28303,
                        40942: 28325,
                        40943: 28354,
                        40944: 28319,
                        40945: 28481,
                        40946: 28433,
                        40947: 28748,
                        40948: 28396,
                        40949: 28408,
                        40950: 28414,
                        40951: 28479,
                        40952: 28402,
                        40953: 28465,
                        40954: 28399,
                        40955: 28466,
                        40956: 28364,
                        57408: 28478,
                        57409: 28435,
                        57410: 28407,
                        57411: 28550,
                        57412: 28538,
                        57413: 28536,
                        57414: 28545,
                        57415: 28544,
                        57416: 28527,
                        57417: 28507,
                        57418: 28659,
                        57419: 28525,
                        57420: 28546,
                        57421: 28540,
                        57422: 28504,
                        57423: 28558,
                        57424: 28561,
                        57425: 28610,
                        57426: 28518,
                        57427: 28595,
                        57428: 28579,
                        57429: 28577,
                        57430: 28580,
                        57431: 28601,
                        57432: 28614,
                        57433: 28586,
                        57434: 28639,
                        57435: 28629,
                        57436: 28652,
                        57437: 28628,
                        57438: 28632,
                        57439: 28657,
                        57440: 28654,
                        57441: 28635,
                        57442: 28681,
                        57443: 28683,
                        57444: 28666,
                        57445: 28689,
                        57446: 28673,
                        57447: 28687,
                        57448: 28670,
                        57449: 28699,
                        57450: 28698,
                        57451: 28532,
                        57452: 28701,
                        57453: 28696,
                        57454: 28703,
                        57455: 28720,
                        57456: 28734,
                        57457: 28722,
                        57458: 28753,
                        57459: 28771,
                        57460: 28825,
                        57461: 28818,
                        57462: 28847,
                        57463: 28913,
                        57464: 28844,
                        57465: 28856,
                        57466: 28851,
                        57467: 28846,
                        57468: 28895,
                        57469: 28875,
                        57470: 28893,
                        57472: 28889,
                        57473: 28937,
                        57474: 28925,
                        57475: 28956,
                        57476: 28953,
                        57477: 29029,
                        57478: 29013,
                        57479: 29064,
                        57480: 29030,
                        57481: 29026,
                        57482: 29004,
                        57483: 29014,
                        57484: 29036,
                        57485: 29071,
                        57486: 29179,
                        57487: 29060,
                        57488: 29077,
                        57489: 29096,
                        57490: 29100,
                        57491: 29143,
                        57492: 29113,
                        57493: 29118,
                        57494: 29138,
                        57495: 29129,
                        57496: 29140,
                        57497: 29134,
                        57498: 29152,
                        57499: 29164,
                        57500: 29159,
                        57501: 29173,
                        57502: 29180,
                        57503: 29177,
                        57504: 29183,
                        57505: 29197,
                        57506: 29200,
                        57507: 29211,
                        57508: 29224,
                        57509: 29229,
                        57510: 29228,
                        57511: 29232,
                        57512: 29234,
                        57513: 29243,
                        57514: 29244,
                        57515: 29247,
                        57516: 29248,
                        57517: 29254,
                        57518: 29259,
                        57519: 29272,
                        57520: 29300,
                        57521: 29310,
                        57522: 29314,
                        57523: 29313,
                        57524: 29319,
                        57525: 29330,
                        57526: 29334,
                        57527: 29346,
                        57528: 29351,
                        57529: 29369,
                        57530: 29362,
                        57531: 29379,
                        57532: 29382,
                        57533: 29380,
                        57534: 29390,
                        57535: 29394,
                        57536: 29410,
                        57537: 29408,
                        57538: 29409,
                        57539: 29433,
                        57540: 29431,
                        57541: 20495,
                        57542: 29463,
                        57543: 29450,
                        57544: 29468,
                        57545: 29462,
                        57546: 29469,
                        57547: 29492,
                        57548: 29487,
                        57549: 29481,
                        57550: 29477,
                        57551: 29502,
                        57552: 29518,
                        57553: 29519,
                        57554: 40664,
                        57555: 29527,
                        57556: 29546,
                        57557: 29544,
                        57558: 29552,
                        57559: 29560,
                        57560: 29557,
                        57561: 29563,
                        57562: 29562,
                        57563: 29640,
                        57564: 29619,
                        57565: 29646,
                        57566: 29627,
                        57567: 29632,
                        57568: 29669,
                        57569: 29678,
                        57570: 29662,
                        57571: 29858,
                        57572: 29701,
                        57573: 29807,
                        57574: 29733,
                        57575: 29688,
                        57576: 29746,
                        57577: 29754,
                        57578: 29781,
                        57579: 29759,
                        57580: 29791,
                        57581: 29785,
                        57582: 29761,
                        57583: 29788,
                        57584: 29801,
                        57585: 29808,
                        57586: 29795,
                        57587: 29802,
                        57588: 29814,
                        57589: 29822,
                        57590: 29835,
                        57591: 29854,
                        57592: 29863,
                        57593: 29898,
                        57594: 29903,
                        57595: 29908,
                        57596: 29681,
                        57664: 29920,
                        57665: 29923,
                        57666: 29927,
                        57667: 29929,
                        57668: 29934,
                        57669: 29938,
                        57670: 29936,
                        57671: 29937,
                        57672: 29944,
                        57673: 29943,
                        57674: 29956,
                        57675: 29955,
                        57676: 29957,
                        57677: 29964,
                        57678: 29966,
                        57679: 29965,
                        57680: 29973,
                        57681: 29971,
                        57682: 29982,
                        57683: 29990,
                        57684: 29996,
                        57685: 30012,
                        57686: 30020,
                        57687: 30029,
                        57688: 30026,
                        57689: 30025,
                        57690: 30043,
                        57691: 30022,
                        57692: 30042,
                        57693: 30057,
                        57694: 30052,
                        57695: 30055,
                        57696: 30059,
                        57697: 30061,
                        57698: 30072,
                        57699: 30070,
                        57700: 30086,
                        57701: 30087,
                        57702: 30068,
                        57703: 30090,
                        57704: 30089,
                        57705: 30082,
                        57706: 30100,
                        57707: 30106,
                        57708: 30109,
                        57709: 30117,
                        57710: 30115,
                        57711: 30146,
                        57712: 30131,
                        57713: 30147,
                        57714: 30133,
                        57715: 30141,
                        57716: 30136,
                        57717: 30140,
                        57718: 30129,
                        57719: 30157,
                        57720: 30154,
                        57721: 30162,
                        57722: 30169,
                        57723: 30179,
                        57724: 30174,
                        57725: 30206,
                        57726: 30207,
                        57728: 30204,
                        57729: 30209,
                        57730: 30192,
                        57731: 30202,
                        57732: 30194,
                        57733: 30195,
                        57734: 30219,
                        57735: 30221,
                        57736: 30217,
                        57737: 30239,
                        57738: 30247,
                        57739: 30240,
                        57740: 30241,
                        57741: 30242,
                        57742: 30244,
                        57743: 30260,
                        57744: 30256,
                        57745: 30267,
                        57746: 30279,
                        57747: 30280,
                        57748: 30278,
                        57749: 30300,
                        57750: 30296,
                        57751: 30305,
                        57752: 30306,
                        57753: 30312,
                        57754: 30313,
                        57755: 30314,
                        57756: 30311,
                        57757: 30316,
                        57758: 30320,
                        57759: 30322,
                        57760: 30326,
                        57761: 30328,
                        57762: 30332,
                        57763: 30336,
                        57764: 30339,
                        57765: 30344,
                        57766: 30347,
                        57767: 30350,
                        57768: 30358,
                        57769: 30355,
                        57770: 30361,
                        57771: 30362,
                        57772: 30384,
                        57773: 30388,
                        57774: 30392,
                        57775: 30393,
                        57776: 30394,
                        57777: 30402,
                        57778: 30413,
                        57779: 30422,
                        57780: 30418,
                        57781: 30430,
                        57782: 30433,
                        57783: 30437,
                        57784: 30439,
                        57785: 30442,
                        57786: 34351,
                        57787: 30459,
                        57788: 30472,
                        57789: 30471,
                        57790: 30468,
                        57791: 30505,
                        57792: 30500,
                        57793: 30494,
                        57794: 30501,
                        57795: 30502,
                        57796: 30491,
                        57797: 30519,
                        57798: 30520,
                        57799: 30535,
                        57800: 30554,
                        57801: 30568,
                        57802: 30571,
                        57803: 30555,
                        57804: 30565,
                        57805: 30591,
                        57806: 30590,
                        57807: 30585,
                        57808: 30606,
                        57809: 30603,
                        57810: 30609,
                        57811: 30624,
                        57812: 30622,
                        57813: 30640,
                        57814: 30646,
                        57815: 30649,
                        57816: 30655,
                        57817: 30652,
                        57818: 30653,
                        57819: 30651,
                        57820: 30663,
                        57821: 30669,
                        57822: 30679,
                        57823: 30682,
                        57824: 30684,
                        57825: 30691,
                        57826: 30702,
                        57827: 30716,
                        57828: 30732,
                        57829: 30738,
                        57830: 31014,
                        57831: 30752,
                        57832: 31018,
                        57833: 30789,
                        57834: 30862,
                        57835: 30836,
                        57836: 30854,
                        57837: 30844,
                        57838: 30874,
                        57839: 30860,
                        57840: 30883,
                        57841: 30901,
                        57842: 30890,
                        57843: 30895,
                        57844: 30929,
                        57845: 30918,
                        57846: 30923,
                        57847: 30932,
                        57848: 30910,
                        57849: 30908,
                        57850: 30917,
                        57851: 30922,
                        57852: 30956,
                        57920: 30951,
                        57921: 30938,
                        57922: 30973,
                        57923: 30964,
                        57924: 30983,
                        57925: 30994,
                        57926: 30993,
                        57927: 31001,
                        57928: 31020,
                        57929: 31019,
                        57930: 31040,
                        57931: 31072,
                        57932: 31063,
                        57933: 31071,
                        57934: 31066,
                        57935: 31061,
                        57936: 31059,
                        57937: 31098,
                        57938: 31103,
                        57939: 31114,
                        57940: 31133,
                        57941: 31143,
                        57942: 40779,
                        57943: 31146,
                        57944: 31150,
                        57945: 31155,
                        57946: 31161,
                        57947: 31162,
                        57948: 31177,
                        57949: 31189,
                        57950: 31207,
                        57951: 31212,
                        57952: 31201,
                        57953: 31203,
                        57954: 31240,
                        57955: 31245,
                        57956: 31256,
                        57957: 31257,
                        57958: 31264,
                        57959: 31263,
                        57960: 31104,
                        57961: 31281,
                        57962: 31291,
                        57963: 31294,
                        57964: 31287,
                        57965: 31299,
                        57966: 31319,
                        57967: 31305,
                        57968: 31329,
                        57969: 31330,
                        57970: 31337,
                        57971: 40861,
                        57972: 31344,
                        57973: 31353,
                        57974: 31357,
                        57975: 31368,
                        57976: 31383,
                        57977: 31381,
                        57978: 31384,
                        57979: 31382,
                        57980: 31401,
                        57981: 31432,
                        57982: 31408,
                        57984: 31414,
                        57985: 31429,
                        57986: 31428,
                        57987: 31423,
                        57988: 36995,
                        57989: 31431,
                        57990: 31434,
                        57991: 31437,
                        57992: 31439,
                        57993: 31445,
                        57994: 31443,
                        57995: 31449,
                        57996: 31450,
                        57997: 31453,
                        57998: 31457,
                        57999: 31458,
                        58e3: 31462,
                        58001: 31469,
                        58002: 31472,
                        58003: 31490,
                        58004: 31503,
                        58005: 31498,
                        58006: 31494,
                        58007: 31539,
                        58008: 31512,
                        58009: 31513,
                        58010: 31518,
                        58011: 31541,
                        58012: 31528,
                        58013: 31542,
                        58014: 31568,
                        58015: 31610,
                        58016: 31492,
                        58017: 31565,
                        58018: 31499,
                        58019: 31564,
                        58020: 31557,
                        58021: 31605,
                        58022: 31589,
                        58023: 31604,
                        58024: 31591,
                        58025: 31600,
                        58026: 31601,
                        58027: 31596,
                        58028: 31598,
                        58029: 31645,
                        58030: 31640,
                        58031: 31647,
                        58032: 31629,
                        58033: 31644,
                        58034: 31642,
                        58035: 31627,
                        58036: 31634,
                        58037: 31631,
                        58038: 31581,
                        58039: 31641,
                        58040: 31691,
                        58041: 31681,
                        58042: 31692,
                        58043: 31695,
                        58044: 31668,
                        58045: 31686,
                        58046: 31709,
                        58047: 31721,
                        58048: 31761,
                        58049: 31764,
                        58050: 31718,
                        58051: 31717,
                        58052: 31840,
                        58053: 31744,
                        58054: 31751,
                        58055: 31763,
                        58056: 31731,
                        58057: 31735,
                        58058: 31767,
                        58059: 31757,
                        58060: 31734,
                        58061: 31779,
                        58062: 31783,
                        58063: 31786,
                        58064: 31775,
                        58065: 31799,
                        58066: 31787,
                        58067: 31805,
                        58068: 31820,
                        58069: 31811,
                        58070: 31828,
                        58071: 31823,
                        58072: 31808,
                        58073: 31824,
                        58074: 31832,
                        58075: 31839,
                        58076: 31844,
                        58077: 31830,
                        58078: 31845,
                        58079: 31852,
                        58080: 31861,
                        58081: 31875,
                        58082: 31888,
                        58083: 31908,
                        58084: 31917,
                        58085: 31906,
                        58086: 31915,
                        58087: 31905,
                        58088: 31912,
                        58089: 31923,
                        58090: 31922,
                        58091: 31921,
                        58092: 31918,
                        58093: 31929,
                        58094: 31933,
                        58095: 31936,
                        58096: 31941,
                        58097: 31938,
                        58098: 31960,
                        58099: 31954,
                        58100: 31964,
                        58101: 31970,
                        58102: 39739,
                        58103: 31983,
                        58104: 31986,
                        58105: 31988,
                        58106: 31990,
                        58107: 31994,
                        58108: 32006,
                        58176: 32002,
                        58177: 32028,
                        58178: 32021,
                        58179: 32010,
                        58180: 32069,
                        58181: 32075,
                        58182: 32046,
                        58183: 32050,
                        58184: 32063,
                        58185: 32053,
                        58186: 32070,
                        58187: 32115,
                        58188: 32086,
                        58189: 32078,
                        58190: 32114,
                        58191: 32104,
                        58192: 32110,
                        58193: 32079,
                        58194: 32099,
                        58195: 32147,
                        58196: 32137,
                        58197: 32091,
                        58198: 32143,
                        58199: 32125,
                        58200: 32155,
                        58201: 32186,
                        58202: 32174,
                        58203: 32163,
                        58204: 32181,
                        58205: 32199,
                        58206: 32189,
                        58207: 32171,
                        58208: 32317,
                        58209: 32162,
                        58210: 32175,
                        58211: 32220,
                        58212: 32184,
                        58213: 32159,
                        58214: 32176,
                        58215: 32216,
                        58216: 32221,
                        58217: 32228,
                        58218: 32222,
                        58219: 32251,
                        58220: 32242,
                        58221: 32225,
                        58222: 32261,
                        58223: 32266,
                        58224: 32291,
                        58225: 32289,
                        58226: 32274,
                        58227: 32305,
                        58228: 32287,
                        58229: 32265,
                        58230: 32267,
                        58231: 32290,
                        58232: 32326,
                        58233: 32358,
                        58234: 32315,
                        58235: 32309,
                        58236: 32313,
                        58237: 32323,
                        58238: 32311,
                        58240: 32306,
                        58241: 32314,
                        58242: 32359,
                        58243: 32349,
                        58244: 32342,
                        58245: 32350,
                        58246: 32345,
                        58247: 32346,
                        58248: 32377,
                        58249: 32362,
                        58250: 32361,
                        58251: 32380,
                        58252: 32379,
                        58253: 32387,
                        58254: 32213,
                        58255: 32381,
                        58256: 36782,
                        58257: 32383,
                        58258: 32392,
                        58259: 32393,
                        58260: 32396,
                        58261: 32402,
                        58262: 32400,
                        58263: 32403,
                        58264: 32404,
                        58265: 32406,
                        58266: 32398,
                        58267: 32411,
                        58268: 32412,
                        58269: 32568,
                        58270: 32570,
                        58271: 32581,
                        58272: 32588,
                        58273: 32589,
                        58274: 32590,
                        58275: 32592,
                        58276: 32593,
                        58277: 32597,
                        58278: 32596,
                        58279: 32600,
                        58280: 32607,
                        58281: 32608,
                        58282: 32616,
                        58283: 32617,
                        58284: 32615,
                        58285: 32632,
                        58286: 32642,
                        58287: 32646,
                        58288: 32643,
                        58289: 32648,
                        58290: 32647,
                        58291: 32652,
                        58292: 32660,
                        58293: 32670,
                        58294: 32669,
                        58295: 32666,
                        58296: 32675,
                        58297: 32687,
                        58298: 32690,
                        58299: 32697,
                        58300: 32686,
                        58301: 32694,
                        58302: 32696,
                        58303: 35697,
                        58304: 32709,
                        58305: 32710,
                        58306: 32714,
                        58307: 32725,
                        58308: 32724,
                        58309: 32737,
                        58310: 32742,
                        58311: 32745,
                        58312: 32755,
                        58313: 32761,
                        58314: 39132,
                        58315: 32774,
                        58316: 32772,
                        58317: 32779,
                        58318: 32786,
                        58319: 32792,
                        58320: 32793,
                        58321: 32796,
                        58322: 32801,
                        58323: 32808,
                        58324: 32831,
                        58325: 32827,
                        58326: 32842,
                        58327: 32838,
                        58328: 32850,
                        58329: 32856,
                        58330: 32858,
                        58331: 32863,
                        58332: 32866,
                        58333: 32872,
                        58334: 32883,
                        58335: 32882,
                        58336: 32880,
                        58337: 32886,
                        58338: 32889,
                        58339: 32893,
                        58340: 32895,
                        58341: 32900,
                        58342: 32902,
                        58343: 32901,
                        58344: 32923,
                        58345: 32915,
                        58346: 32922,
                        58347: 32941,
                        58348: 20880,
                        58349: 32940,
                        58350: 32987,
                        58351: 32997,
                        58352: 32985,
                        58353: 32989,
                        58354: 32964,
                        58355: 32986,
                        58356: 32982,
                        58357: 33033,
                        58358: 33007,
                        58359: 33009,
                        58360: 33051,
                        58361: 33065,
                        58362: 33059,
                        58363: 33071,
                        58364: 33099,
                        58432: 38539,
                        58433: 33094,
                        58434: 33086,
                        58435: 33107,
                        58436: 33105,
                        58437: 33020,
                        58438: 33137,
                        58439: 33134,
                        58440: 33125,
                        58441: 33126,
                        58442: 33140,
                        58443: 33155,
                        58444: 33160,
                        58445: 33162,
                        58446: 33152,
                        58447: 33154,
                        58448: 33184,
                        58449: 33173,
                        58450: 33188,
                        58451: 33187,
                        58452: 33119,
                        58453: 33171,
                        58454: 33193,
                        58455: 33200,
                        58456: 33205,
                        58457: 33214,
                        58458: 33208,
                        58459: 33213,
                        58460: 33216,
                        58461: 33218,
                        58462: 33210,
                        58463: 33225,
                        58464: 33229,
                        58465: 33233,
                        58466: 33241,
                        58467: 33240,
                        58468: 33224,
                        58469: 33242,
                        58470: 33247,
                        58471: 33248,
                        58472: 33255,
                        58473: 33274,
                        58474: 33275,
                        58475: 33278,
                        58476: 33281,
                        58477: 33282,
                        58478: 33285,
                        58479: 33287,
                        58480: 33290,
                        58481: 33293,
                        58482: 33296,
                        58483: 33302,
                        58484: 33321,
                        58485: 33323,
                        58486: 33336,
                        58487: 33331,
                        58488: 33344,
                        58489: 33369,
                        58490: 33368,
                        58491: 33373,
                        58492: 33370,
                        58493: 33375,
                        58494: 33380,
                        58496: 33378,
                        58497: 33384,
                        58498: 33386,
                        58499: 33387,
                        58500: 33326,
                        58501: 33393,
                        58502: 33399,
                        58503: 33400,
                        58504: 33406,
                        58505: 33421,
                        58506: 33426,
                        58507: 33451,
                        58508: 33439,
                        58509: 33467,
                        58510: 33452,
                        58511: 33505,
                        58512: 33507,
                        58513: 33503,
                        58514: 33490,
                        58515: 33524,
                        58516: 33523,
                        58517: 33530,
                        58518: 33683,
                        58519: 33539,
                        58520: 33531,
                        58521: 33529,
                        58522: 33502,
                        58523: 33542,
                        58524: 33500,
                        58525: 33545,
                        58526: 33497,
                        58527: 33589,
                        58528: 33588,
                        58529: 33558,
                        58530: 33586,
                        58531: 33585,
                        58532: 33600,
                        58533: 33593,
                        58534: 33616,
                        58535: 33605,
                        58536: 33583,
                        58537: 33579,
                        58538: 33559,
                        58539: 33560,
                        58540: 33669,
                        58541: 33690,
                        58542: 33706,
                        58543: 33695,
                        58544: 33698,
                        58545: 33686,
                        58546: 33571,
                        58547: 33678,
                        58548: 33671,
                        58549: 33674,
                        58550: 33660,
                        58551: 33717,
                        58552: 33651,
                        58553: 33653,
                        58554: 33696,
                        58555: 33673,
                        58556: 33704,
                        58557: 33780,
                        58558: 33811,
                        58559: 33771,
                        58560: 33742,
                        58561: 33789,
                        58562: 33795,
                        58563: 33752,
                        58564: 33803,
                        58565: 33729,
                        58566: 33783,
                        58567: 33799,
                        58568: 33760,
                        58569: 33778,
                        58570: 33805,
                        58571: 33826,
                        58572: 33824,
                        58573: 33725,
                        58574: 33848,
                        58575: 34054,
                        58576: 33787,
                        58577: 33901,
                        58578: 33834,
                        58579: 33852,
                        58580: 34138,
                        58581: 33924,
                        58582: 33911,
                        58583: 33899,
                        58584: 33965,
                        58585: 33902,
                        58586: 33922,
                        58587: 33897,
                        58588: 33862,
                        58589: 33836,
                        58590: 33903,
                        58591: 33913,
                        58592: 33845,
                        58593: 33994,
                        58594: 33890,
                        58595: 33977,
                        58596: 33983,
                        58597: 33951,
                        58598: 34009,
                        58599: 33997,
                        58600: 33979,
                        58601: 34010,
                        58602: 34e3,
                        58603: 33985,
                        58604: 33990,
                        58605: 34006,
                        58606: 33953,
                        58607: 34081,
                        58608: 34047,
                        58609: 34036,
                        58610: 34071,
                        58611: 34072,
                        58612: 34092,
                        58613: 34079,
                        58614: 34069,
                        58615: 34068,
                        58616: 34044,
                        58617: 34112,
                        58618: 34147,
                        58619: 34136,
                        58620: 34120,
                        58688: 34113,
                        58689: 34306,
                        58690: 34123,
                        58691: 34133,
                        58692: 34176,
                        58693: 34212,
                        58694: 34184,
                        58695: 34193,
                        58696: 34186,
                        58697: 34216,
                        58698: 34157,
                        58699: 34196,
                        58700: 34203,
                        58701: 34282,
                        58702: 34183,
                        58703: 34204,
                        58704: 34167,
                        58705: 34174,
                        58706: 34192,
                        58707: 34249,
                        58708: 34234,
                        58709: 34255,
                        58710: 34233,
                        58711: 34256,
                        58712: 34261,
                        58713: 34269,
                        58714: 34277,
                        58715: 34268,
                        58716: 34297,
                        58717: 34314,
                        58718: 34323,
                        58719: 34315,
                        58720: 34302,
                        58721: 34298,
                        58722: 34310,
                        58723: 34338,
                        58724: 34330,
                        58725: 34352,
                        58726: 34367,
                        58727: 34381,
                        58728: 20053,
                        58729: 34388,
                        58730: 34399,
                        58731: 34407,
                        58732: 34417,
                        58733: 34451,
                        58734: 34467,
                        58735: 34473,
                        58736: 34474,
                        58737: 34443,
                        58738: 34444,
                        58739: 34486,
                        58740: 34479,
                        58741: 34500,
                        58742: 34502,
                        58743: 34480,
                        58744: 34505,
                        58745: 34851,
                        58746: 34475,
                        58747: 34516,
                        58748: 34526,
                        58749: 34537,
                        58750: 34540,
                        58752: 34527,
                        58753: 34523,
                        58754: 34543,
                        58755: 34578,
                        58756: 34566,
                        58757: 34568,
                        58758: 34560,
                        58759: 34563,
                        58760: 34555,
                        58761: 34577,
                        58762: 34569,
                        58763: 34573,
                        58764: 34553,
                        58765: 34570,
                        58766: 34612,
                        58767: 34623,
                        58768: 34615,
                        58769: 34619,
                        58770: 34597,
                        58771: 34601,
                        58772: 34586,
                        58773: 34656,
                        58774: 34655,
                        58775: 34680,
                        58776: 34636,
                        58777: 34638,
                        58778: 34676,
                        58779: 34647,
                        58780: 34664,
                        58781: 34670,
                        58782: 34649,
                        58783: 34643,
                        58784: 34659,
                        58785: 34666,
                        58786: 34821,
                        58787: 34722,
                        58788: 34719,
                        58789: 34690,
                        58790: 34735,
                        58791: 34763,
                        58792: 34749,
                        58793: 34752,
                        58794: 34768,
                        58795: 38614,
                        58796: 34731,
                        58797: 34756,
                        58798: 34739,
                        58799: 34759,
                        58800: 34758,
                        58801: 34747,
                        58802: 34799,
                        58803: 34802,
                        58804: 34784,
                        58805: 34831,
                        58806: 34829,
                        58807: 34814,
                        58808: 34806,
                        58809: 34807,
                        58810: 34830,
                        58811: 34770,
                        58812: 34833,
                        58813: 34838,
                        58814: 34837,
                        58815: 34850,
                        58816: 34849,
                        58817: 34865,
                        58818: 34870,
                        58819: 34873,
                        58820: 34855,
                        58821: 34875,
                        58822: 34884,
                        58823: 34882,
                        58824: 34898,
                        58825: 34905,
                        58826: 34910,
                        58827: 34914,
                        58828: 34923,
                        58829: 34945,
                        58830: 34942,
                        58831: 34974,
                        58832: 34933,
                        58833: 34941,
                        58834: 34997,
                        58835: 34930,
                        58836: 34946,
                        58837: 34967,
                        58838: 34962,
                        58839: 34990,
                        58840: 34969,
                        58841: 34978,
                        58842: 34957,
                        58843: 34980,
                        58844: 34992,
                        58845: 35007,
                        58846: 34993,
                        58847: 35011,
                        58848: 35012,
                        58849: 35028,
                        58850: 35032,
                        58851: 35033,
                        58852: 35037,
                        58853: 35065,
                        58854: 35074,
                        58855: 35068,
                        58856: 35060,
                        58857: 35048,
                        58858: 35058,
                        58859: 35076,
                        58860: 35084,
                        58861: 35082,
                        58862: 35091,
                        58863: 35139,
                        58864: 35102,
                        58865: 35109,
                        58866: 35114,
                        58867: 35115,
                        58868: 35137,
                        58869: 35140,
                        58870: 35131,
                        58871: 35126,
                        58872: 35128,
                        58873: 35148,
                        58874: 35101,
                        58875: 35168,
                        58876: 35166,
                        58944: 35174,
                        58945: 35172,
                        58946: 35181,
                        58947: 35178,
                        58948: 35183,
                        58949: 35188,
                        58950: 35191,
                        58951: 35198,
                        58952: 35203,
                        58953: 35208,
                        58954: 35210,
                        58955: 35219,
                        58956: 35224,
                        58957: 35233,
                        58958: 35241,
                        58959: 35238,
                        58960: 35244,
                        58961: 35247,
                        58962: 35250,
                        58963: 35258,
                        58964: 35261,
                        58965: 35263,
                        58966: 35264,
                        58967: 35290,
                        58968: 35292,
                        58969: 35293,
                        58970: 35303,
                        58971: 35316,
                        58972: 35320,
                        58973: 35331,
                        58974: 35350,
                        58975: 35344,
                        58976: 35340,
                        58977: 35355,
                        58978: 35357,
                        58979: 35365,
                        58980: 35382,
                        58981: 35393,
                        58982: 35419,
                        58983: 35410,
                        58984: 35398,
                        58985: 35400,
                        58986: 35452,
                        58987: 35437,
                        58988: 35436,
                        58989: 35426,
                        58990: 35461,
                        58991: 35458,
                        58992: 35460,
                        58993: 35496,
                        58994: 35489,
                        58995: 35473,
                        58996: 35493,
                        58997: 35494,
                        58998: 35482,
                        58999: 35491,
                        59e3: 35524,
                        59001: 35533,
                        59002: 35522,
                        59003: 35546,
                        59004: 35563,
                        59005: 35571,
                        59006: 35559,
                        59008: 35556,
                        59009: 35569,
                        59010: 35604,
                        59011: 35552,
                        59012: 35554,
                        59013: 35575,
                        59014: 35550,
                        59015: 35547,
                        59016: 35596,
                        59017: 35591,
                        59018: 35610,
                        59019: 35553,
                        59020: 35606,
                        59021: 35600,
                        59022: 35607,
                        59023: 35616,
                        59024: 35635,
                        59025: 38827,
                        59026: 35622,
                        59027: 35627,
                        59028: 35646,
                        59029: 35624,
                        59030: 35649,
                        59031: 35660,
                        59032: 35663,
                        59033: 35662,
                        59034: 35657,
                        59035: 35670,
                        59036: 35675,
                        59037: 35674,
                        59038: 35691,
                        59039: 35679,
                        59040: 35692,
                        59041: 35695,
                        59042: 35700,
                        59043: 35709,
                        59044: 35712,
                        59045: 35724,
                        59046: 35726,
                        59047: 35730,
                        59048: 35731,
                        59049: 35734,
                        59050: 35737,
                        59051: 35738,
                        59052: 35898,
                        59053: 35905,
                        59054: 35903,
                        59055: 35912,
                        59056: 35916,
                        59057: 35918,
                        59058: 35920,
                        59059: 35925,
                        59060: 35938,
                        59061: 35948,
                        59062: 35960,
                        59063: 35962,
                        59064: 35970,
                        59065: 35977,
                        59066: 35973,
                        59067: 35978,
                        59068: 35981,
                        59069: 35982,
                        59070: 35988,
                        59071: 35964,
                        59072: 35992,
                        59073: 25117,
                        59074: 36013,
                        59075: 36010,
                        59076: 36029,
                        59077: 36018,
                        59078: 36019,
                        59079: 36014,
                        59080: 36022,
                        59081: 36040,
                        59082: 36033,
                        59083: 36068,
                        59084: 36067,
                        59085: 36058,
                        59086: 36093,
                        59087: 36090,
                        59088: 36091,
                        59089: 36100,
                        59090: 36101,
                        59091: 36106,
                        59092: 36103,
                        59093: 36111,
                        59094: 36109,
                        59095: 36112,
                        59096: 40782,
                        59097: 36115,
                        59098: 36045,
                        59099: 36116,
                        59100: 36118,
                        59101: 36199,
                        59102: 36205,
                        59103: 36209,
                        59104: 36211,
                        59105: 36225,
                        59106: 36249,
                        59107: 36290,
                        59108: 36286,
                        59109: 36282,
                        59110: 36303,
                        59111: 36314,
                        59112: 36310,
                        59113: 36300,
                        59114: 36315,
                        59115: 36299,
                        59116: 36330,
                        59117: 36331,
                        59118: 36319,
                        59119: 36323,
                        59120: 36348,
                        59121: 36360,
                        59122: 36361,
                        59123: 36351,
                        59124: 36381,
                        59125: 36382,
                        59126: 36368,
                        59127: 36383,
                        59128: 36418,
                        59129: 36405,
                        59130: 36400,
                        59131: 36404,
                        59132: 36426,
                        59200: 36423,
                        59201: 36425,
                        59202: 36428,
                        59203: 36432,
                        59204: 36424,
                        59205: 36441,
                        59206: 36452,
                        59207: 36448,
                        59208: 36394,
                        59209: 36451,
                        59210: 36437,
                        59211: 36470,
                        59212: 36466,
                        59213: 36476,
                        59214: 36481,
                        59215: 36487,
                        59216: 36485,
                        59217: 36484,
                        59218: 36491,
                        59219: 36490,
                        59220: 36499,
                        59221: 36497,
                        59222: 36500,
                        59223: 36505,
                        59224: 36522,
                        59225: 36513,
                        59226: 36524,
                        59227: 36528,
                        59228: 36550,
                        59229: 36529,
                        59230: 36542,
                        59231: 36549,
                        59232: 36552,
                        59233: 36555,
                        59234: 36571,
                        59235: 36579,
                        59236: 36604,
                        59237: 36603,
                        59238: 36587,
                        59239: 36606,
                        59240: 36618,
                        59241: 36613,
                        59242: 36629,
                        59243: 36626,
                        59244: 36633,
                        59245: 36627,
                        59246: 36636,
                        59247: 36639,
                        59248: 36635,
                        59249: 36620,
                        59250: 36646,
                        59251: 36659,
                        59252: 36667,
                        59253: 36665,
                        59254: 36677,
                        59255: 36674,
                        59256: 36670,
                        59257: 36684,
                        59258: 36681,
                        59259: 36678,
                        59260: 36686,
                        59261: 36695,
                        59262: 36700,
                        59264: 36706,
                        59265: 36707,
                        59266: 36708,
                        59267: 36764,
                        59268: 36767,
                        59269: 36771,
                        59270: 36781,
                        59271: 36783,
                        59272: 36791,
                        59273: 36826,
                        59274: 36837,
                        59275: 36834,
                        59276: 36842,
                        59277: 36847,
                        59278: 36999,
                        59279: 36852,
                        59280: 36869,
                        59281: 36857,
                        59282: 36858,
                        59283: 36881,
                        59284: 36885,
                        59285: 36897,
                        59286: 36877,
                        59287: 36894,
                        59288: 36886,
                        59289: 36875,
                        59290: 36903,
                        59291: 36918,
                        59292: 36917,
                        59293: 36921,
                        59294: 36856,
                        59295: 36943,
                        59296: 36944,
                        59297: 36945,
                        59298: 36946,
                        59299: 36878,
                        59300: 36937,
                        59301: 36926,
                        59302: 36950,
                        59303: 36952,
                        59304: 36958,
                        59305: 36968,
                        59306: 36975,
                        59307: 36982,
                        59308: 38568,
                        59309: 36978,
                        59310: 36994,
                        59311: 36989,
                        59312: 36993,
                        59313: 36992,
                        59314: 37002,
                        59315: 37001,
                        59316: 37007,
                        59317: 37032,
                        59318: 37039,
                        59319: 37041,
                        59320: 37045,
                        59321: 37090,
                        59322: 37092,
                        59323: 25160,
                        59324: 37083,
                        59325: 37122,
                        59326: 37138,
                        59327: 37145,
                        59328: 37170,
                        59329: 37168,
                        59330: 37194,
                        59331: 37206,
                        59332: 37208,
                        59333: 37219,
                        59334: 37221,
                        59335: 37225,
                        59336: 37235,
                        59337: 37234,
                        59338: 37259,
                        59339: 37257,
                        59340: 37250,
                        59341: 37282,
                        59342: 37291,
                        59343: 37295,
                        59344: 37290,
                        59345: 37301,
                        59346: 37300,
                        59347: 37306,
                        59348: 37312,
                        59349: 37313,
                        59350: 37321,
                        59351: 37323,
                        59352: 37328,
                        59353: 37334,
                        59354: 37343,
                        59355: 37345,
                        59356: 37339,
                        59357: 37372,
                        59358: 37365,
                        59359: 37366,
                        59360: 37406,
                        59361: 37375,
                        59362: 37396,
                        59363: 37420,
                        59364: 37397,
                        59365: 37393,
                        59366: 37470,
                        59367: 37463,
                        59368: 37445,
                        59369: 37449,
                        59370: 37476,
                        59371: 37448,
                        59372: 37525,
                        59373: 37439,
                        59374: 37451,
                        59375: 37456,
                        59376: 37532,
                        59377: 37526,
                        59378: 37523,
                        59379: 37531,
                        59380: 37466,
                        59381: 37583,
                        59382: 37561,
                        59383: 37559,
                        59384: 37609,
                        59385: 37647,
                        59386: 37626,
                        59387: 37700,
                        59388: 37678,
                        59456: 37657,
                        59457: 37666,
                        59458: 37658,
                        59459: 37667,
                        59460: 37690,
                        59461: 37685,
                        59462: 37691,
                        59463: 37724,
                        59464: 37728,
                        59465: 37756,
                        59466: 37742,
                        59467: 37718,
                        59468: 37808,
                        59469: 37804,
                        59470: 37805,
                        59471: 37780,
                        59472: 37817,
                        59473: 37846,
                        59474: 37847,
                        59475: 37864,
                        59476: 37861,
                        59477: 37848,
                        59478: 37827,
                        59479: 37853,
                        59480: 37840,
                        59481: 37832,
                        59482: 37860,
                        59483: 37914,
                        59484: 37908,
                        59485: 37907,
                        59486: 37891,
                        59487: 37895,
                        59488: 37904,
                        59489: 37942,
                        59490: 37931,
                        59491: 37941,
                        59492: 37921,
                        59493: 37946,
                        59494: 37953,
                        59495: 37970,
                        59496: 37956,
                        59497: 37979,
                        59498: 37984,
                        59499: 37986,
                        59500: 37982,
                        59501: 37994,
                        59502: 37417,
                        59503: 38e3,
                        59504: 38005,
                        59505: 38007,
                        59506: 38013,
                        59507: 37978,
                        59508: 38012,
                        59509: 38014,
                        59510: 38017,
                        59511: 38015,
                        59512: 38274,
                        59513: 38279,
                        59514: 38282,
                        59515: 38292,
                        59516: 38294,
                        59517: 38296,
                        59518: 38297,
                        59520: 38304,
                        59521: 38312,
                        59522: 38311,
                        59523: 38317,
                        59524: 38332,
                        59525: 38331,
                        59526: 38329,
                        59527: 38334,
                        59528: 38346,
                        59529: 28662,
                        59530: 38339,
                        59531: 38349,
                        59532: 38348,
                        59533: 38357,
                        59534: 38356,
                        59535: 38358,
                        59536: 38364,
                        59537: 38369,
                        59538: 38373,
                        59539: 38370,
                        59540: 38433,
                        59541: 38440,
                        59542: 38446,
                        59543: 38447,
                        59544: 38466,
                        59545: 38476,
                        59546: 38479,
                        59547: 38475,
                        59548: 38519,
                        59549: 38492,
                        59550: 38494,
                        59551: 38493,
                        59552: 38495,
                        59553: 38502,
                        59554: 38514,
                        59555: 38508,
                        59556: 38541,
                        59557: 38552,
                        59558: 38549,
                        59559: 38551,
                        59560: 38570,
                        59561: 38567,
                        59562: 38577,
                        59563: 38578,
                        59564: 38576,
                        59565: 38580,
                        59566: 38582,
                        59567: 38584,
                        59568: 38585,
                        59569: 38606,
                        59570: 38603,
                        59571: 38601,
                        59572: 38605,
                        59573: 35149,
                        59574: 38620,
                        59575: 38669,
                        59576: 38613,
                        59577: 38649,
                        59578: 38660,
                        59579: 38662,
                        59580: 38664,
                        59581: 38675,
                        59582: 38670,
                        59583: 38673,
                        59584: 38671,
                        59585: 38678,
                        59586: 38681,
                        59587: 38692,
                        59588: 38698,
                        59589: 38704,
                        59590: 38713,
                        59591: 38717,
                        59592: 38718,
                        59593: 38724,
                        59594: 38726,
                        59595: 38728,
                        59596: 38722,
                        59597: 38729,
                        59598: 38748,
                        59599: 38752,
                        59600: 38756,
                        59601: 38758,
                        59602: 38760,
                        59603: 21202,
                        59604: 38763,
                        59605: 38769,
                        59606: 38777,
                        59607: 38789,
                        59608: 38780,
                        59609: 38785,
                        59610: 38778,
                        59611: 38790,
                        59612: 38795,
                        59613: 38799,
                        59614: 38800,
                        59615: 38812,
                        59616: 38824,
                        59617: 38822,
                        59618: 38819,
                        59619: 38835,
                        59620: 38836,
                        59621: 38851,
                        59622: 38854,
                        59623: 38856,
                        59624: 38859,
                        59625: 38876,
                        59626: 38893,
                        59627: 40783,
                        59628: 38898,
                        59629: 31455,
                        59630: 38902,
                        59631: 38901,
                        59632: 38927,
                        59633: 38924,
                        59634: 38968,
                        59635: 38948,
                        59636: 38945,
                        59637: 38967,
                        59638: 38973,
                        59639: 38982,
                        59640: 38991,
                        59641: 38987,
                        59642: 39019,
                        59643: 39023,
                        59644: 39024,
                        59712: 39025,
                        59713: 39028,
                        59714: 39027,
                        59715: 39082,
                        59716: 39087,
                        59717: 39089,
                        59718: 39094,
                        59719: 39108,
                        59720: 39107,
                        59721: 39110,
                        59722: 39145,
                        59723: 39147,
                        59724: 39171,
                        59725: 39177,
                        59726: 39186,
                        59727: 39188,
                        59728: 39192,
                        59729: 39201,
                        59730: 39197,
                        59731: 39198,
                        59732: 39204,
                        59733: 39200,
                        59734: 39212,
                        59735: 39214,
                        59736: 39229,
                        59737: 39230,
                        59738: 39234,
                        59739: 39241,
                        59740: 39237,
                        59741: 39248,
                        59742: 39243,
                        59743: 39249,
                        59744: 39250,
                        59745: 39244,
                        59746: 39253,
                        59747: 39319,
                        59748: 39320,
                        59749: 39333,
                        59750: 39341,
                        59751: 39342,
                        59752: 39356,
                        59753: 39391,
                        59754: 39387,
                        59755: 39389,
                        59756: 39384,
                        59757: 39377,
                        59758: 39405,
                        59759: 39406,
                        59760: 39409,
                        59761: 39410,
                        59762: 39419,
                        59763: 39416,
                        59764: 39425,
                        59765: 39439,
                        59766: 39429,
                        59767: 39394,
                        59768: 39449,
                        59769: 39467,
                        59770: 39479,
                        59771: 39493,
                        59772: 39490,
                        59773: 39488,
                        59774: 39491,
                        59776: 39486,
                        59777: 39509,
                        59778: 39501,
                        59779: 39515,
                        59780: 39511,
                        59781: 39519,
                        59782: 39522,
                        59783: 39525,
                        59784: 39524,
                        59785: 39529,
                        59786: 39531,
                        59787: 39530,
                        59788: 39597,
                        59789: 39600,
                        59790: 39612,
                        59791: 39616,
                        59792: 39631,
                        59793: 39633,
                        59794: 39635,
                        59795: 39636,
                        59796: 39646,
                        59797: 39647,
                        59798: 39650,
                        59799: 39651,
                        59800: 39654,
                        59801: 39663,
                        59802: 39659,
                        59803: 39662,
                        59804: 39668,
                        59805: 39665,
                        59806: 39671,
                        59807: 39675,
                        59808: 39686,
                        59809: 39704,
                        59810: 39706,
                        59811: 39711,
                        59812: 39714,
                        59813: 39715,
                        59814: 39717,
                        59815: 39719,
                        59816: 39720,
                        59817: 39721,
                        59818: 39722,
                        59819: 39726,
                        59820: 39727,
                        59821: 39730,
                        59822: 39748,
                        59823: 39747,
                        59824: 39759,
                        59825: 39757,
                        59826: 39758,
                        59827: 39761,
                        59828: 39768,
                        59829: 39796,
                        59830: 39827,
                        59831: 39811,
                        59832: 39825,
                        59833: 39830,
                        59834: 39831,
                        59835: 39839,
                        59836: 39840,
                        59837: 39848,
                        59838: 39860,
                        59839: 39872,
                        59840: 39882,
                        59841: 39865,
                        59842: 39878,
                        59843: 39887,
                        59844: 39889,
                        59845: 39890,
                        59846: 39907,
                        59847: 39906,
                        59848: 39908,
                        59849: 39892,
                        59850: 39905,
                        59851: 39994,
                        59852: 39922,
                        59853: 39921,
                        59854: 39920,
                        59855: 39957,
                        59856: 39956,
                        59857: 39945,
                        59858: 39955,
                        59859: 39948,
                        59860: 39942,
                        59861: 39944,
                        59862: 39954,
                        59863: 39946,
                        59864: 39940,
                        59865: 39982,
                        59866: 39963,
                        59867: 39973,
                        59868: 39972,
                        59869: 39969,
                        59870: 39984,
                        59871: 40007,
                        59872: 39986,
                        59873: 40006,
                        59874: 39998,
                        59875: 40026,
                        59876: 40032,
                        59877: 40039,
                        59878: 40054,
                        59879: 40056,
                        59880: 40167,
                        59881: 40172,
                        59882: 40176,
                        59883: 40201,
                        59884: 40200,
                        59885: 40171,
                        59886: 40195,
                        59887: 40198,
                        59888: 40234,
                        59889: 40230,
                        59890: 40367,
                        59891: 40227,
                        59892: 40223,
                        59893: 40260,
                        59894: 40213,
                        59895: 40210,
                        59896: 40257,
                        59897: 40255,
                        59898: 40254,
                        59899: 40262,
                        59900: 40264,
                        59968: 40285,
                        59969: 40286,
                        59970: 40292,
                        59971: 40273,
                        59972: 40272,
                        59973: 40281,
                        59974: 40306,
                        59975: 40329,
                        59976: 40327,
                        59977: 40363,
                        59978: 40303,
                        59979: 40314,
                        59980: 40346,
                        59981: 40356,
                        59982: 40361,
                        59983: 40370,
                        59984: 40388,
                        59985: 40385,
                        59986: 40379,
                        59987: 40376,
                        59988: 40378,
                        59989: 40390,
                        59990: 40399,
                        59991: 40386,
                        59992: 40409,
                        59993: 40403,
                        59994: 40440,
                        59995: 40422,
                        59996: 40429,
                        59997: 40431,
                        59998: 40445,
                        59999: 40474,
                        6e4: 40475,
                        60001: 40478,
                        60002: 40565,
                        60003: 40569,
                        60004: 40573,
                        60005: 40577,
                        60006: 40584,
                        60007: 40587,
                        60008: 40588,
                        60009: 40594,
                        60010: 40597,
                        60011: 40593,
                        60012: 40605,
                        60013: 40613,
                        60014: 40617,
                        60015: 40632,
                        60016: 40618,
                        60017: 40621,
                        60018: 38753,
                        60019: 40652,
                        60020: 40654,
                        60021: 40655,
                        60022: 40656,
                        60023: 40660,
                        60024: 40668,
                        60025: 40670,
                        60026: 40669,
                        60027: 40672,
                        60028: 40677,
                        60029: 40680,
                        60030: 40687,
                        60032: 40692,
                        60033: 40694,
                        60034: 40695,
                        60035: 40697,
                        60036: 40699,
                        60037: 40700,
                        60038: 40701,
                        60039: 40711,
                        60040: 40712,
                        60041: 30391,
                        60042: 40725,
                        60043: 40737,
                        60044: 40748,
                        60045: 40766,
                        60046: 40778,
                        60047: 40786,
                        60048: 40788,
                        60049: 40803,
                        60050: 40799,
                        60051: 40800,
                        60052: 40801,
                        60053: 40806,
                        60054: 40807,
                        60055: 40812,
                        60056: 40810,
                        60057: 40823,
                        60058: 40818,
                        60059: 40822,
                        60060: 40853,
                        60061: 40860,
                        60062: 40864,
                        60063: 22575,
                        60064: 27079,
                        60065: 36953,
                        60066: 29796,
                        60067: 20956,
                        60068: 29081,
                        60736: 32394,
                        60737: 35100,
                        60738: 37704,
                        60739: 37512,
                        60740: 34012,
                        60741: 20425,
                        60742: 28859,
                        60743: 26161,
                        60744: 26824,
                        60745: 37625,
                        60746: 26363,
                        60747: 24389,
                        60748: 20008,
                        60749: 20193,
                        60750: 20220,
                        60751: 20224,
                        60752: 20227,
                        60753: 20281,
                        60754: 20310,
                        60755: 20370,
                        60756: 20362,
                        60757: 20378,
                        60758: 20372,
                        60759: 20429,
                        60760: 20544,
                        60761: 20514,
                        60762: 20479,
                        60763: 20510,
                        60764: 20550,
                        60765: 20592,
                        60766: 20546,
                        60767: 20628,
                        60768: 20724,
                        60769: 20696,
                        60770: 20810,
                        60771: 20836,
                        60772: 20893,
                        60773: 20926,
                        60774: 20972,
                        60775: 21013,
                        60776: 21148,
                        60777: 21158,
                        60778: 21184,
                        60779: 21211,
                        60780: 21248,
                        60781: 21255,
                        60782: 21284,
                        60783: 21362,
                        60784: 21395,
                        60785: 21426,
                        60786: 21469,
                        60787: 64014,
                        60788: 21660,
                        60789: 21642,
                        60790: 21673,
                        60791: 21759,
                        60792: 21894,
                        60793: 22361,
                        60794: 22373,
                        60795: 22444,
                        60796: 22472,
                        60797: 22471,
                        60798: 64015,
                        60800: 64016,
                        60801: 22686,
                        60802: 22706,
                        60803: 22795,
                        60804: 22867,
                        60805: 22875,
                        60806: 22877,
                        60807: 22883,
                        60808: 22948,
                        60809: 22970,
                        60810: 23382,
                        60811: 23488,
                        60812: 29999,
                        60813: 23512,
                        60814: 23532,
                        60815: 23582,
                        60816: 23718,
                        60817: 23738,
                        60818: 23797,
                        60819: 23847,
                        60820: 23891,
                        60821: 64017,
                        60822: 23874,
                        60823: 23917,
                        60824: 23992,
                        60825: 23993,
                        60826: 24016,
                        60827: 24353,
                        60828: 24372,
                        60829: 24423,
                        60830: 24503,
                        60831: 24542,
                        60832: 24669,
                        60833: 24709,
                        60834: 24714,
                        60835: 24798,
                        60836: 24789,
                        60837: 24864,
                        60838: 24818,
                        60839: 24849,
                        60840: 24887,
                        60841: 24880,
                        60842: 24984,
                        60843: 25107,
                        60844: 25254,
                        60845: 25589,
                        60846: 25696,
                        60847: 25757,
                        60848: 25806,
                        60849: 25934,
                        60850: 26112,
                        60851: 26133,
                        60852: 26171,
                        60853: 26121,
                        60854: 26158,
                        60855: 26142,
                        60856: 26148,
                        60857: 26213,
                        60858: 26199,
                        60859: 26201,
                        60860: 64018,
                        60861: 26227,
                        60862: 26265,
                        60863: 26272,
                        60864: 26290,
                        60865: 26303,
                        60866: 26362,
                        60867: 26382,
                        60868: 63785,
                        60869: 26470,
                        60870: 26555,
                        60871: 26706,
                        60872: 26560,
                        60873: 26625,
                        60874: 26692,
                        60875: 26831,
                        60876: 64019,
                        60877: 26984,
                        60878: 64020,
                        60879: 27032,
                        60880: 27106,
                        60881: 27184,
                        60882: 27243,
                        60883: 27206,
                        60884: 27251,
                        60885: 27262,
                        60886: 27362,
                        60887: 27364,
                        60888: 27606,
                        60889: 27711,
                        60890: 27740,
                        60891: 27782,
                        60892: 27759,
                        60893: 27866,
                        60894: 27908,
                        60895: 28039,
                        60896: 28015,
                        60897: 28054,
                        60898: 28076,
                        60899: 28111,
                        60900: 28152,
                        60901: 28146,
                        60902: 28156,
                        60903: 28217,
                        60904: 28252,
                        60905: 28199,
                        60906: 28220,
                        60907: 28351,
                        60908: 28552,
                        60909: 28597,
                        60910: 28661,
                        60911: 28677,
                        60912: 28679,
                        60913: 28712,
                        60914: 28805,
                        60915: 28843,
                        60916: 28943,
                        60917: 28932,
                        60918: 29020,
                        60919: 28998,
                        60920: 28999,
                        60921: 64021,
                        60922: 29121,
                        60923: 29182,
                        60924: 29361,
                        60992: 29374,
                        60993: 29476,
                        60994: 64022,
                        60995: 29559,
                        60996: 29629,
                        60997: 29641,
                        60998: 29654,
                        60999: 29667,
                        61e3: 29650,
                        61001: 29703,
                        61002: 29685,
                        61003: 29734,
                        61004: 29738,
                        61005: 29737,
                        61006: 29742,
                        61007: 29794,
                        61008: 29833,
                        61009: 29855,
                        61010: 29953,
                        61011: 30063,
                        61012: 30338,
                        61013: 30364,
                        61014: 30366,
                        61015: 30363,
                        61016: 30374,
                        61017: 64023,
                        61018: 30534,
                        61019: 21167,
                        61020: 30753,
                        61021: 30798,
                        61022: 30820,
                        61023: 30842,
                        61024: 31024,
                        61025: 64024,
                        61026: 64025,
                        61027: 64026,
                        61028: 31124,
                        61029: 64027,
                        61030: 31131,
                        61031: 31441,
                        61032: 31463,
                        61033: 64028,
                        61034: 31467,
                        61035: 31646,
                        61036: 64029,
                        61037: 32072,
                        61038: 32092,
                        61039: 32183,
                        61040: 32160,
                        61041: 32214,
                        61042: 32338,
                        61043: 32583,
                        61044: 32673,
                        61045: 64030,
                        61046: 33537,
                        61047: 33634,
                        61048: 33663,
                        61049: 33735,
                        61050: 33782,
                        61051: 33864,
                        61052: 33972,
                        61053: 34131,
                        61054: 34137,
                        61056: 34155,
                        61057: 64031,
                        61058: 34224,
                        61059: 64032,
                        61060: 64033,
                        61061: 34823,
                        61062: 35061,
                        61063: 35346,
                        61064: 35383,
                        61065: 35449,
                        61066: 35495,
                        61067: 35518,
                        61068: 35551,
                        61069: 64034,
                        61070: 35574,
                        61071: 35667,
                        61072: 35711,
                        61073: 36080,
                        61074: 36084,
                        61075: 36114,
                        61076: 36214,
                        61077: 64035,
                        61078: 36559,
                        61079: 64036,
                        61080: 64037,
                        61081: 36967,
                        61082: 37086,
                        61083: 64038,
                        61084: 37141,
                        61085: 37159,
                        61086: 37338,
                        61087: 37335,
                        61088: 37342,
                        61089: 37357,
                        61090: 37358,
                        61091: 37348,
                        61092: 37349,
                        61093: 37382,
                        61094: 37392,
                        61095: 37386,
                        61096: 37434,
                        61097: 37440,
                        61098: 37436,
                        61099: 37454,
                        61100: 37465,
                        61101: 37457,
                        61102: 37433,
                        61103: 37479,
                        61104: 37543,
                        61105: 37495,
                        61106: 37496,
                        61107: 37607,
                        61108: 37591,
                        61109: 37593,
                        61110: 37584,
                        61111: 64039,
                        61112: 37589,
                        61113: 37600,
                        61114: 37587,
                        61115: 37669,
                        61116: 37665,
                        61117: 37627,
                        61118: 64040,
                        61119: 37662,
                        61120: 37631,
                        61121: 37661,
                        61122: 37634,
                        61123: 37744,
                        61124: 37719,
                        61125: 37796,
                        61126: 37830,
                        61127: 37854,
                        61128: 37880,
                        61129: 37937,
                        61130: 37957,
                        61131: 37960,
                        61132: 38290,
                        61133: 63964,
                        61134: 64041,
                        61135: 38557,
                        61136: 38575,
                        61137: 38707,
                        61138: 38715,
                        61139: 38723,
                        61140: 38733,
                        61141: 38735,
                        61142: 38737,
                        61143: 38741,
                        61144: 38999,
                        61145: 39013,
                        61146: 64042,
                        61147: 64043,
                        61148: 39207,
                        61149: 64044,
                        61150: 39326,
                        61151: 39502,
                        61152: 39641,
                        61153: 39644,
                        61154: 39797,
                        61155: 39794,
                        61156: 39823,
                        61157: 39857,
                        61158: 39867,
                        61159: 39936,
                        61160: 40304,
                        61161: 40299,
                        61162: 64045,
                        61163: 40473,
                        61164: 40657,
                        61167: 8560,
                        61168: 8561,
                        61169: 8562,
                        61170: 8563,
                        61171: 8564,
                        61172: 8565,
                        61173: 8566,
                        61174: 8567,
                        61175: 8568,
                        61176: 8569,
                        61177: 65506,
                        61178: 65508,
                        61179: 65287,
                        61180: 65282,
                        61504: 57344,
                        61505: 57345,
                        61506: 57346,
                        61507: 57347,
                        61508: 57348,
                        61509: 57349,
                        61510: 57350,
                        61511: 57351,
                        61512: 57352,
                        61513: 57353,
                        61514: 57354,
                        61515: 57355,
                        61516: 57356,
                        61517: 57357,
                        61518: 57358,
                        61519: 57359,
                        61520: 57360,
                        61521: 57361,
                        61522: 57362,
                        61523: 57363,
                        61524: 57364,
                        61525: 57365,
                        61526: 57366,
                        61527: 57367,
                        61528: 57368,
                        61529: 57369,
                        61530: 57370,
                        61531: 57371,
                        61532: 57372,
                        61533: 57373,
                        61534: 57374,
                        61535: 57375,
                        61536: 57376,
                        61537: 57377,
                        61538: 57378,
                        61539: 57379,
                        61540: 57380,
                        61541: 57381,
                        61542: 57382,
                        61543: 57383,
                        61544: 57384,
                        61545: 57385,
                        61546: 57386,
                        61547: 57387,
                        61548: 57388,
                        61549: 57389,
                        61550: 57390,
                        61551: 57391,
                        61552: 57392,
                        61553: 57393,
                        61554: 57394,
                        61555: 57395,
                        61556: 57396,
                        61557: 57397,
                        61558: 57398,
                        61559: 57399,
                        61560: 57400,
                        61561: 57401,
                        61562: 57402,
                        61563: 57403,
                        61564: 57404,
                        61565: 57405,
                        61566: 57406,
                        61568: 57407,
                        61569: 57408,
                        61570: 57409,
                        61571: 57410,
                        61572: 57411,
                        61573: 57412,
                        61574: 57413,
                        61575: 57414,
                        61576: 57415,
                        61577: 57416,
                        61578: 57417,
                        61579: 57418,
                        61580: 57419,
                        61581: 57420,
                        61582: 57421,
                        61583: 57422,
                        61584: 57423,
                        61585: 57424,
                        61586: 57425,
                        61587: 57426,
                        61588: 57427,
                        61589: 57428,
                        61590: 57429,
                        61591: 57430,
                        61592: 57431,
                        61593: 57432,
                        61594: 57433,
                        61595: 57434,
                        61596: 57435,
                        61597: 57436,
                        61598: 57437,
                        61599: 57438,
                        61600: 57439,
                        61601: 57440,
                        61602: 57441,
                        61603: 57442,
                        61604: 57443,
                        61605: 57444,
                        61606: 57445,
                        61607: 57446,
                        61608: 57447,
                        61609: 57448,
                        61610: 57449,
                        61611: 57450,
                        61612: 57451,
                        61613: 57452,
                        61614: 57453,
                        61615: 57454,
                        61616: 57455,
                        61617: 57456,
                        61618: 57457,
                        61619: 57458,
                        61620: 57459,
                        61621: 57460,
                        61622: 57461,
                        61623: 57462,
                        61624: 57463,
                        61625: 57464,
                        61626: 57465,
                        61627: 57466,
                        61628: 57467,
                        61629: 57468,
                        61630: 57469,
                        61631: 57470,
                        61632: 57471,
                        61633: 57472,
                        61634: 57473,
                        61635: 57474,
                        61636: 57475,
                        61637: 57476,
                        61638: 57477,
                        61639: 57478,
                        61640: 57479,
                        61641: 57480,
                        61642: 57481,
                        61643: 57482,
                        61644: 57483,
                        61645: 57484,
                        61646: 57485,
                        61647: 57486,
                        61648: 57487,
                        61649: 57488,
                        61650: 57489,
                        61651: 57490,
                        61652: 57491,
                        61653: 57492,
                        61654: 57493,
                        61655: 57494,
                        61656: 57495,
                        61657: 57496,
                        61658: 57497,
                        61659: 57498,
                        61660: 57499,
                        61661: 57500,
                        61662: 57501,
                        61663: 57502,
                        61664: 57503,
                        61665: 57504,
                        61666: 57505,
                        61667: 57506,
                        61668: 57507,
                        61669: 57508,
                        61670: 57509,
                        61671: 57510,
                        61672: 57511,
                        61673: 57512,
                        61674: 57513,
                        61675: 57514,
                        61676: 57515,
                        61677: 57516,
                        61678: 57517,
                        61679: 57518,
                        61680: 57519,
                        61681: 57520,
                        61682: 57521,
                        61683: 57522,
                        61684: 57523,
                        61685: 57524,
                        61686: 57525,
                        61687: 57526,
                        61688: 57527,
                        61689: 57528,
                        61690: 57529,
                        61691: 57530,
                        61692: 57531,
                        61760: 57532,
                        61761: 57533,
                        61762: 57534,
                        61763: 57535,
                        61764: 57536,
                        61765: 57537,
                        61766: 57538,
                        61767: 57539,
                        61768: 57540,
                        61769: 57541,
                        61770: 57542,
                        61771: 57543,
                        61772: 57544,
                        61773: 57545,
                        61774: 57546,
                        61775: 57547,
                        61776: 57548,
                        61777: 57549,
                        61778: 57550,
                        61779: 57551,
                        61780: 57552,
                        61781: 57553,
                        61782: 57554,
                        61783: 57555,
                        61784: 57556,
                        61785: 57557,
                        61786: 57558,
                        61787: 57559,
                        61788: 57560,
                        61789: 57561,
                        61790: 57562,
                        61791: 57563,
                        61792: 57564,
                        61793: 57565,
                        61794: 57566,
                        61795: 57567,
                        61796: 57568,
                        61797: 57569,
                        61798: 57570,
                        61799: 57571,
                        61800: 57572,
                        61801: 57573,
                        61802: 57574,
                        61803: 57575,
                        61804: 57576,
                        61805: 57577,
                        61806: 57578,
                        61807: 57579,
                        61808: 57580,
                        61809: 57581,
                        61810: 57582,
                        61811: 57583,
                        61812: 57584,
                        61813: 57585,
                        61814: 57586,
                        61815: 57587,
                        61816: 57588,
                        61817: 57589,
                        61818: 57590,
                        61819: 57591,
                        61820: 57592,
                        61821: 57593,
                        61822: 57594,
                        61824: 57595,
                        61825: 57596,
                        61826: 57597,
                        61827: 57598,
                        61828: 57599,
                        61829: 57600,
                        61830: 57601,
                        61831: 57602,
                        61832: 57603,
                        61833: 57604,
                        61834: 57605,
                        61835: 57606,
                        61836: 57607,
                        61837: 57608,
                        61838: 57609,
                        61839: 57610,
                        61840: 57611,
                        61841: 57612,
                        61842: 57613,
                        61843: 57614,
                        61844: 57615,
                        61845: 57616,
                        61846: 57617,
                        61847: 57618,
                        61848: 57619,
                        61849: 57620,
                        61850: 57621,
                        61851: 57622,
                        61852: 57623,
                        61853: 57624,
                        61854: 57625,
                        61855: 57626,
                        61856: 57627,
                        61857: 57628,
                        61858: 57629,
                        61859: 57630,
                        61860: 57631,
                        61861: 57632,
                        61862: 57633,
                        61863: 57634,
                        61864: 57635,
                        61865: 57636,
                        61866: 57637,
                        61867: 57638,
                        61868: 57639,
                        61869: 57640,
                        61870: 57641,
                        61871: 57642,
                        61872: 57643,
                        61873: 57644,
                        61874: 57645,
                        61875: 57646,
                        61876: 57647,
                        61877: 57648,
                        61878: 57649,
                        61879: 57650,
                        61880: 57651,
                        61881: 57652,
                        61882: 57653,
                        61883: 57654,
                        61884: 57655,
                        61885: 57656,
                        61886: 57657,
                        61887: 57658,
                        61888: 57659,
                        61889: 57660,
                        61890: 57661,
                        61891: 57662,
                        61892: 57663,
                        61893: 57664,
                        61894: 57665,
                        61895: 57666,
                        61896: 57667,
                        61897: 57668,
                        61898: 57669,
                        61899: 57670,
                        61900: 57671,
                        61901: 57672,
                        61902: 57673,
                        61903: 57674,
                        61904: 57675,
                        61905: 57676,
                        61906: 57677,
                        61907: 57678,
                        61908: 57679,
                        61909: 57680,
                        61910: 57681,
                        61911: 57682,
                        61912: 57683,
                        61913: 57684,
                        61914: 57685,
                        61915: 57686,
                        61916: 57687,
                        61917: 57688,
                        61918: 57689,
                        61919: 57690,
                        61920: 57691,
                        61921: 57692,
                        61922: 57693,
                        61923: 57694,
                        61924: 57695,
                        61925: 57696,
                        61926: 57697,
                        61927: 57698,
                        61928: 57699,
                        61929: 57700,
                        61930: 57701,
                        61931: 57702,
                        61932: 57703,
                        61933: 57704,
                        61934: 57705,
                        61935: 57706,
                        61936: 57707,
                        61937: 57708,
                        61938: 57709,
                        61939: 57710,
                        61940: 57711,
                        61941: 57712,
                        61942: 57713,
                        61943: 57714,
                        61944: 57715,
                        61945: 57716,
                        61946: 57717,
                        61947: 57718,
                        61948: 57719,
                        62016: 57720,
                        62017: 57721,
                        62018: 57722,
                        62019: 57723,
                        62020: 57724,
                        62021: 57725,
                        62022: 57726,
                        62023: 57727,
                        62024: 57728,
                        62025: 57729,
                        62026: 57730,
                        62027: 57731,
                        62028: 57732,
                        62029: 57733,
                        62030: 57734,
                        62031: 57735,
                        62032: 57736,
                        62033: 57737,
                        62034: 57738,
                        62035: 57739,
                        62036: 57740,
                        62037: 57741,
                        62038: 57742,
                        62039: 57743,
                        62040: 57744,
                        62041: 57745,
                        62042: 57746,
                        62043: 57747,
                        62044: 57748,
                        62045: 57749,
                        62046: 57750,
                        62047: 57751,
                        62048: 57752,
                        62049: 57753,
                        62050: 57754,
                        62051: 57755,
                        62052: 57756,
                        62053: 57757,
                        62054: 57758,
                        62055: 57759,
                        62056: 57760,
                        62057: 57761,
                        62058: 57762,
                        62059: 57763,
                        62060: 57764,
                        62061: 57765,
                        62062: 57766,
                        62063: 57767,
                        62064: 57768,
                        62065: 57769,
                        62066: 57770,
                        62067: 57771,
                        62068: 57772,
                        62069: 57773,
                        62070: 57774,
                        62071: 57775,
                        62072: 57776,
                        62073: 57777,
                        62074: 57778,
                        62075: 57779,
                        62076: 57780,
                        62077: 57781,
                        62078: 57782,
                        62080: 57783,
                        62081: 57784,
                        62082: 57785,
                        62083: 57786,
                        62084: 57787,
                        62085: 57788,
                        62086: 57789,
                        62087: 57790,
                        62088: 57791,
                        62089: 57792,
                        62090: 57793,
                        62091: 57794,
                        62092: 57795,
                        62093: 57796,
                        62094: 57797,
                        62095: 57798,
                        62096: 57799,
                        62097: 57800,
                        62098: 57801,
                        62099: 57802,
                        62100: 57803,
                        62101: 57804,
                        62102: 57805,
                        62103: 57806,
                        62104: 57807,
                        62105: 57808,
                        62106: 57809,
                        62107: 57810,
                        62108: 57811,
                        62109: 57812,
                        62110: 57813,
                        62111: 57814,
                        62112: 57815,
                        62113: 57816,
                        62114: 57817,
                        62115: 57818,
                        62116: 57819,
                        62117: 57820,
                        62118: 57821,
                        62119: 57822,
                        62120: 57823,
                        62121: 57824,
                        62122: 57825,
                        62123: 57826,
                        62124: 57827,
                        62125: 57828,
                        62126: 57829,
                        62127: 57830,
                        62128: 57831,
                        62129: 57832,
                        62130: 57833,
                        62131: 57834,
                        62132: 57835,
                        62133: 57836,
                        62134: 57837,
                        62135: 57838,
                        62136: 57839,
                        62137: 57840,
                        62138: 57841,
                        62139: 57842,
                        62140: 57843,
                        62141: 57844,
                        62142: 57845,
                        62143: 57846,
                        62144: 57847,
                        62145: 57848,
                        62146: 57849,
                        62147: 57850,
                        62148: 57851,
                        62149: 57852,
                        62150: 57853,
                        62151: 57854,
                        62152: 57855,
                        62153: 57856,
                        62154: 57857,
                        62155: 57858,
                        62156: 57859,
                        62157: 57860,
                        62158: 57861,
                        62159: 57862,
                        62160: 57863,
                        62161: 57864,
                        62162: 57865,
                        62163: 57866,
                        62164: 57867,
                        62165: 57868,
                        62166: 57869,
                        62167: 57870,
                        62168: 57871,
                        62169: 57872,
                        62170: 57873,
                        62171: 57874,
                        62172: 57875,
                        62173: 57876,
                        62174: 57877,
                        62175: 57878,
                        62176: 57879,
                        62177: 57880,
                        62178: 57881,
                        62179: 57882,
                        62180: 57883,
                        62181: 57884,
                        62182: 57885,
                        62183: 57886,
                        62184: 57887,
                        62185: 57888,
                        62186: 57889,
                        62187: 57890,
                        62188: 57891,
                        62189: 57892,
                        62190: 57893,
                        62191: 57894,
                        62192: 57895,
                        62193: 57896,
                        62194: 57897,
                        62195: 57898,
                        62196: 57899,
                        62197: 57900,
                        62198: 57901,
                        62199: 57902,
                        62200: 57903,
                        62201: 57904,
                        62202: 57905,
                        62203: 57906,
                        62204: 57907,
                        62272: 57908,
                        62273: 57909,
                        62274: 57910,
                        62275: 57911,
                        62276: 57912,
                        62277: 57913,
                        62278: 57914,
                        62279: 57915,
                        62280: 57916,
                        62281: 57917,
                        62282: 57918,
                        62283: 57919,
                        62284: 57920,
                        62285: 57921,
                        62286: 57922,
                        62287: 57923,
                        62288: 57924,
                        62289: 57925,
                        62290: 57926,
                        62291: 57927,
                        62292: 57928,
                        62293: 57929,
                        62294: 57930,
                        62295: 57931,
                        62296: 57932,
                        62297: 57933,
                        62298: 57934,
                        62299: 57935,
                        62300: 57936,
                        62301: 57937,
                        62302: 57938,
                        62303: 57939,
                        62304: 57940,
                        62305: 57941,
                        62306: 57942,
                        62307: 57943,
                        62308: 57944,
                        62309: 57945,
                        62310: 57946,
                        62311: 57947,
                        62312: 57948,
                        62313: 57949,
                        62314: 57950,
                        62315: 57951,
                        62316: 57952,
                        62317: 57953,
                        62318: 57954,
                        62319: 57955,
                        62320: 57956,
                        62321: 57957,
                        62322: 57958,
                        62323: 57959,
                        62324: 57960,
                        62325: 57961,
                        62326: 57962,
                        62327: 57963,
                        62328: 57964,
                        62329: 57965,
                        62330: 57966,
                        62331: 57967,
                        62332: 57968,
                        62333: 57969,
                        62334: 57970,
                        62336: 57971,
                        62337: 57972,
                        62338: 57973,
                        62339: 57974,
                        62340: 57975,
                        62341: 57976,
                        62342: 57977,
                        62343: 57978,
                        62344: 57979,
                        62345: 57980,
                        62346: 57981,
                        62347: 57982,
                        62348: 57983,
                        62349: 57984,
                        62350: 57985,
                        62351: 57986,
                        62352: 57987,
                        62353: 57988,
                        62354: 57989,
                        62355: 57990,
                        62356: 57991,
                        62357: 57992,
                        62358: 57993,
                        62359: 57994,
                        62360: 57995,
                        62361: 57996,
                        62362: 57997,
                        62363: 57998,
                        62364: 57999,
                        62365: 58e3,
                        62366: 58001,
                        62367: 58002,
                        62368: 58003,
                        62369: 58004,
                        62370: 58005,
                        62371: 58006,
                        62372: 58007,
                        62373: 58008,
                        62374: 58009,
                        62375: 58010,
                        62376: 58011,
                        62377: 58012,
                        62378: 58013,
                        62379: 58014,
                        62380: 58015,
                        62381: 58016,
                        62382: 58017,
                        62383: 58018,
                        62384: 58019,
                        62385: 58020,
                        62386: 58021,
                        62387: 58022,
                        62388: 58023,
                        62389: 58024,
                        62390: 58025,
                        62391: 58026,
                        62392: 58027,
                        62393: 58028,
                        62394: 58029,
                        62395: 58030,
                        62396: 58031,
                        62397: 58032,
                        62398: 58033,
                        62399: 58034,
                        62400: 58035,
                        62401: 58036,
                        62402: 58037,
                        62403: 58038,
                        62404: 58039,
                        62405: 58040,
                        62406: 58041,
                        62407: 58042,
                        62408: 58043,
                        62409: 58044,
                        62410: 58045,
                        62411: 58046,
                        62412: 58047,
                        62413: 58048,
                        62414: 58049,
                        62415: 58050,
                        62416: 58051,
                        62417: 58052,
                        62418: 58053,
                        62419: 58054,
                        62420: 58055,
                        62421: 58056,
                        62422: 58057,
                        62423: 58058,
                        62424: 58059,
                        62425: 58060,
                        62426: 58061,
                        62427: 58062,
                        62428: 58063,
                        62429: 58064,
                        62430: 58065,
                        62431: 58066,
                        62432: 58067,
                        62433: 58068,
                        62434: 58069,
                        62435: 58070,
                        62436: 58071,
                        62437: 58072,
                        62438: 58073,
                        62439: 58074,
                        62440: 58075,
                        62441: 58076,
                        62442: 58077,
                        62443: 58078,
                        62444: 58079,
                        62445: 58080,
                        62446: 58081,
                        62447: 58082,
                        62448: 58083,
                        62449: 58084,
                        62450: 58085,
                        62451: 58086,
                        62452: 58087,
                        62453: 58088,
                        62454: 58089,
                        62455: 58090,
                        62456: 58091,
                        62457: 58092,
                        62458: 58093,
                        62459: 58094,
                        62460: 58095,
                        62528: 58096,
                        62529: 58097,
                        62530: 58098,
                        62531: 58099,
                        62532: 58100,
                        62533: 58101,
                        62534: 58102,
                        62535: 58103,
                        62536: 58104,
                        62537: 58105,
                        62538: 58106,
                        62539: 58107,
                        62540: 58108,
                        62541: 58109,
                        62542: 58110,
                        62543: 58111,
                        62544: 58112,
                        62545: 58113,
                        62546: 58114,
                        62547: 58115,
                        62548: 58116,
                        62549: 58117,
                        62550: 58118,
                        62551: 58119,
                        62552: 58120,
                        62553: 58121,
                        62554: 58122,
                        62555: 58123,
                        62556: 58124,
                        62557: 58125,
                        62558: 58126,
                        62559: 58127,
                        62560: 58128,
                        62561: 58129,
                        62562: 58130,
                        62563: 58131,
                        62564: 58132,
                        62565: 58133,
                        62566: 58134,
                        62567: 58135,
                        62568: 58136,
                        62569: 58137,
                        62570: 58138,
                        62571: 58139,
                        62572: 58140,
                        62573: 58141,
                        62574: 58142,
                        62575: 58143,
                        62576: 58144,
                        62577: 58145,
                        62578: 58146,
                        62579: 58147,
                        62580: 58148,
                        62581: 58149,
                        62582: 58150,
                        62583: 58151,
                        62584: 58152,
                        62585: 58153,
                        62586: 58154,
                        62587: 58155,
                        62588: 58156,
                        62589: 58157,
                        62590: 58158,
                        62592: 58159,
                        62593: 58160,
                        62594: 58161,
                        62595: 58162,
                        62596: 58163,
                        62597: 58164,
                        62598: 58165,
                        62599: 58166,
                        62600: 58167,
                        62601: 58168,
                        62602: 58169,
                        62603: 58170,
                        62604: 58171,
                        62605: 58172,
                        62606: 58173,
                        62607: 58174,
                        62608: 58175,
                        62609: 58176,
                        62610: 58177,
                        62611: 58178,
                        62612: 58179,
                        62613: 58180,
                        62614: 58181,
                        62615: 58182,
                        62616: 58183,
                        62617: 58184,
                        62618: 58185,
                        62619: 58186,
                        62620: 58187,
                        62621: 58188,
                        62622: 58189,
                        62623: 58190,
                        62624: 58191,
                        62625: 58192,
                        62626: 58193,
                        62627: 58194,
                        62628: 58195,
                        62629: 58196,
                        62630: 58197,
                        62631: 58198,
                        62632: 58199,
                        62633: 58200,
                        62634: 58201,
                        62635: 58202,
                        62636: 58203,
                        62637: 58204,
                        62638: 58205,
                        62639: 58206,
                        62640: 58207,
                        62641: 58208,
                        62642: 58209,
                        62643: 58210,
                        62644: 58211,
                        62645: 58212,
                        62646: 58213,
                        62647: 58214,
                        62648: 58215,
                        62649: 58216,
                        62650: 58217,
                        62651: 58218,
                        62652: 58219,
                        62653: 58220,
                        62654: 58221,
                        62655: 58222,
                        62656: 58223,
                        62657: 58224,
                        62658: 58225,
                        62659: 58226,
                        62660: 58227,
                        62661: 58228,
                        62662: 58229,
                        62663: 58230,
                        62664: 58231,
                        62665: 58232,
                        62666: 58233,
                        62667: 58234,
                        62668: 58235,
                        62669: 58236,
                        62670: 58237,
                        62671: 58238,
                        62672: 58239,
                        62673: 58240,
                        62674: 58241,
                        62675: 58242,
                        62676: 58243,
                        62677: 58244,
                        62678: 58245,
                        62679: 58246,
                        62680: 58247,
                        62681: 58248,
                        62682: 58249,
                        62683: 58250,
                        62684: 58251,
                        62685: 58252,
                        62686: 58253,
                        62687: 58254,
                        62688: 58255,
                        62689: 58256,
                        62690: 58257,
                        62691: 58258,
                        62692: 58259,
                        62693: 58260,
                        62694: 58261,
                        62695: 58262,
                        62696: 58263,
                        62697: 58264,
                        62698: 58265,
                        62699: 58266,
                        62700: 58267,
                        62701: 58268,
                        62702: 58269,
                        62703: 58270,
                        62704: 58271,
                        62705: 58272,
                        62706: 58273,
                        62707: 58274,
                        62708: 58275,
                        62709: 58276,
                        62710: 58277,
                        62711: 58278,
                        62712: 58279,
                        62713: 58280,
                        62714: 58281,
                        62715: 58282,
                        62716: 58283,
                        62784: 58284,
                        62785: 58285,
                        62786: 58286,
                        62787: 58287,
                        62788: 58288,
                        62789: 58289,
                        62790: 58290,
                        62791: 58291,
                        62792: 58292,
                        62793: 58293,
                        62794: 58294,
                        62795: 58295,
                        62796: 58296,
                        62797: 58297,
                        62798: 58298,
                        62799: 58299,
                        62800: 58300,
                        62801: 58301,
                        62802: 58302,
                        62803: 58303,
                        62804: 58304,
                        62805: 58305,
                        62806: 58306,
                        62807: 58307,
                        62808: 58308,
                        62809: 58309,
                        62810: 58310,
                        62811: 58311,
                        62812: 58312,
                        62813: 58313,
                        62814: 58314,
                        62815: 58315,
                        62816: 58316,
                        62817: 58317,
                        62818: 58318,
                        62819: 58319,
                        62820: 58320,
                        62821: 58321,
                        62822: 58322,
                        62823: 58323,
                        62824: 58324,
                        62825: 58325,
                        62826: 58326,
                        62827: 58327,
                        62828: 58328,
                        62829: 58329,
                        62830: 58330,
                        62831: 58331,
                        62832: 58332,
                        62833: 58333,
                        62834: 58334,
                        62835: 58335,
                        62836: 58336,
                        62837: 58337,
                        62838: 58338,
                        62839: 58339,
                        62840: 58340,
                        62841: 58341,
                        62842: 58342,
                        62843: 58343,
                        62844: 58344,
                        62845: 58345,
                        62846: 58346,
                        62848: 58347,
                        62849: 58348,
                        62850: 58349,
                        62851: 58350,
                        62852: 58351,
                        62853: 58352,
                        62854: 58353,
                        62855: 58354,
                        62856: 58355,
                        62857: 58356,
                        62858: 58357,
                        62859: 58358,
                        62860: 58359,
                        62861: 58360,
                        62862: 58361,
                        62863: 58362,
                        62864: 58363,
                        62865: 58364,
                        62866: 58365,
                        62867: 58366,
                        62868: 58367,
                        62869: 58368,
                        62870: 58369,
                        62871: 58370,
                        62872: 58371,
                        62873: 58372,
                        62874: 58373,
                        62875: 58374,
                        62876: 58375,
                        62877: 58376,
                        62878: 58377,
                        62879: 58378,
                        62880: 58379,
                        62881: 58380,
                        62882: 58381,
                        62883: 58382,
                        62884: 58383,
                        62885: 58384,
                        62886: 58385,
                        62887: 58386,
                        62888: 58387,
                        62889: 58388,
                        62890: 58389,
                        62891: 58390,
                        62892: 58391,
                        62893: 58392,
                        62894: 58393,
                        62895: 58394,
                        62896: 58395,
                        62897: 58396,
                        62898: 58397,
                        62899: 58398,
                        62900: 58399,
                        62901: 58400,
                        62902: 58401,
                        62903: 58402,
                        62904: 58403,
                        62905: 58404,
                        62906: 58405,
                        62907: 58406,
                        62908: 58407,
                        62909: 58408,
                        62910: 58409,
                        62911: 58410,
                        62912: 58411,
                        62913: 58412,
                        62914: 58413,
                        62915: 58414,
                        62916: 58415,
                        62917: 58416,
                        62918: 58417,
                        62919: 58418,
                        62920: 58419,
                        62921: 58420,
                        62922: 58421,
                        62923: 58422,
                        62924: 58423,
                        62925: 58424,
                        62926: 58425,
                        62927: 58426,
                        62928: 58427,
                        62929: 58428,
                        62930: 58429,
                        62931: 58430,
                        62932: 58431,
                        62933: 58432,
                        62934: 58433,
                        62935: 58434,
                        62936: 58435,
                        62937: 58436,
                        62938: 58437,
                        62939: 58438,
                        62940: 58439,
                        62941: 58440,
                        62942: 58441,
                        62943: 58442,
                        62944: 58443,
                        62945: 58444,
                        62946: 58445,
                        62947: 58446,
                        62948: 58447,
                        62949: 58448,
                        62950: 58449,
                        62951: 58450,
                        62952: 58451,
                        62953: 58452,
                        62954: 58453,
                        62955: 58454,
                        62956: 58455,
                        62957: 58456,
                        62958: 58457,
                        62959: 58458,
                        62960: 58459,
                        62961: 58460,
                        62962: 58461,
                        62963: 58462,
                        62964: 58463,
                        62965: 58464,
                        62966: 58465,
                        62967: 58466,
                        62968: 58467,
                        62969: 58468,
                        62970: 58469,
                        62971: 58470,
                        62972: 58471,
                        63040: 58472,
                        63041: 58473,
                        63042: 58474,
                        63043: 58475,
                        63044: 58476,
                        63045: 58477,
                        63046: 58478,
                        63047: 58479,
                        63048: 58480,
                        63049: 58481,
                        63050: 58482,
                        63051: 58483,
                        63052: 58484,
                        63053: 58485,
                        63054: 58486,
                        63055: 58487,
                        63056: 58488,
                        63057: 58489,
                        63058: 58490,
                        63059: 58491,
                        63060: 58492,
                        63061: 58493,
                        63062: 58494,
                        63063: 58495,
                        63064: 58496,
                        63065: 58497,
                        63066: 58498,
                        63067: 58499,
                        63068: 58500,
                        63069: 58501,
                        63070: 58502,
                        63071: 58503,
                        63072: 58504,
                        63073: 58505,
                        63074: 58506,
                        63075: 58507,
                        63076: 58508,
                        63077: 58509,
                        63078: 58510,
                        63079: 58511,
                        63080: 58512,
                        63081: 58513,
                        63082: 58514,
                        63083: 58515,
                        63084: 58516,
                        63085: 58517,
                        63086: 58518,
                        63087: 58519,
                        63088: 58520,
                        63089: 58521,
                        63090: 58522,
                        63091: 58523,
                        63092: 58524,
                        63093: 58525,
                        63094: 58526,
                        63095: 58527,
                        63096: 58528,
                        63097: 58529,
                        63098: 58530,
                        63099: 58531,
                        63100: 58532,
                        63101: 58533,
                        63102: 58534,
                        63104: 58535,
                        63105: 58536,
                        63106: 58537,
                        63107: 58538,
                        63108: 58539,
                        63109: 58540,
                        63110: 58541,
                        63111: 58542,
                        63112: 58543,
                        63113: 58544,
                        63114: 58545,
                        63115: 58546,
                        63116: 58547,
                        63117: 58548,
                        63118: 58549,
                        63119: 58550,
                        63120: 58551,
                        63121: 58552,
                        63122: 58553,
                        63123: 58554,
                        63124: 58555,
                        63125: 58556,
                        63126: 58557,
                        63127: 58558,
                        63128: 58559,
                        63129: 58560,
                        63130: 58561,
                        63131: 58562,
                        63132: 58563,
                        63133: 58564,
                        63134: 58565,
                        63135: 58566,
                        63136: 58567,
                        63137: 58568,
                        63138: 58569,
                        63139: 58570,
                        63140: 58571,
                        63141: 58572,
                        63142: 58573,
                        63143: 58574,
                        63144: 58575,
                        63145: 58576,
                        63146: 58577,
                        63147: 58578,
                        63148: 58579,
                        63149: 58580,
                        63150: 58581,
                        63151: 58582,
                        63152: 58583,
                        63153: 58584,
                        63154: 58585,
                        63155: 58586,
                        63156: 58587,
                        63157: 58588,
                        63158: 58589,
                        63159: 58590,
                        63160: 58591,
                        63161: 58592,
                        63162: 58593,
                        63163: 58594,
                        63164: 58595,
                        63165: 58596,
                        63166: 58597,
                        63167: 58598,
                        63168: 58599,
                        63169: 58600,
                        63170: 58601,
                        63171: 58602,
                        63172: 58603,
                        63173: 58604,
                        63174: 58605,
                        63175: 58606,
                        63176: 58607,
                        63177: 58608,
                        63178: 58609,
                        63179: 58610,
                        63180: 58611,
                        63181: 58612,
                        63182: 58613,
                        63183: 58614,
                        63184: 58615,
                        63185: 58616,
                        63186: 58617,
                        63187: 58618,
                        63188: 58619,
                        63189: 58620,
                        63190: 58621,
                        63191: 58622,
                        63192: 58623,
                        63193: 58624,
                        63194: 58625,
                        63195: 58626,
                        63196: 58627,
                        63197: 58628,
                        63198: 58629,
                        63199: 58630,
                        63200: 58631,
                        63201: 58632,
                        63202: 58633,
                        63203: 58634,
                        63204: 58635,
                        63205: 58636,
                        63206: 58637,
                        63207: 58638,
                        63208: 58639,
                        63209: 58640,
                        63210: 58641,
                        63211: 58642,
                        63212: 58643,
                        63213: 58644,
                        63214: 58645,
                        63215: 58646,
                        63216: 58647,
                        63217: 58648,
                        63218: 58649,
                        63219: 58650,
                        63220: 58651,
                        63221: 58652,
                        63222: 58653,
                        63223: 58654,
                        63224: 58655,
                        63225: 58656,
                        63226: 58657,
                        63227: 58658,
                        63228: 58659,
                        63296: 58660,
                        63297: 58661,
                        63298: 58662,
                        63299: 58663,
                        63300: 58664,
                        63301: 58665,
                        63302: 58666,
                        63303: 58667,
                        63304: 58668,
                        63305: 58669,
                        63306: 58670,
                        63307: 58671,
                        63308: 58672,
                        63309: 58673,
                        63310: 58674,
                        63311: 58675,
                        63312: 58676,
                        63313: 58677,
                        63314: 58678,
                        63315: 58679,
                        63316: 58680,
                        63317: 58681,
                        63318: 58682,
                        63319: 58683,
                        63320: 58684,
                        63321: 58685,
                        63322: 58686,
                        63323: 58687,
                        63324: 58688,
                        63325: 58689,
                        63326: 58690,
                        63327: 58691,
                        63328: 58692,
                        63329: 58693,
                        63330: 58694,
                        63331: 58695,
                        63332: 58696,
                        63333: 58697,
                        63334: 58698,
                        63335: 58699,
                        63336: 58700,
                        63337: 58701,
                        63338: 58702,
                        63339: 58703,
                        63340: 58704,
                        63341: 58705,
                        63342: 58706,
                        63343: 58707,
                        63344: 58708,
                        63345: 58709,
                        63346: 58710,
                        63347: 58711,
                        63348: 58712,
                        63349: 58713,
                        63350: 58714,
                        63351: 58715,
                        63352: 58716,
                        63353: 58717,
                        63354: 58718,
                        63355: 58719,
                        63356: 58720,
                        63357: 58721,
                        63358: 58722,
                        63360: 58723,
                        63361: 58724,
                        63362: 58725,
                        63363: 58726,
                        63364: 58727,
                        63365: 58728,
                        63366: 58729,
                        63367: 58730,
                        63368: 58731,
                        63369: 58732,
                        63370: 58733,
                        63371: 58734,
                        63372: 58735,
                        63373: 58736,
                        63374: 58737,
                        63375: 58738,
                        63376: 58739,
                        63377: 58740,
                        63378: 58741,
                        63379: 58742,
                        63380: 58743,
                        63381: 58744,
                        63382: 58745,
                        63383: 58746,
                        63384: 58747,
                        63385: 58748,
                        63386: 58749,
                        63387: 58750,
                        63388: 58751,
                        63389: 58752,
                        63390: 58753,
                        63391: 58754,
                        63392: 58755,
                        63393: 58756,
                        63394: 58757,
                        63395: 58758,
                        63396: 58759,
                        63397: 58760,
                        63398: 58761,
                        63399: 58762,
                        63400: 58763,
                        63401: 58764,
                        63402: 58765,
                        63403: 58766,
                        63404: 58767,
                        63405: 58768,
                        63406: 58769,
                        63407: 58770,
                        63408: 58771,
                        63409: 58772,
                        63410: 58773,
                        63411: 58774,
                        63412: 58775,
                        63413: 58776,
                        63414: 58777,
                        63415: 58778,
                        63416: 58779,
                        63417: 58780,
                        63418: 58781,
                        63419: 58782,
                        63420: 58783,
                        63421: 58784,
                        63422: 58785,
                        63423: 58786,
                        63424: 58787,
                        63425: 58788,
                        63426: 58789,
                        63427: 58790,
                        63428: 58791,
                        63429: 58792,
                        63430: 58793,
                        63431: 58794,
                        63432: 58795,
                        63433: 58796,
                        63434: 58797,
                        63435: 58798,
                        63436: 58799,
                        63437: 58800,
                        63438: 58801,
                        63439: 58802,
                        63440: 58803,
                        63441: 58804,
                        63442: 58805,
                        63443: 58806,
                        63444: 58807,
                        63445: 58808,
                        63446: 58809,
                        63447: 58810,
                        63448: 58811,
                        63449: 58812,
                        63450: 58813,
                        63451: 58814,
                        63452: 58815,
                        63453: 58816,
                        63454: 58817,
                        63455: 58818,
                        63456: 58819,
                        63457: 58820,
                        63458: 58821,
                        63459: 58822,
                        63460: 58823,
                        63461: 58824,
                        63462: 58825,
                        63463: 58826,
                        63464: 58827,
                        63465: 58828,
                        63466: 58829,
                        63467: 58830,
                        63468: 58831,
                        63469: 58832,
                        63470: 58833,
                        63471: 58834,
                        63472: 58835,
                        63473: 58836,
                        63474: 58837,
                        63475: 58838,
                        63476: 58839,
                        63477: 58840,
                        63478: 58841,
                        63479: 58842,
                        63480: 58843,
                        63481: 58844,
                        63482: 58845,
                        63483: 58846,
                        63484: 58847,
                        63552: 58848,
                        63553: 58849,
                        63554: 58850,
                        63555: 58851,
                        63556: 58852,
                        63557: 58853,
                        63558: 58854,
                        63559: 58855,
                        63560: 58856,
                        63561: 58857,
                        63562: 58858,
                        63563: 58859,
                        63564: 58860,
                        63565: 58861,
                        63566: 58862,
                        63567: 58863,
                        63568: 58864,
                        63569: 58865,
                        63570: 58866,
                        63571: 58867,
                        63572: 58868,
                        63573: 58869,
                        63574: 58870,
                        63575: 58871,
                        63576: 58872,
                        63577: 58873,
                        63578: 58874,
                        63579: 58875,
                        63580: 58876,
                        63581: 58877,
                        63582: 58878,
                        63583: 58879,
                        63584: 58880,
                        63585: 58881,
                        63586: 58882,
                        63587: 58883,
                        63588: 58884,
                        63589: 58885,
                        63590: 58886,
                        63591: 58887,
                        63592: 58888,
                        63593: 58889,
                        63594: 58890,
                        63595: 58891,
                        63596: 58892,
                        63597: 58893,
                        63598: 58894,
                        63599: 58895,
                        63600: 58896,
                        63601: 58897,
                        63602: 58898,
                        63603: 58899,
                        63604: 58900,
                        63605: 58901,
                        63606: 58902,
                        63607: 58903,
                        63608: 58904,
                        63609: 58905,
                        63610: 58906,
                        63611: 58907,
                        63612: 58908,
                        63613: 58909,
                        63614: 58910,
                        63616: 58911,
                        63617: 58912,
                        63618: 58913,
                        63619: 58914,
                        63620: 58915,
                        63621: 58916,
                        63622: 58917,
                        63623: 58918,
                        63624: 58919,
                        63625: 58920,
                        63626: 58921,
                        63627: 58922,
                        63628: 58923,
                        63629: 58924,
                        63630: 58925,
                        63631: 58926,
                        63632: 58927,
                        63633: 58928,
                        63634: 58929,
                        63635: 58930,
                        63636: 58931,
                        63637: 58932,
                        63638: 58933,
                        63639: 58934,
                        63640: 58935,
                        63641: 58936,
                        63642: 58937,
                        63643: 58938,
                        63644: 58939,
                        63645: 58940,
                        63646: 58941,
                        63647: 58942,
                        63648: 58943,
                        63649: 58944,
                        63650: 58945,
                        63651: 58946,
                        63652: 58947,
                        63653: 58948,
                        63654: 58949,
                        63655: 58950,
                        63656: 58951,
                        63657: 58952,
                        63658: 58953,
                        63659: 58954,
                        63660: 58955,
                        63661: 58956,
                        63662: 58957,
                        63663: 58958,
                        63664: 58959,
                        63665: 58960,
                        63666: 58961,
                        63667: 58962,
                        63668: 58963,
                        63669: 58964,
                        63670: 58965,
                        63671: 58966,
                        63672: 58967,
                        63673: 58968,
                        63674: 58969,
                        63675: 58970,
                        63676: 58971,
                        63677: 58972,
                        63678: 58973,
                        63679: 58974,
                        63680: 58975,
                        63681: 58976,
                        63682: 58977,
                        63683: 58978,
                        63684: 58979,
                        63685: 58980,
                        63686: 58981,
                        63687: 58982,
                        63688: 58983,
                        63689: 58984,
                        63690: 58985,
                        63691: 58986,
                        63692: 58987,
                        63693: 58988,
                        63694: 58989,
                        63695: 58990,
                        63696: 58991,
                        63697: 58992,
                        63698: 58993,
                        63699: 58994,
                        63700: 58995,
                        63701: 58996,
                        63702: 58997,
                        63703: 58998,
                        63704: 58999,
                        63705: 59e3,
                        63706: 59001,
                        63707: 59002,
                        63708: 59003,
                        63709: 59004,
                        63710: 59005,
                        63711: 59006,
                        63712: 59007,
                        63713: 59008,
                        63714: 59009,
                        63715: 59010,
                        63716: 59011,
                        63717: 59012,
                        63718: 59013,
                        63719: 59014,
                        63720: 59015,
                        63721: 59016,
                        63722: 59017,
                        63723: 59018,
                        63724: 59019,
                        63725: 59020,
                        63726: 59021,
                        63727: 59022,
                        63728: 59023,
                        63729: 59024,
                        63730: 59025,
                        63731: 59026,
                        63732: 59027,
                        63733: 59028,
                        63734: 59029,
                        63735: 59030,
                        63736: 59031,
                        63737: 59032,
                        63738: 59033,
                        63739: 59034,
                        63740: 59035,
                        64064: 8560,
                        64065: 8561,
                        64066: 8562,
                        64067: 8563,
                        64068: 8564,
                        64069: 8565,
                        64070: 8566,
                        64071: 8567,
                        64072: 8568,
                        64073: 8569,
                        64074: 8544,
                        64075: 8545,
                        64076: 8546,
                        64077: 8547,
                        64078: 8548,
                        64079: 8549,
                        64080: 8550,
                        64081: 8551,
                        64082: 8552,
                        64083: 8553,
                        64084: 65506,
                        64085: 65508,
                        64086: 65287,
                        64087: 65282,
                        64088: 12849,
                        64089: 8470,
                        64090: 8481,
                        64091: 8757,
                        64092: 32394,
                        64093: 35100,
                        64094: 37704,
                        64095: 37512,
                        64096: 34012,
                        64097: 20425,
                        64098: 28859,
                        64099: 26161,
                        64100: 26824,
                        64101: 37625,
                        64102: 26363,
                        64103: 24389,
                        64104: 20008,
                        64105: 20193,
                        64106: 20220,
                        64107: 20224,
                        64108: 20227,
                        64109: 20281,
                        64110: 20310,
                        64111: 20370,
                        64112: 20362,
                        64113: 20378,
                        64114: 20372,
                        64115: 20429,
                        64116: 20544,
                        64117: 20514,
                        64118: 20479,
                        64119: 20510,
                        64120: 20550,
                        64121: 20592,
                        64122: 20546,
                        64123: 20628,
                        64124: 20724,
                        64125: 20696,
                        64126: 20810,
                        64128: 20836,
                        64129: 20893,
                        64130: 20926,
                        64131: 20972,
                        64132: 21013,
                        64133: 21148,
                        64134: 21158,
                        64135: 21184,
                        64136: 21211,
                        64137: 21248,
                        64138: 21255,
                        64139: 21284,
                        64140: 21362,
                        64141: 21395,
                        64142: 21426,
                        64143: 21469,
                        64144: 64014,
                        64145: 21660,
                        64146: 21642,
                        64147: 21673,
                        64148: 21759,
                        64149: 21894,
                        64150: 22361,
                        64151: 22373,
                        64152: 22444,
                        64153: 22472,
                        64154: 22471,
                        64155: 64015,
                        64156: 64016,
                        64157: 22686,
                        64158: 22706,
                        64159: 22795,
                        64160: 22867,
                        64161: 22875,
                        64162: 22877,
                        64163: 22883,
                        64164: 22948,
                        64165: 22970,
                        64166: 23382,
                        64167: 23488,
                        64168: 29999,
                        64169: 23512,
                        64170: 23532,
                        64171: 23582,
                        64172: 23718,
                        64173: 23738,
                        64174: 23797,
                        64175: 23847,
                        64176: 23891,
                        64177: 64017,
                        64178: 23874,
                        64179: 23917,
                        64180: 23992,
                        64181: 23993,
                        64182: 24016,
                        64183: 24353,
                        64184: 24372,
                        64185: 24423,
                        64186: 24503,
                        64187: 24542,
                        64188: 24669,
                        64189: 24709,
                        64190: 24714,
                        64191: 24798,
                        64192: 24789,
                        64193: 24864,
                        64194: 24818,
                        64195: 24849,
                        64196: 24887,
                        64197: 24880,
                        64198: 24984,
                        64199: 25107,
                        64200: 25254,
                        64201: 25589,
                        64202: 25696,
                        64203: 25757,
                        64204: 25806,
                        64205: 25934,
                        64206: 26112,
                        64207: 26133,
                        64208: 26171,
                        64209: 26121,
                        64210: 26158,
                        64211: 26142,
                        64212: 26148,
                        64213: 26213,
                        64214: 26199,
                        64215: 26201,
                        64216: 64018,
                        64217: 26227,
                        64218: 26265,
                        64219: 26272,
                        64220: 26290,
                        64221: 26303,
                        64222: 26362,
                        64223: 26382,
                        64224: 63785,
                        64225: 26470,
                        64226: 26555,
                        64227: 26706,
                        64228: 26560,
                        64229: 26625,
                        64230: 26692,
                        64231: 26831,
                        64232: 64019,
                        64233: 26984,
                        64234: 64020,
                        64235: 27032,
                        64236: 27106,
                        64237: 27184,
                        64238: 27243,
                        64239: 27206,
                        64240: 27251,
                        64241: 27262,
                        64242: 27362,
                        64243: 27364,
                        64244: 27606,
                        64245: 27711,
                        64246: 27740,
                        64247: 27782,
                        64248: 27759,
                        64249: 27866,
                        64250: 27908,
                        64251: 28039,
                        64252: 28015,
                        64320: 28054,
                        64321: 28076,
                        64322: 28111,
                        64323: 28152,
                        64324: 28146,
                        64325: 28156,
                        64326: 28217,
                        64327: 28252,
                        64328: 28199,
                        64329: 28220,
                        64330: 28351,
                        64331: 28552,
                        64332: 28597,
                        64333: 28661,
                        64334: 28677,
                        64335: 28679,
                        64336: 28712,
                        64337: 28805,
                        64338: 28843,
                        64339: 28943,
                        64340: 28932,
                        64341: 29020,
                        64342: 28998,
                        64343: 28999,
                        64344: 64021,
                        64345: 29121,
                        64346: 29182,
                        64347: 29361,
                        64348: 29374,
                        64349: 29476,
                        64350: 64022,
                        64351: 29559,
                        64352: 29629,
                        64353: 29641,
                        64354: 29654,
                        64355: 29667,
                        64356: 29650,
                        64357: 29703,
                        64358: 29685,
                        64359: 29734,
                        64360: 29738,
                        64361: 29737,
                        64362: 29742,
                        64363: 29794,
                        64364: 29833,
                        64365: 29855,
                        64366: 29953,
                        64367: 30063,
                        64368: 30338,
                        64369: 30364,
                        64370: 30366,
                        64371: 30363,
                        64372: 30374,
                        64373: 64023,
                        64374: 30534,
                        64375: 21167,
                        64376: 30753,
                        64377: 30798,
                        64378: 30820,
                        64379: 30842,
                        64380: 31024,
                        64381: 64024,
                        64382: 64025,
                        64384: 64026,
                        64385: 31124,
                        64386: 64027,
                        64387: 31131,
                        64388: 31441,
                        64389: 31463,
                        64390: 64028,
                        64391: 31467,
                        64392: 31646,
                        64393: 64029,
                        64394: 32072,
                        64395: 32092,
                        64396: 32183,
                        64397: 32160,
                        64398: 32214,
                        64399: 32338,
                        64400: 32583,
                        64401: 32673,
                        64402: 64030,
                        64403: 33537,
                        64404: 33634,
                        64405: 33663,
                        64406: 33735,
                        64407: 33782,
                        64408: 33864,
                        64409: 33972,
                        64410: 34131,
                        64411: 34137,
                        64412: 34155,
                        64413: 64031,
                        64414: 34224,
                        64415: 64032,
                        64416: 64033,
                        64417: 34823,
                        64418: 35061,
                        64419: 35346,
                        64420: 35383,
                        64421: 35449,
                        64422: 35495,
                        64423: 35518,
                        64424: 35551,
                        64425: 64034,
                        64426: 35574,
                        64427: 35667,
                        64428: 35711,
                        64429: 36080,
                        64430: 36084,
                        64431: 36114,
                        64432: 36214,
                        64433: 64035,
                        64434: 36559,
                        64435: 64036,
                        64436: 64037,
                        64437: 36967,
                        64438: 37086,
                        64439: 64038,
                        64440: 37141,
                        64441: 37159,
                        64442: 37338,
                        64443: 37335,
                        64444: 37342,
                        64445: 37357,
                        64446: 37358,
                        64447: 37348,
                        64448: 37349,
                        64449: 37382,
                        64450: 37392,
                        64451: 37386,
                        64452: 37434,
                        64453: 37440,
                        64454: 37436,
                        64455: 37454,
                        64456: 37465,
                        64457: 37457,
                        64458: 37433,
                        64459: 37479,
                        64460: 37543,
                        64461: 37495,
                        64462: 37496,
                        64463: 37607,
                        64464: 37591,
                        64465: 37593,
                        64466: 37584,
                        64467: 64039,
                        64468: 37589,
                        64469: 37600,
                        64470: 37587,
                        64471: 37669,
                        64472: 37665,
                        64473: 37627,
                        64474: 64040,
                        64475: 37662,
                        64476: 37631,
                        64477: 37661,
                        64478: 37634,
                        64479: 37744,
                        64480: 37719,
                        64481: 37796,
                        64482: 37830,
                        64483: 37854,
                        64484: 37880,
                        64485: 37937,
                        64486: 37957,
                        64487: 37960,
                        64488: 38290,
                        64489: 63964,
                        64490: 64041,
                        64491: 38557,
                        64492: 38575,
                        64493: 38707,
                        64494: 38715,
                        64495: 38723,
                        64496: 38733,
                        64497: 38735,
                        64498: 38737,
                        64499: 38741,
                        64500: 38999,
                        64501: 39013,
                        64502: 64042,
                        64503: 64043,
                        64504: 39207,
                        64505: 64044,
                        64506: 39326,
                        64507: 39502,
                        64508: 39641,
                        64576: 39644,
                        64577: 39797,
                        64578: 39794,
                        64579: 39823,
                        64580: 39857,
                        64581: 39867,
                        64582: 39936,
                        64583: 40304,
                        64584: 40299,
                        64585: 64045,
                        64586: 40473,
                        64587: 40657
                    }, o.prototype = {
                        constructor: o,
                        getInt8: function() {
                            var t = this.dv.getInt8(this.offset);
                            return this.offset += 1, t
                        },
                        getInt8Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getInt8());
                            return e
                        },
                        getUint8: function() {
                            var t = this.dv.getUint8(this.offset);
                            return this.offset += 1, t
                        },
                        getUint8Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getUint8());
                            return e
                        },
                        getInt16: function() {
                            var t = this.dv.getInt16(this.offset, this.littleEndian);
                            return this.offset += 2, t
                        },
                        getInt16Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getInt16());
                            return e
                        },
                        getUint16: function() {
                            var t = this.dv.getUint16(this.offset, this.littleEndian);
                            return this.offset += 2, t
                        },
                        getUint16Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getUint16());
                            return e
                        },
                        getInt32: function() {
                            var t = this.dv.getInt32(this.offset, this.littleEndian);
                            return this.offset += 4, t
                        },
                        getInt32Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getInt32());
                            return e
                        },
                        getUint32: function() {
                            var t = this.dv.getUint32(this.offset, this.littleEndian);
                            return this.offset += 4, t
                        },
                        getUint32Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getUint32());
                            return e
                        },
                        getFloat32: function() {
                            var t = this.dv.getFloat32(this.offset, this.littleEndian);
                            return this.offset += 4, t
                        },
                        getFloat32Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getFloat32());
                            return e
                        },
                        getFloat64: function() {
                            var t = this.dv.getFloat64(this.offset, this.littleEndian);
                            return this.offset += 8, t
                        },
                        getFloat64Array: function(t) {
                            for (var e = [], i = 0; i < t; i++) e.push(this.getFloat64());
                            return e
                        },
                        getIndex: function(t, e) {
                            switch (t) {
                                case 1:
                                    return !0 === e ? this.getUint8() : this.getInt8();
                                case 2:
                                    return !0 === e ? this.getUint16() : this.getInt16();
                                case 4:
                                    return this.getInt32();
                                default:
                                    throw "unknown number type " + t + " exception."
                            }
                        },
                        getIndexArray: function(t, e, i) {
                            for (var n = [], r = 0; r < e; r++) n.push(this.getIndex(t, i));
                            return n
                        },
                        getChars: function(t) {
                            for (var e = ""; t > 0;) {
                                var i = this.getUint8();
                                if (t--, 0 === i) break;
                                e += String.fromCharCode(i)
                            }
                            for (; t > 0;) this.getUint8(), t--;
                            return e
                        },
                        getSjisStringsAsUnicode: function(t) {
                            for (var e = []; t > 0;) {
                                var i = this.getUint8();
                                if (t--, 0 === i) break;
                                e.push(i)
                            }
                            for (; t > 0;) this.getUint8(), t--;
                            return this.encoder.s2u(new Uint8Array(e))
                        },
                        getUnicodeStrings: function(t) {
                            for (var e = ""; t > 0;) {
                                var i = this.getUint16();
                                if (t -= 2, 0 === i) break;
                                e += String.fromCharCode(i)
                            }
                            for (; t > 0;) this.getUint8(), t--;
                            return e
                        },
                        getTextBuffer: function() {
                            var t = this.getUint32();
                            return this.getUnicodeStrings(t)
                        }
                    }, l.prototype = {
                        constructor: l,
                        leftToRightVector3: function(t) {
                            t[2] = -t[2]
                        },
                        leftToRightQuaternion: function(t) {
                            t[0] = -t[0], t[1] = -t[1]
                        },
                        leftToRightEuler: function(t) {
                            t[0] = -t[0], t[1] = -t[1]
                        },
                        leftToRightIndexOrder: function(t) {
                            var e = t[2];
                            t[2] = t[0], t[0] = e
                        },
                        leftToRightVector3Range: function(t, e) {
                            var i = -e[2];
                            e[2] = -t[2], t[2] = i
                        },
                        leftToRightEulerRange: function(t, e) {
                            var i = -e[0],
                                n = -e[1];
                            e[0] = -t[0], e[1] = -t[1], t[0] = i, t[1] = n
                        }
                    }, h.prototype.parsePmd = function(t, e) {
                        var i, n = {},
                            r = new o(t);
                        return n.metadata = {}, n.metadata.format = "pmd", n.metadata.coordinateSystem = "left",
                            function() {
                                var t = n.metadata;
                                if (t.magic = r.getChars(3), "Pmd" !== t.magic) throw "PMD file magic is not Pmd, but " + t.magic;
                                t.version = r.getFloat32(), t.modelName = r.getSjisStringsAsUnicode(20), t.comment = r.getSjisStringsAsUnicode(256)
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.vertexCount = r.getUint32(), n.vertices = [];
                                for (var i = 0; i < e.vertexCount; i++) n.vertices.push((t = void 0, (t = {}).position = r.getFloat32Array(3), t.normal = r.getFloat32Array(3), t.uv = r.getFloat32Array(2), t.skinIndices = r.getUint16Array(2), t.skinWeights = [r.getUint8() / 100], t.skinWeights.push(1 - t.skinWeights[0]), t.edgeFlag = r.getUint8(), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.faceCount = r.getUint32() / 3, n.faces = [];
                                for (var i = 0; i < e.faceCount; i++) n.faces.push((t = void 0, (t = {}).indices = r.getUint16Array(3), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.materialCount = r.getUint32(), n.materials = [];
                                for (var i = 0; i < e.materialCount; i++) n.materials.push((t = void 0, (t = {}).diffuse = r.getFloat32Array(4), t.shininess = r.getFloat32(), t.specular = r.getFloat32Array(3), t.ambient = r.getFloat32Array(3), t.toonIndex = r.getInt8(), t.edgeFlag = r.getUint8(), t.faceCount = r.getUint32() / 3, t.fileName = r.getSjisStringsAsUnicode(20), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.boneCount = r.getUint16(), n.bones = [];
                                for (var i = 0; i < e.boneCount; i++) n.bones.push((t = void 0, (t = {}).name = r.getSjisStringsAsUnicode(20), t.parentIndex = r.getInt16(), t.tailIndex = r.getInt16(), t.type = r.getUint8(), t.ikIndex = r.getInt16(), t.position = r.getFloat32Array(3), t))
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        t.target = r.getUint16(), t.effector = r.getUint16(), t.linkCount = r.getUint8(), t.iteration = r.getUint16(), t.maxAngle = r.getFloat32(), t.links = [];
                                        for (var e = 0; e < t.linkCount; e++) {
                                            var i = {};
                                            i.index = r.getUint16(), t.links.push(i)
                                        }
                                        return t
                                    },
                                    e = n.metadata;
                                e.ikCount = r.getUint16(), n.iks = [];
                                for (var i = 0; i < e.ikCount; i++) n.iks.push(t())
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        t.name = r.getSjisStringsAsUnicode(20), t.elementCount = r.getUint32(), t.type = r.getUint8(), t.elements = [];
                                        for (var e = 0; e < t.elementCount; e++) t.elements.push({
                                            index: r.getUint32(),
                                            position: r.getFloat32Array(3)
                                        });
                                        return t
                                    },
                                    e = n.metadata;
                                e.morphCount = r.getUint16(), n.morphs = [];
                                for (var i = 0; i < e.morphCount; i++) n.morphs.push(t())
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.morphFrameCount = r.getUint8(), n.morphFrames = [];
                                for (var i = 0; i < e.morphFrameCount; i++) n.morphFrames.push((t = void 0, (t = {}).index = r.getUint16(), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.boneFrameNameCount = r.getUint8(), n.boneFrameNames = [];
                                for (var i = 0; i < e.boneFrameNameCount; i++) n.boneFrameNames.push((t = void 0, (t = {}).name = r.getSjisStringsAsUnicode(50), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.boneFrameCount = r.getUint32(), n.boneFrames = [];
                                for (var i = 0; i < e.boneFrameCount; i++) n.boneFrames.push((t = void 0, (t = {}).boneIndex = r.getInt16(), t.frameIndex = r.getUint8(), t))
                            }(), (i = n.metadata).englishCompatibility = r.getUint8(), i.englishCompatibility > 0 && (i.englishModelName = r.getSjisStringsAsUnicode(20), i.englishComment = r.getSjisStringsAsUnicode(256)),
                            function() {
                                var t = n.metadata;
                                if (0 !== t.englishCompatibility) {
                                    n.englishBoneNames = [];
                                    for (var e = 0; e < t.boneCount; e++) n.englishBoneNames.push((i = void 0, (i = {}).name = r.getSjisStringsAsUnicode(20), i));
                                    var i
                                }
                            }(),
                            function() {
                                var t = n.metadata;
                                if (0 !== t.englishCompatibility) {
                                    n.englishMorphNames = [];
                                    for (var e = 0; e < t.morphCount - 1; e++) n.englishMorphNames.push((i = void 0, (i = {}).name = r.getSjisStringsAsUnicode(20), i));
                                    var i
                                }
                            }(),
                            function() {
                                var t = n.metadata;
                                if (0 !== t.englishCompatibility) {
                                    n.englishBoneFrameNames = [];
                                    for (var e = 0; e < t.boneFrameNameCount; e++) n.englishBoneFrameNames.push((i = void 0, (i = {}).name = r.getSjisStringsAsUnicode(50), i));
                                    var i
                                }
                            }(),
                            function() {
                                var t;
                                n.toonTextures = [];
                                for (var e = 0; e < 10; e++) n.toonTextures.push((t = void 0, (t = {}).fileName = r.getSjisStringsAsUnicode(100), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.rigidBodyCount = r.getUint32(), n.rigidBodies = [];
                                for (var i = 0; i < e.rigidBodyCount; i++) n.rigidBodies.push((t = void 0, (t = {}).name = r.getSjisStringsAsUnicode(20), t.boneIndex = r.getInt16(), t.groupIndex = r.getUint8(), t.groupTarget = r.getUint16(), t.shapeType = r.getUint8(), t.width = r.getFloat32(), t.height = r.getFloat32(), t.depth = r.getFloat32(), t.position = r.getFloat32Array(3), t.rotation = r.getFloat32Array(3), t.weight = r.getFloat32(), t.positionDamping = r.getFloat32(), t.rotationDamping = r.getFloat32(), t.restitution = r.getFloat32(), t.friction = r.getFloat32(), t.type = r.getUint8(), t))
                            }(),
                            function() {
                                var t, e = n.metadata;
                                e.constraintCount = r.getUint32(), n.constraints = [];
                                for (var i = 0; i < e.constraintCount; i++) n.constraints.push((t = void 0, (t = {}).name = r.getSjisStringsAsUnicode(20), t.rigidBodyIndex1 = r.getUint32(), t.rigidBodyIndex2 = r.getUint32(), t.position = r.getFloat32Array(3), t.rotation = r.getFloat32Array(3), t.translationLimitation1 = r.getFloat32Array(3), t.translationLimitation2 = r.getFloat32Array(3), t.rotationLimitation1 = r.getFloat32Array(3), t.rotationLimitation2 = r.getFloat32Array(3), t.springPosition = r.getFloat32Array(3), t.springRotation = r.getFloat32Array(3), t))
                            }(), !0 === e && this.leftToRightModel(n), n
                    }, h.prototype.parsePmx = function(t, e) {
                        var i = {},
                            n = new o(t);
                        return i.metadata = {}, i.metadata.format = "pmx", i.metadata.coordinateSystem = "left",
                            function() {
                                var t = i.metadata;
                                if (t.magic = n.getChars(4), "PMX " !== t.magic) throw "PMX file magic is not PMX , but " + t.magic;
                                if (t.version = n.getFloat32(), 2 !== t.version && 2.1 !== t.version) throw "PMX version " + t.version + " is not supported.";
                                t.headerSize = n.getUint8(), t.encoding = n.getUint8(), t.additionalUvNum = n.getUint8(), t.vertexIndexSize = n.getUint8(), t.textureIndexSize = n.getUint8(), t.materialIndexSize = n.getUint8(), t.boneIndexSize = n.getUint8(), t.morphIndexSize = n.getUint8(), t.rigidBodyIndexSize = n.getUint8(), t.modelName = n.getTextBuffer(), t.englishModelName = n.getTextBuffer(), t.comment = n.getTextBuffer(), t.englishComment = n.getTextBuffer()
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        t.position = n.getFloat32Array(3), t.normal = n.getFloat32Array(3), t.uv = n.getFloat32Array(2), t.auvs = [];
                                        for (var r = 0; r < i.metadata.additionalUvNum; r++) t.auvs.push(n.getFloat32Array(4));
                                        t.type = n.getUint8();
                                        var s = e.boneIndexSize;
                                        if (0 === t.type) t.skinIndices = n.getIndexArray(s, 1), t.skinWeights = [1];
                                        else if (1 === t.type) t.skinIndices = n.getIndexArray(s, 2), t.skinWeights = n.getFloat32Array(1), t.skinWeights.push(1 - t.skinWeights[0]);
                                        else if (2 === t.type) t.skinIndices = n.getIndexArray(s, 4), t.skinWeights = n.getFloat32Array(4);
                                        else {
                                            if (3 !== t.type) throw "unsupport bone type " + t.type + " exception.";
                                            t.skinIndices = n.getIndexArray(s, 2), t.skinWeights = n.getFloat32Array(1), t.skinWeights.push(1 - t.skinWeights[0]), t.skinC = n.getFloat32Array(3), t.skinR0 = n.getFloat32Array(3), t.skinR1 = n.getFloat32Array(3), t.type = 1
                                        }
                                        return t.edgeRatio = n.getFloat32(), t
                                    },
                                    e = i.metadata;
                                e.vertexCount = n.getUint32(), i.vertices = [];
                                for (var r = 0; r < e.vertexCount; r++) i.vertices.push(t())
                            }(),
                            function() {
                                var t, e = i.metadata;
                                e.faceCount = n.getUint32() / 3, i.faces = [];
                                for (var r = 0; r < e.faceCount; r++) i.faces.push((t = void 0, (t = {}).indices = n.getIndexArray(e.vertexIndexSize, 3, !0), t))
                            }(),
                            function() {
                                var t = i.metadata;
                                t.textureCount = n.getUint32(), i.textures = [];
                                for (var e = 0; e < t.textureCount; e++) i.textures.push(n.getTextBuffer())
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        if (t.name = n.getTextBuffer(), t.englishName = n.getTextBuffer(), t.diffuse = n.getFloat32Array(4), t.specular = n.getFloat32Array(3), t.shininess = n.getFloat32(), t.ambient = n.getFloat32Array(3), t.flag = n.getUint8(), t.edgeColor = n.getFloat32Array(4), t.edgeSize = n.getFloat32(), t.textureIndex = n.getIndex(i.metadata.textureIndexSize), t.envTextureIndex = n.getIndex(i.metadata.textureIndexSize), t.envFlag = n.getUint8(), t.toonFlag = n.getUint8(), 0 === t.toonFlag) t.toonIndex = n.getIndex(i.metadata.textureIndexSize);
                                        else {
                                            if (1 !== t.toonFlag) throw "unknown toon flag " + t.toonFlag + " exception.";
                                            t.toonIndex = n.getInt8()
                                        }
                                        return t.comment = n.getTextBuffer(), t.faceCount = n.getUint32() / 3, t
                                    },
                                    e = i.metadata;
                                e.materialCount = n.getUint32(), i.materials = [];
                                for (var r = 0; r < e.materialCount; r++) i.materials.push(t())
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        if (t.name = n.getTextBuffer(), t.englishName = n.getTextBuffer(), t.position = n.getFloat32Array(3), t.parentIndex = n.getIndex(i.metadata.boneIndexSize), t.transformationClass = n.getUint32(), t.flag = n.getUint16(), 1 & t.flag ? t.connectIndex = n.getIndex(i.metadata.boneIndexSize) : t.offsetPosition = n.getFloat32Array(3), 256 & t.flag || 512 & t.flag) {
                                            var e = {};
                                            e.isLocal = !!(128 & t.flag), e.affectRotation = !!(256 & t.flag), e.affectPosition = !!(512 & t.flag), e.parentIndex = n.getIndex(i.metadata.boneIndexSize), e.ratio = n.getFloat32(), t.grant = e
                                        }
                                        if (1024 & t.flag && (t.fixAxis = n.getFloat32Array(3)), 2048 & t.flag && (t.localXVector = n.getFloat32Array(3), t.localZVector = n.getFloat32Array(3)), 8192 & t.flag && (t.key = n.getUint32()), 32 & t.flag) {
                                            var r = {};
                                            r.effector = n.getIndex(i.metadata.boneIndexSize), r.target = null, r.iteration = n.getUint32(), r.maxAngle = n.getFloat32(), r.linkCount = n.getUint32(), r.links = [];
                                            for (var s = 0; s < r.linkCount; s++) {
                                                var a = {};
                                                a.index = n.getIndex(i.metadata.boneIndexSize), a.angleLimitation = n.getUint8(), 1 === a.angleLimitation && (a.lowerLimitationAngle = n.getFloat32Array(3), a.upperLimitationAngle = n.getFloat32Array(3)), r.links.push(a)
                                            }
                                            t.ik = r
                                        }
                                        return t
                                    },
                                    e = i.metadata;
                                e.boneCount = n.getUint32(), i.bones = [];
                                for (var r = 0; r < e.boneCount; r++) i.bones.push(t())
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        t.name = n.getTextBuffer(), t.englishName = n.getTextBuffer(), t.panel = n.getUint8(), t.type = n.getUint8(), t.elementCount = n.getUint32(), t.elements = [];
                                        for (var e = 0; e < t.elementCount; e++)
                                            if (0 === t.type)(r = {}).index = n.getIndex(i.metadata.morphIndexSize), r.ratio = n.getFloat32(), t.elements.push(r);
                                            else if (1 === t.type)(r = {}).index = n.getIndex(i.metadata.vertexIndexSize, !0), r.position = n.getFloat32Array(3), t.elements.push(r);
                                        else if (2 === t.type)(r = {}).index = n.getIndex(i.metadata.boneIndexSize), r.position = n.getFloat32Array(3), r.rotation = n.getFloat32Array(4), t.elements.push(r);
                                        else if (3 === t.type)(r = {}).index = n.getIndex(i.metadata.vertexIndexSize, !0), r.uv = n.getFloat32Array(4), t.elements.push(r);
                                        else if (4 === t.type);
                                        else if (5 === t.type);
                                        else if (6 === t.type);
                                        else if (7 === t.type);
                                        else if (8 === t.type) {
                                            var r;
                                            (r = {}).index = n.getIndex(i.metadata.materialIndexSize), r.type = n.getUint8(), r.diffuse = n.getFloat32Array(4), r.specular = n.getFloat32Array(3), r.shininess = n.getFloat32(), r.ambient = n.getFloat32Array(3), r.edgeColor = n.getFloat32Array(4), r.edgeSize = n.getFloat32(), r.textureColor = n.getFloat32Array(4), r.sphereTextureColor = n.getFloat32Array(4), r.toonColor = n.getFloat32Array(4), t.elements.push(r)
                                        }
                                        return t
                                    },
                                    e = i.metadata;
                                e.morphCount = n.getUint32(), i.morphs = [];
                                for (var r = 0; r < e.morphCount; r++) i.morphs.push(t())
                            }(),
                            function() {
                                var t = function() {
                                        var t = {};
                                        t.name = n.getTextBuffer(), t.englishName = n.getTextBuffer(), t.type = n.getUint8(), t.elementCount = n.getUint32(), t.elements = [];
                                        for (var e = 0; e < t.elementCount; e++) {
                                            var r = {};
                                            r.target = n.getUint8(), r.index = 0 === r.target ? n.getIndex(i.metadata.boneIndexSize) : n.getIndex(i.metadata.morphIndexSize), t.elements.push(r)
                                        }
                                        return t
                                    },
                                    e = i.metadata;
                                e.frameCount = n.getUint32(), i.frames = [];
                                for (var r = 0; r < e.frameCount; r++) i.frames.push(t())
                            }(),
                            function() {
                                var t, e = i.metadata;
                                e.rigidBodyCount = n.getUint32(), i.rigidBodies = [];
                                for (var r = 0; r < e.rigidBodyCount; r++) i.rigidBodies.push((t = void 0, (t = {}).name = n.getTextBuffer(), t.englishName = n.getTextBuffer(), t.boneIndex = n.getIndex(i.metadata.boneIndexSize), t.groupIndex = n.getUint8(), t.groupTarget = n.getUint16(), t.shapeType = n.getUint8(), t.width = n.getFloat32(), t.height = n.getFloat32(), t.depth = n.getFloat32(), t.position = n.getFloat32Array(3), t.rotation = n.getFloat32Array(3), t.weight = n.getFloat32(), t.positionDamping = n.getFloat32(), t.rotationDamping = n.getFloat32(), t.restitution = n.getFloat32(), t.friction = n.getFloat32(), t.type = n.getUint8(), t))
                            }(),
                            function() {
                                var t, e = i.metadata;
                                e.constraintCount = n.getUint32(), i.constraints = [];
                                for (var r = 0; r < e.constraintCount; r++) i.constraints.push((t = void 0, (t = {}).name = n.getTextBuffer(), t.englishName = n.getTextBuffer(), t.type = n.getUint8(), t.rigidBodyIndex1 = n.getIndex(i.metadata.rigidBodyIndexSize), t.rigidBodyIndex2 = n.getIndex(i.metadata.rigidBodyIndexSize), t.position = n.getFloat32Array(3), t.rotation = n.getFloat32Array(3), t.translationLimitation1 = n.getFloat32Array(3), t.translationLimitation2 = n.getFloat32Array(3), t.rotationLimitation1 = n.getFloat32Array(3), t.rotationLimitation2 = n.getFloat32Array(3), t.springPosition = n.getFloat32Array(3), t.springRotation = n.getFloat32Array(3), t))
                            }(), !0 === e && this.leftToRightModel(i), i
                    }, h.prototype.parseVmd = function(t, e) {
                        var i = {},
                            n = new o(t);
                        return i.metadata = {}, i.metadata.coordinateSystem = "left",
                            function() {
                                var t = i.metadata;
                                if (t.magic = n.getChars(30), "Vocaloid Motion Data 0002" !== t.magic) throw "VMD file magic is not Vocaloid Motion Data 0002, but " + t.magic;
                                t.name = n.getSjisStringsAsUnicode(20)
                            }(),
                            function() {
                                var t, e = i.metadata;
                                e.motionCount = n.getUint32(), i.motions = [];
                                for (var r = 0; r < e.motionCount; r++) i.motions.push((t = void 0, (t = {}).boneName = n.getSjisStringsAsUnicode(15), t.frameNum = n.getUint32(), t.position = n.getFloat32Array(3), t.rotation = n.getFloat32Array(4), t.interpolation = n.getUint8Array(64), t))
                            }(),
                            function() {
                                var t, e = i.metadata;
                                e.morphCount = n.getUint32(), i.morphs = [];
                                for (var r = 0; r < e.morphCount; r++) i.morphs.push((t = void 0, (t = {}).morphName = n.getSjisStringsAsUnicode(15), t.frameNum = n.getUint32(), t.weight = n.getFloat32(), t))
                            }(),
                            function() {
                                var t, e = i.metadata;
                                e.cameraCount = n.getUint32(), i.cameras = [];
                                for (var r = 0; r < e.cameraCount; r++) i.cameras.push((t = void 0, (t = {}).frameNum = n.getUint32(), t.distance = n.getFloat32(), t.position = n.getFloat32Array(3), t.rotation = n.getFloat32Array(3), t.interpolation = n.getUint8Array(24), t.fov = n.getUint32(), t.perspective = n.getUint8(), t))
                            }(), !0 === e && this.leftToRightVmd(i), i
                    }, h.prototype.parseVpd = function(t, e) {
                        var i = {
                            metadata: {}
                        };
                        i.metadata.coordinateSystem = "left", i.bones = [];
                        var n = t.replace(/\/\/\w*(\r|\n|\r\n)/g, "").split(/\r|\n|\r\n/);

                        function r() {
                            throw "the file seems not vpd file."
                        }
                        return "Vocaloid Pose Data file" !== n[0] && r(), n.length < 4 && r(), i.metadata.parentFile = n[2], i.metadata.boneCount = parseInt(n[3]),
                            function() {
                                for (var t = /^\s*(Bone[0-9]+)\s*\{\s*(.*)$/, e = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/, s = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/, a = /^\s*}/, o = i.bones, l = null, h = null, c = null, u = 4; u < n.length; u++) {
                                    var d, p = n[u];
                                    null !== (d = p.match(t)) && (null !== l && r(), l = d[2]), null !== (d = p.match(e)) && (null !== h && r(), h = [parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])]), null !== (d = p.match(s)) && (null !== c && r(), c = [parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]), parseFloat(d[4])]), null !== (d = p.match(a)) && (null !== l && null !== h && null !== c || r(), o.push({
                                        name: l,
                                        translation: h,
                                        quaternion: c
                                    }), l = null, h = null, c = null)
                                }
                                null === l && null === h && null === c || r()
                            }(), !0 === e && this.leftToRightVpd(i), i
                    }, h.prototype.mergeVmds = function(t) {
                        var e = {
                            metadata: {}
                        };
                        e.metadata.name = t[0].metadata.name, e.metadata.coordinateSystem = t[0].metadata.coordinateSystem, e.metadata.motionCount = 0, e.metadata.morphCount = 0, e.metadata.cameraCount = 0, e.motions = [], e.morphs = [], e.cameras = [];
                        for (var i = 0; i < t.length; i++) {
                            var n = t[i];
                            e.metadata.motionCount += n.metadata.motionCount, e.metadata.morphCount += n.metadata.morphCount, e.metadata.cameraCount += n.metadata.cameraCount;
                            for (var r = 0; r < n.metadata.motionCount; r++) e.motions.push(n.motions[r]);
                            for (r = 0; r < n.metadata.morphCount; r++) e.morphs.push(n.morphs[r]);
                            for (r = 0; r < n.metadata.cameraCount; r++) e.cameras.push(n.cameras[r])
                        }
                        return e
                    }, h.prototype.leftToRightModel = function(t) {
                        if ("right" !== t.metadata.coordinateSystem) {
                            t.metadata.coordinateSystem = "right";
                            for (var e = new l, i = 0; i < t.metadata.vertexCount; i++) e.leftToRightVector3(t.vertices[i].position), e.leftToRightVector3(t.vertices[i].normal);
                            for (i = 0; i < t.metadata.faceCount; i++) e.leftToRightIndexOrder(t.faces[i].indices);
                            for (i = 0; i < t.metadata.boneCount; i++) e.leftToRightVector3(t.bones[i].position);
                            for (i = 0; i < t.metadata.morphCount; i++) {
                                var n = t.morphs[i];
                                if ("pmx" !== t.metadata.format || 1 === n.type)
                                    for (var r = 0; r < n.elements.length; r++) e.leftToRightVector3(n.elements[r].position)
                            }
                            for (i = 0; i < t.metadata.rigidBodyCount; i++) e.leftToRightVector3(t.rigidBodies[i].position), e.leftToRightEuler(t.rigidBodies[i].rotation);
                            for (i = 0; i < t.metadata.constraintCount; i++) e.leftToRightVector3(t.constraints[i].position), e.leftToRightEuler(t.constraints[i].rotation), e.leftToRightVector3Range(t.constraints[i].translationLimitation1, t.constraints[i].translationLimitation2), e.leftToRightEulerRange(t.constraints[i].rotationLimitation1, t.constraints[i].rotationLimitation2)
                        }
                    }, h.prototype.leftToRightVmd = function(t) {
                        if ("right" !== t.metadata.coordinateSystem) {
                            t.metadata.coordinateSystem = "right";
                            for (var e = new l, i = 0; i < t.metadata.motionCount; i++) e.leftToRightVector3(t.motions[i].position), e.leftToRightQuaternion(t.motions[i].rotation);
                            for (i = 0; i < t.metadata.cameraCount; i++) e.leftToRightVector3(t.cameras[i].position), e.leftToRightEuler(t.cameras[i].rotation)
                        }
                    }, h.prototype.leftToRightVpd = function(t) {
                        if ("right" !== t.metadata.coordinateSystem) {
                            t.metadata.coordinateSystem = "right";
                            for (var e = new l, i = 0; i < t.bones.length; i++) e.leftToRightVector3(t.bones[i].translation), e.leftToRightQuaternion(t.bones[i].quaternion)
                        }
                    };
                    var c = {
                        CharsetEncoder: a,
                        Parser: h
                    };
                    class u extends n.aHM {
                        constructor(t) {
                            super(t), this.loader = new n.Y9S(this.manager), this.parser = null, this.meshBuilder = new m(this.manager), this.animationBuilder = new v
                        }
                        setAnimationPath(t) {
                            return this.animationPath = t, this
                        }
                        load(t, e, i, r) {
                            const s = this.meshBuilder.setCrossOrigin(this.crossOrigin);
                            let a;
                            a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : n.r6x.extractUrlBase(t);
                            const o = this._getParser(),
                                l = this._extractModelExtension;
                            this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(t, (function(t) {
                                try {
                                    const n = l(t);
                                    if ("pmd" !== n && "pmx" !== n) return void(r && r(new Error("THREE.MMDLoader: Unknown model file extension ." + n + ".")));
                                    const h = "pmd" === n ? o.parsePmd(t, !0) : o.parsePmx(t, !0);
                                    e(s.build(h, a, i, r))
                                } catch (t) {
                                    r && r(t)
                                }
                            }), i, r)
                        }
                        loadAnimation(t, e, i, n, r) {
                            const s = this.animationBuilder;
                            this.loadVMD(t, (function(t) {
                                console.log(e);
                                i(e.isCamera ? s.buildCameraAnimation(t) : s.build(t, e))//留个锚点 第二参数是s.buildCameraAnimation(t
                            }), n, r)
                        }
                        loadWithAnimation(t, e, i, n, r) {
                            const s = this;
                            this.load(t, (function(t) {
                                s.loadAnimation(e, t, (function(e) {
                                    t.scale.set(
                                        mmdinfo.model.scale.x,
                                        mmdinfo.model.scale.y,
                                        mmdinfo.model.scale.z)
                                    i({
                                        mesh: t, //使用的网格
                                        animation: e //使用的动画
                                    })
                                }), n, r)
                            }), n, r)
                        }
                        loadPMD(t, e, i, n) {
                            const r = this._getParser();
                            this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(t, (function(t) {
                                try {
                                    e(r.parsePmd(t, !0))
                                } catch (t) {
                                    n && n(t)
                                }
                            }), i, n)
                        }
                        loadPMX(t, e, i, n) {
                            const r = this._getParser();
                            this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(t, (function(t) {
                                try {
                                    e(r.parsePmx(t, !0))
                                } catch (t) {
                                    n && n(t)
                                }
                            }), i, n)
                        }
                        loadVMD(t, e, i, n) {
                            const r = Array.isArray(t) ? t : [t],
                                s = [],
                                a = r.length,
                                o = this._getParser();
                            this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);
                            for (let t = 0, l = r.length; t < l; t++) this.loader.load(r[t], (function(t) {
                                try {
                                    s.push(o.parseVmd(t, !0)), s.length === a && e(o.mergeVmds(s))
                                } catch (t) {
                                    n && n(t)
                                }
                            }), i, n)
                        }
                        loadVPD(t, e, i, n, r) {
                            const s = this._getParser();
                            this.loader.setMimeType(e ? void 0 : "text/plain; charset=shift_jis").setPath(this.animationPath).setResponseType("text").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(t, (function(t) {
                                try {
                                    i(s.parseVpd(t, !0))
                                } catch (t) {
                                    r && r(t)
                                }
                            }), n, r)
                        }
                        _extractModelExtension(t) {
                            const e = new TextDecoder("utf-8"),
                                i = new Uint8Array(t, 0, 3);
                            return e.decode(i).toLowerCase()
                        }
                        _getParser() {
                            return null === this.parser && (this.parser = new c.Parser), this.parser
                        }
                    }
                    const d = ["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII="],
                        p = [n.IE4, n.k6Q, n.kTp, n.CVz, n.Riy];
                    class m {
                        constructor(t) {
                            this.crossOrigin = "anonymous", this.geometryBuilder = new f, this.materialBuilder = new g(t)
                        }
                        setCrossOrigin(t) {
                            return this.crossOrigin = t, this
                        }
                        build(t, e, i, r) {
                            const s = this.geometryBuilder.build(t),
                                a = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(e).build(t, s, i, r),
                                o = new n.I46(s, a),
                                l = new n.EAD(function(t) {
                                    const e = t.geometry,
                                        i = [];
                                    if (e && void 0 !== e.bones) {
                                        for (let t = 0, r = e.bones.length; t < r; t++) {
                                            const r = e.bones[t],
                                                s = new n.$Kf;
                                            i.push(s), s.name = r.name, s.position.fromArray(r.pos), s.quaternion.fromArray(r.rotq), void 0 !== r.scl && s.scale.fromArray(r.scl)
                                        }
                                        for (let n = 0, r = e.bones.length; n < r; n++) {
                                            const r = e.bones[n]; - 1 !== r.parent && null !== r.parent && void 0 !== i[r.parent] ? i[r.parent].add(i[n]) : t.add(i[n])
                                        }
                                    }
                                    return t.updateMatrixWorld(!0), i
                                }(o));
                            return o.bind(l), o
                        }
                    }
                    class f {
                        build(t) {
                            const e = [],
                                i = [],
                                r = [],
                                s = [],
                                a = [],
                                o = [],
                                l = [],
                                h = [],
                                c = [],
                                u = [],
                                d = [],
                                p = [],
                                m = [],
                                f = [];
                            let g = 0;
                            const v = {};
                            for (let x = 0; x < t.metadata.vertexCount; x++) {
                                const M = t.vertices[x];
                                for (let b = 0, S = M.position.length; b < S; b++) e.push(M.position[b]);
                                for (let w = 0, A = M.normal.length; w < A; w++) r.push(M.normal[w]);
                                for (let T = 0, E = M.uv.length; T < E; T++) i.push(M.uv[T]);
                                for (let C = 0; C < 4; C++) l.push(M.skinIndices.length - 1 >= C ? M.skinIndices[C] : 0);
                                for (let R = 0; R < 4; R++) h.push(M.skinWeights.length - 1 >= R ? M.skinWeights[R] : 0)
                            }
                            for (let P = 0; P < t.metadata.faceCount; P++) {
                                const I = t.faces[P];
                                for (let L = 0, U = I.indices.length; L < U; L++) s.push(I.indices[L])
                            }
                            for (let N = 0; N < t.metadata.materialCount; N++) {
                                const D = t.materials[N];
                                a.push({
                                    offset: 3 * g,
                                    count: 3 * D.faceCount
                                }), g += D.faceCount
                            }
                            for (let O = 0; O < t.metadata.rigidBodyCount; O++) {
                                const B = t.rigidBodies[O];
                                let z = v[B.boneIndex];
                                z = void 0 === z ? B.type : Math.max(B.type, z), v[B.boneIndex] = z
                            }
                            for (let F = 0; F < t.metadata.boneCount; F++) {
                                const k = t.bones[F],
                                    V = {
                                        index: F,
                                        transformationClass: k.transformationClass,
                                        parent: k.parentIndex,
                                        name: k.name,
                                        pos: k.position.slice(0, 3),
                                        rotq: [0, 0, 0, 1],
                                        scl: [1, 1, 1],
                                        rigidBodyType: void 0 !== v[F] ? v[F] : -1
                                    }; - 1 !== V.parent && (V.pos[0] -= t.bones[V.parent].position[0], V.pos[1] -= t.bones[V.parent].position[1], V.pos[2] -= t.bones[V.parent].position[2]), o.push(V)
                            }
                            if ("pmd" === t.metadata.format)
                                for (let H = 0; H < t.metadata.ikCount; H++) {
                                    const G = t.iks[H],
                                        W = {
                                            target: G.target,
                                            effector: G.effector,
                                            iteration: G.iteration,
                                            maxAngle: 4 * G.maxAngle,
                                            links: []
                                        };
                                    for (let j = 0, X = G.links.length; j < X; j++) {
                                        const q = {};
                                        q.index = G.links[j].index, q.enabled = !0, t.bones[q.index].name.indexOf("ひざ") >= 0 && (q.limitation = new n.Pq0(1, 0, 0)), W.links.push(q)
                                    }
                                    d.push(W)
                                } else
                                    for (let Y = 0; Y < t.metadata.boneCount; Y++) {
                                        const J = t.bones[Y].ik;
                                        if (void 0 === J) continue;
                                        const Z = {
                                            target: Y,
                                            effector: J.effector,
                                            iteration: J.iteration,
                                            maxAngle: J.maxAngle,
                                            links: []
                                        };
                                        for (let K = 0, Q = J.links.length; K < Q; K++) {
                                            const $ = {};
                                            if ($.index = J.links[K].index, $.enabled = !0, 1 === J.links[K].angleLimitation) {
                                                const tt = J.links[K].lowerLimitationAngle,
                                                    et = J.links[K].upperLimitationAngle,
                                                    it = -et[0],
                                                    nt = -et[1];
                                                et[0] = -tt[0], et[1] = -tt[1], tt[0] = it, tt[1] = nt, $.rotationMin = (new n.Pq0).fromArray(tt), $.rotationMax = (new n.Pq0).fromArray(et)
                                            }
                                            Z.links.push($)
                                        }
                                        d.push(Z), o[Y].ik = Z
                                    }
                            if ("pmx" === t.metadata.format) {
                                const rt = {};
                                for (let ot = 0; ot < t.metadata.boneCount; ot++) {
                                    const lt = t.bones[ot],
                                        ht = lt.grant;
                                    if (void 0 === ht) continue;
                                    const ct = {
                                        index: ot,
                                        parentIndex: ht.parentIndex,
                                        ratio: ht.ratio,
                                        isLocal: ht.isLocal,
                                        affectRotation: ht.affectRotation,
                                        affectPosition: ht.affectPosition,
                                        transformationClass: lt.transformationClass
                                    };
                                    rt[ot] = {
                                        parent: null,
                                        children: [],
                                        param: ct,
                                        visited: !1
                                    }
                                }
                                const st = {
                                    parent: null,
                                    children: [],
                                    param: null,
                                    visited: !1
                                };
                                for (const ut in rt) {
                                    const dt = rt[ut],
                                        pt = rt[dt.parentIndex] || st;
                                    dt.parent = pt, pt.children.push(dt)
                                }

                                function at(t) {
                                    t.param && (p.push(t.param), o[t.param.index].grant = t.param), t.visited = !0;
                                    for (let e = 0, i = t.children.length; e < i; e++) {
                                        const i = t.children[e];
                                        i.visited || at(i)
                                    }
                                }
                                at(st)
                            }

                            function _(e, i, n) {
                                for (let r = 0; r < i.elementCount; r++) {
                                    const s = i.elements[r];
                                    let a;
                                    a = "pmd" === t.metadata.format ? t.morphs[0].elements[s.index].index : s.index, e.array[3 * a + 0] += s.position[0] * n, e.array[3 * a + 1] += s.position[1] * n, e.array[3 * a + 2] += s.position[2] * n
                                }
                            }
                            for (let mt = 0; mt < t.metadata.morphCount; mt++) {
                                const ft = t.morphs[mt],
                                    gt = {
                                        name: ft.name
                                    },
                                    vt = new n.qtW(3 * t.metadata.vertexCount, 3);
                                vt.name = ft.name;
                                for (let _t = 0; _t < 3 * t.metadata.vertexCount; _t++) vt.array[_t] = e[_t];
                                if ("pmd" === t.metadata.format) 0 !== mt && _(vt, ft, 1);
                                else if (0 === ft.type)
                                    for (let yt = 0; yt < ft.elementCount; yt++) {
                                        const xt = t.morphs[ft.elements[yt].index],
                                            Mt = ft.elements[yt].ratio;
                                        1 === xt.type && _(vt, xt, Mt)
                                    } else 1 === ft.type ? _(vt, ft, 1) : 2 === ft.type || 3 === ft.type || 4 === ft.type || 5 === ft.type || 6 === ft.type || 7 === ft.type || ft.type;
                                c.push(gt), u.push(vt)
                            }
                            for (let bt = 0; bt < t.metadata.rigidBodyCount; bt++) {
                                const St = t.rigidBodies[bt],
                                    wt = {};
                                for (const At in St) wt[At] = St[At];
                                if ("pmx" === t.metadata.format && -1 !== wt.boneIndex) {
                                    const Tt = t.bones[wt.boneIndex];
                                    wt.position[0] -= Tt.position[0], wt.position[1] -= Tt.position[1], wt.position[2] -= Tt.position[2]
                                }
                                m.push(wt)
                            }
                            for (let Et = 0; Et < t.metadata.constraintCount; Et++) {
                                const Ct = t.constraints[Et],
                                    Rt = {};
                                for (const Lt in Ct) Rt[Lt] = Ct[Lt];
                                const Pt = m[Rt.rigidBodyIndex1],
                                    It = m[Rt.rigidBodyIndex2];
                                0 !== Pt.type && 2 === It.type && -1 !== Pt.boneIndex && -1 !== It.boneIndex && t.bones[It.boneIndex].parentIndex === Pt.boneIndex && (It.type = 1), f.push(Rt)
                            }
                            const y = new n.LoY;
                            y.setAttribute("position", new n.qtW(e, 3)), y.setAttribute("normal", new n.qtW(r, 3)), y.setAttribute("uv", new n.qtW(i, 2)), y.setAttribute("skinIndex", new n.A$4(l, 4)), y.setAttribute("skinWeight", new n.qtW(h, 4)), y.setIndex(s);
                            for (let Ut = 0, Nt = a.length; Ut < Nt; Ut++) y.addGroup(a[Ut].offset, a[Ut].count, Ut);
                            return y.bones = o, y.morphTargets = c, y.morphAttributes.position = u, y.morphTargetsRelative = !1, y.userData.MMD = {
                                bones: o,
                                iks: d,
                                grants: p,
                                rigidBodies: m,
                                constraints: f,
                                format: t.metadata.format
                            }, y.computeBoundingSphere(), y
                        }
                    }
                    class g {
                        constructor(t) {
                            this.manager = t, this.textureLoader = new n.Tap(this.manager), this.tgaLoader = null, this.crossOrigin = "anonymous", this.resourcePath = void 0
                        }
                        setCrossOrigin(t) {
                            return this.crossOrigin = t, this
                        }
                        setResourcePath(t) {
                            return this.resourcePath = t, this
                        }
                        build(t, e) {
                            const i = [],
                                r = {};
                            this.textureLoader.setCrossOrigin(this.crossOrigin);
                            for (let s = 0; s < t.metadata.materialCount; s++) {
                                const a = t.materials[s],
                                    o = {
                                        userData: {
                                            MMD: {}
                                        }
                                    };
                                if (void 0 !== a.name && (o.name = a.name), o.diffuse = (new n.Q1f).setRGB(a.diffuse[0], a.diffuse[1], a.diffuse[2], n.er$), o.opacity = a.diffuse[3], o.specular = (new n.Q1f).setRGB(...a.specular, n.er$), o.shininess = a.shininess, o.emissive = (new n.Q1f).setRGB(...a.ambient, n.er$), o.transparent = 1 !== o.opacity, o.fog = !0, o.blending = n.bCz, o.blendSrc = n.ie2, o.blendDst = n.OuU, o.blendSrcAlpha = n.ie2, o.blendDstAlpha = n.hdd, "pmx" !== t.metadata.format || 1 & ~a.flag ? o.side = 1 === o.opacity ? n.hB5 : n.$EB : o.side = n.$EB, "pmd" === t.metadata.format) {
                                    if (a.fileName) {
                                        const h = a.fileName.split("*");
                                        if (o.map = this._loadTexture(h[0], r), h.length > 1) {
                                            const c = h[1].slice(-4).toLowerCase();
                                            o.matcap = this._loadTexture(h[1], r), o.matcapCombine = ".sph" === c ? n.caT : n.XrR
                                        }
                                    }
                                    const l = -1 === a.toonIndex ? "toon00.bmp" : t.toonTextures[a.toonIndex].fileName;
                                    o.gradientMap = this._loadTexture(l, r, {
                                        isToonTexture: !0,
                                        isDefaultToonTexture: this._isDefaultToonTexture(l)
                                    }), o.userData.outlineParameters = {
                                        thickness: 1 === a.edgeFlag ? .003 : 0,
                                        color: [0, 0, 0],
                                        alpha: 1,
                                        visible: 1 === a.edgeFlag
                                    }
                                } else {
                                    let u, d; - 1 !== a.textureIndex && (o.map = this._loadTexture(t.textures[a.textureIndex], r), o.userData.MMD.mapFileName = t.textures[a.textureIndex]), -1 === a.envTextureIndex || 1 !== a.envFlag && 2 != a.envFlag || (o.matcap = this._loadTexture(t.textures[a.envTextureIndex], r), o.userData.MMD.matcapFileName = t.textures[a.envTextureIndex], o.matcapCombine = 1 === a.envFlag ? n.caT : n.XrR), -1 === a.toonIndex || 0 !== a.toonFlag ? (u = "toon" + ("0" + (a.toonIndex + 1)).slice(-2) + ".bmp", d = !0) : (u = t.textures[a.toonIndex], d = !1), o.gradientMap = this._loadTexture(u, r, {
                                        isToonTexture: !0,
                                        isDefaultToonTexture: d
                                    }), o.userData.outlineParameters = {
                                        thickness: a.edgeSize / 300,
                                        color: a.edgeColor.slice(0, 3),
                                        alpha: a.edgeColor[3],
                                        visible: !!(16 & a.flag) && a.edgeSize > 0
                                    }
                                }
                                void 0 !== o.map && (o.transparent || this._checkImageTransparency(o.map, e, s), o.emissive.multiplyScalar(.2)), i.push(new y(o))
                            }
                            if ("pmx" === t.metadata.format) {
                                function p(t, e) {
                                    for (let i = 0, n = t.length; i < n; i++) {
                                        const n = t[i];
                                        if (-1 === n.index) continue;
                                        const r = e[n.index];
                                        r.opacity !== n.diffuse[3] && (r.transparent = !0)
                                    }
                                }
                                for (let m = 0, f = t.morphs.length; m < f; m++) {
                                    const g = t.morphs[m],
                                        v = g.elements;
                                    if (0 === g.type)
                                        for (let _ = 0, x = v.length; _ < x; _++) {
                                            const M = t.morphs[v[_].index];
                                            8 === M.type && p(M.elements, i)
                                        } else 8 === g.type && p(v, i)
                                }
                            }
                            return i
                        }
                        _getTGALoader() {
                            if (null === this.tgaLoader) {
                                if (void 0 === s) throw new Error("THREE.MMDLoader: Import TGALoader");
                                this.tgaLoader = new s(this.manager)
                            }
                            return this.tgaLoader
                        }
                        _isDefaultToonTexture(t) {
                            return 10 === t.length && /toon(10|0[0-9])\.bmp/.test(t)
                        }
                        _loadTexture(t, e, i, r, s) {
                            const a = this;
                            let o;
                            if (!0 === (i = i || {}).isDefaultToonTexture) {
                                let e;
                                try {
                                    e = parseInt(t.match(/toon([0-9]{2})\.bmp$/)[1])
                                } catch (i) {
                                    console.warn("THREE.MMDLoader: " + t + " seems like a not right default texture path. Using toon00.bmp instead."), e = 0
                                }
                                o = d[e]
                            } else o = this.resourcePath + t;
                            if (void 0 !== e[o]) return e[o];
                            let l = this.manager.getHandler(o);
                            null === l && (l = ".tga" === t.slice(-4).toLowerCase() ? this._getTGALoader() : this.textureLoader);
                            const h = l.load(o, (function(t) {
                                !0 === i.isToonTexture && (t.image = a._getRotatedImage(t.image), t.magFilter = n.hxR, t.minFilter = n.hxR), t.flipY = !1, t.wrapS = n.GJx, t.wrapT = n.GJx, t.colorSpace = n.er$;
                                for (let t = 0; t < h.readyCallbacks.length; t++) h.readyCallbacks[t](h);
                                delete h.readyCallbacks
                            }), r, s);
                            return h.readyCallbacks = [], e[o] = h, h
                        }
                        _getRotatedImage(t) {
                            const e = document.createElement("canvas"),
                                i = e.getContext("2d"),
                                n = t.width,
                                r = t.height;
                            return e.width = n, e.height = r, i.clearRect(0, 0, n, r), i.translate(n / 2, r / 2), i.rotate(.5 * Math.PI), i.translate(-n / 2, -r / 2), i.drawImage(t, 0, 0), i.getImageData(0, 0, n, r)
                        }
                        _checkImageTransparency(t, e, i) {
                            t.readyCallbacks.push((function(n) {
                                function r(t, e) {
                                    const i = t.width,
                                        n = t.height;
                                    let r = Math.round(e.x * i) % i,
                                        s = Math.round(e.y * n) % n;
                                    r < 0 && (r += i), s < 0 && (s += n);
                                    const a = s * i + r;
                                    return t.data[4 * a + 3]
                                }
                                if (!0 === n.isCompressedTexture) return void(p.includes(n.format) ? t.transparent = !1 : t.transparent = !0);
                                const s = void 0 !== n.image.data ? n.image : function(t) {
                                        const e = document.createElement("canvas");
                                        e.width = t.width, e.height = t.height;
                                        const i = e.getContext("2d");
                                        return i.drawImage(t, 0, 0), i.getImageData(0, 0, e.width, e.height)
                                    }(n.image),
                                    a = e.groups[i];
                                (function(t, e, i) {
                                    const n = t.width,
                                        s = t.height;
                                    if (t.data.length / (n * s) != 4) return !1;
                                    for (let n = 0; n < i.length; n += 3) {
                                        const s = {
                                            x: 0,
                                            y: 0
                                        };
                                        for (let a = 0; a < 3; a++) {
                                            const o = i[3 * n + a],
                                                l = {
                                                    x: e[2 * o + 0],
                                                    y: e[2 * o + 1]
                                                };
                                            if (r(t, l) < 253) return !0;
                                            s.x += l.x, s.y += l.y
                                        }
                                        if (s.x /= 3, s.y /= 3, r(t, s) < 253) return !0
                                    }
                                    return !1
                                })(s, e.attributes.uv.array, e.index.array.slice(a.start, a.start + a.count)) && (t.transparent = !0)
                            }))
                        }
                    }
                    class v {
                        build(t, e) {
                            const i = this.buildSkeletalAnimation(t, e).tracks,
                                r = this.buildMorphAnimation(t, e).tracks;
                            for (let t = 0, e = r.length; t < e; t++) i.push(r[t]);
                            return new n.tz3("", -1, i)
                        }
                        buildSkeletalAnimation(t, e) {
                            function i(t, e, i) {
                                t.push(e[i + 0] / 127), t.push(e[i + 8] / 127), t.push(e[i + 4] / 127), t.push(e[i + 12] / 127)
                            }
                            const r = [],
                                s = {},
                                a = e.skeleton.bones,
                                o = {};
                            for (let t = 0, e = a.length; t < e; t++) o[a[t].name] = !0;
                            for (let e = 0; e < t.metadata.motionCount; e++) {
                                const i = t.motions[e],
                                    n = i.boneName;
                                void 0 !== o[n] && (s[n] = s[n] || [], s[n].push(i))
                            }
                            for (const t in s) {
                                const a = s[t];
                                a.sort((function(t, e) {
                                    return t.frameNum - e.frameNum
                                }));
                                const o = [],
                                    l = [],
                                    h = [],
                                    c = [],
                                    u = [],
                                    d = e.skeleton.getBoneByName(t).position.toArray();
                                for (let t = 0, e = a.length; t < e; t++) {
                                    const e = a[t].frameNum / 30,
                                        n = a[t].position,
                                        r = a[t].rotation,
                                        s = a[t].interpolation;
                                    o.push(e);
                                    for (let t = 0; t < 3; t++) l.push(d[t] + n[t]);
                                    for (let t = 0; t < 4; t++) h.push(r[t]);
                                    for (let t = 0; t < 3; t++) i(c, s, t);
                                    i(u, s, 3)
                                }
                                const p = ".bones[" + t + "]";
                                r.push(this._createTrack(p + ".position", n.RiT, o, l, c)), r.push(this._createTrack(p + ".quaternion", n.MBL, o, h, u))
                            }
                            return new n.tz3("", -1, r)
                        }
                        buildMorphAnimation(t, e) {
                            const i = [],
                                r = {},
                                s = e.morphTargetDictionary;
                            for (let e = 0; e < t.metadata.morphCount; e++) {
                                const i = t.morphs[e],
                                    n = i.morphName;
                                void 0 !== s[n] && (r[n] = r[n] || [], r[n].push(i))
                            }
                            for (const t in r) {
                                const e = r[t];
                                e.sort((function(t, e) {
                                    return t.frameNum - e.frameNum
                                }));
                                const a = [],
                                    o = [];
                                for (let t = 0, i = e.length; t < i; t++) a.push(e[t].frameNum / 30), o.push(e[t].weight);
                                i.push(new n.Hit(".morphTargetInfluences[" + s[t] + "]", a, o))
                            }
                            return new n.tz3("", -1, i)
                        }
                        buildCameraAnimation(t) {
                            function e(t, e) {
                                t.push(e.x), t.push(e.y), t.push(e.z)
                            }

                            function i(t, e, i) {
                                t.push(e[4 * i + 0] / 127), t.push(e[4 * i + 1] / 127), t.push(e[4 * i + 2] / 127), t.push(e[4 * i + 3] / 127)
                            }
                            const r = void 0 === t.cameras ? [] : t.cameras.slice();
                            r.sort((function(t, e) {
                                return t.frameNum - e.frameNum
                            }));
                            const s = [],
                                a = [],
                                o = [],
                                l = [],
                                h = [],
                                c = [],
                                u = [],
                                d = [],
                                p = [],
                                m = new n.PTz,
                                f = new n.O9p,
                                g = new n.Pq0,
                                v = new n.Pq0;
                            for (let t = 0, n = r.length; t < n; t++) {
                                const n = r[t],
                                    x = n.frameNum / 30,
                                    M = n.position,
                                    b = n.rotation,
                                    S = n.distance,
                                    w = n.fov,
                                    A = n.interpolation;
                                s.push(x), g.set(0, 0, -S), v.set(M[0], M[1], M[2]), f.set(-b[0], -b[1], -b[2]), m.setFromEuler(f), g.add(v), g.applyQuaternion(m), e(a, v), (_ = o).push((y = m).x), _.push(y.y), _.push(y.z), _.push(y.w), e(l, g), h.push(w);
                                for (let t = 0; t < 3; t++) i(c, A, t);
                                i(u, A, 3);
                                for (let t = 0; t < 3; t++) i(d, A, 4);
                                i(p, A, 5)
                            }
                            var _, y;
                            const x = [];
                            return x.push(this._createTrack("target.position", n.RiT, s, a, c)), x.push(this._createTrack(".quaternion", n.MBL, s, o, u)), x.push(this._createTrack(".position", n.RiT, s, l, d)), x.push(this._createTrack(".fov", n.Hit, s, h, p)), new n.tz3("", -1, x)
                        }
                        _createTrack(t, e, i, n, r) {
                            if (i.length > 2) {
                                i = i.slice(), n = n.slice(), r = r.slice();
                                const t = n.length / i.length,
                                    e = r.length / i.length;
                                let s = 1;
                                for (let a = 2, o = i.length; a < o; a++) {
                                    for (let e = 0; e < t; e++)
                                        if (n[s * t + e] !== n[(s - 1) * t + e] || n[s * t + e] !== n[a * t + e]) {
                                            s++;
                                            break
                                        } if (a > s) {
                                        i[s] = i[a];
                                        for (let e = 0; e < t; e++) n[s * t + e] = n[a * t + e];
                                        for (let t = 0; t < e; t++) r[s * e + t] = r[a * e + t]
                                    }
                                }
                                i.length = s + 1, n.length = (s + 1) * t, r.length = (s + 1) * e
                            }
                            const s = new e(t, i, n);
                            return s.createInterpolant = function(t) {
                                return new _(this.times, this.values, this.getValueSize(), t, new Float32Array(r))
                            }, s
                        }
                    }
                    class _ extends n.lGw {
                        constructor(t, e, i, n, r) {
                            super(t, e, i, n), this.interpolationParams = r
                        }
                        interpolate_(t, e, i, r) {
                            const s = this.resultBuffer,
                                a = this.sampleValues,
                                o = this.valueSize,
                                l = this.interpolationParams,
                                h = t * o,
                                c = h - o,
                                u = r - e < .05 ? 0 : (i - e) / (r - e);
                            if (4 === o) {
                                const e = l[4 * t + 0],
                                    i = l[4 * t + 1],
                                    r = l[4 * t + 2],
                                    o = l[4 * t + 3],
                                    d = this._calculate(e, i, r, o, u);
                                n.PTz.slerpFlat(s, 0, a, c, a, h, d)
                            } else if (3 === o)
                                for (let e = 0; e !== o; ++e) {
                                    const i = l[12 * t + 4 * e + 0],
                                        n = l[12 * t + 4 * e + 1],
                                        r = l[12 * t + 4 * e + 2],
                                        o = l[12 * t + 4 * e + 3],
                                        d = this._calculate(i, n, r, o, u);
                                    s[e] = a[c + e] * (1 - d) + a[h + e] * d
                                } else {
                                    const e = l[4 * t + 0],
                                        i = l[4 * t + 1],
                                        n = l[4 * t + 2],
                                        r = l[4 * t + 3],
                                        o = this._calculate(e, i, n, r, u);
                                    s[0] = a[c] * (1 - o) + a[h] * o
                                }
                            return s
                        }
                        _calculate(t, e, i, n, r) {
                            let s = .5,
                                a = s,
                                o = 1 - a;
                            const l = Math;
                            let h, c, u;
                            for (let i = 0; i < 15; i++) {
                                h = 3 * o * o * a, c = 3 * o * a * a, u = a * a * a;
                                const i = h * t + c * e + u - r;
                                if (l.abs(i) < 1e-5) break;
                                s /= 2, a += i < 0 ? s : -s, o = 1 - a
                            }
                            return h * i + c * n + u
                        }
                    }
                    class y extends n.BKk {
                        constructor(t) {
                            super(), this.isMMDToonMaterial = !0, this.type = "MMDToonMaterial", this._matcapCombine = n.XrR, this.emissiveIntensity = 1, this.normalMapType = n.bI3, this.combine = n.caT, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.lights = !0, this.vertexShader = r.vertexShader, this.fragmentShader = r.fragmentShader, this.defines = Object.assign({}, r.defines), Object.defineProperty(this, "matcapCombine", {
                                get: function() {
                                    return this._matcapCombine
                                },
                                set: function(t) {
                                    switch (this._matcapCombine = t, t) {
                                        case n.caT:
                                            this.defines.MATCAP_BLENDING_MULTIPLY = !0, delete this.defines.MATCAP_BLENDING_ADD;
                                            break;
                                        default:
                                        case n.XrR:
                                            this.defines.MATCAP_BLENDING_ADD = !0, delete this.defines.MATCAP_BLENDING_MULTIPLY
                                    }
                                }
                            }), this.uniforms = n.LlO.clone(r.uniforms);
                            const e = ["specular", "opacity", "diffuse", "map", "matcap", "gradientMap", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalScale", "displacemantBias", "displacemantMap", "displacemantScale", "specularMap", "alphaMap", "reflectivity", "refractionRatio"];
                            for (const t of e) Object.defineProperty(this, t, {
                                get: function() {
                                    return this.uniforms[t].value
                                },
                                set: function(e) {
                                    this.uniforms[t].value = e
                                }
                            });
                            this._shininess = 30, Object.defineProperty(this, "shininess", {
                                get: function() {
                                    return this._shininess
                                },
                                set: function(t) {
                                    this._shininess = t, this.uniforms.shininess.value = Math.max(this._shininess, 1e-4)
                                }
                            }), Object.defineProperty(this, "color", Object.getOwnPropertyDescriptor(this, "diffuse")), this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.matcapCombine = t.matcapCombine, this.emissiveIntensity = t.emissiveIntensity, this.normalMapType = t.normalMapType, this.combine = t.combine, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                        }
                    }
                },
                36: (t, e) => {
                    var i, n;
                    "object" != typeof globalThis && (Object.defineProperty(Object.prototype, "__magic__", {
                        get: function() {
                            return this
                        },
                        configurable: !0
                    }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__), void 0 === (n = "function" == typeof(i = function(t) {
                        "use strict";

                        function e() {}

                        function i() {}
                        var n, r, s, a, o, l, h, c;

                        function u() {
                            r = this, this.a_1 = new d(0, -2147483648), this.b_1 = new d(-1, 2147483647), this.c_1 = 8, this.d_1 = 64
                        }

                        function d(t, i) {
                            null == r && new u, e.call(this), this.e_1 = t, this.f_1 = i
                        }

                        function p(t) {
                            for (var e = 1, i = [], n = 0, r = t.length; n < r;) {
                                var s = t[n];
                                n = n + 1 | 0;
                                var a = e,
                                    o = s.prototype.$imask$,
                                    l = null == o ? s.$imask$ : o;
                                null != l && (i.push(l), a = l.length);
                                var h = s.$metadata$.iid,
                                    c = null == h ? null : (d = void 0, p = void 0, m = void 0, d = (u = h) >> 5, p = new Int32Array(d + 1 | 0), m = 1 << (31 & u), p[d] = p[d] | m, p);
                                null != c && (i.push(c), a = Math.max(a, c.length)), a > e && (e = a)
                            }
                            var u, d, p, m;
                            return function(t, e) {
                                for (var i = 0, n = new Int32Array(t); i < t;) {
                                    for (var r = i, s = 0, a = 0, o = e.length; a < o;) {
                                        var l = e[a];
                                        a = a + 1 | 0, r < l.length && (s |= l[r])
                                    }
                                    n[r] = s, i = i + 1 | 0
                                }
                                return n
                            }(e, i)
                        }

                        function m(t) {
                            return t = t === o ? null : t, Object.create(t)
                        }

                        function f(t, e) {
                            return null == t ? null == e : null != e && ("object" == typeof t && "function" == typeof t.equals ? t.equals(e) : t != t ? e != e : "number" == typeof t && "number" == typeof e ? t === e && (0 !== t || 1 / t == 1 / e) : t === e)
                        }

                        function g(t, e) {
                            null != Error.captureStackTrace ? Error.captureStackTrace(t, e) : t.stack = (new Error).stack
                        }

                        function v(t) {
                            return t.prototype
                        }

                        function _(t, e, i) {
                            Error.call(t),
                                function(t, e, i) {
                                    var n = A(Object.getPrototypeOf(t));
                                    if (!(1 & n)) {
                                        var r;
                                        if (null == e) {
                                            var s;
                                            if (null !== e) {
                                                var a = null == i ? null : i.toString();
                                                s = null == a ? o : a
                                            } else s = o;
                                            r = s
                                        } else r = e;
                                        t.message = r
                                    }
                                    2 & n || (t.cause = i), t.name = Object.getPrototypeOf(t).constructor.name
                                }(t, e, i)
                        }

                        function y(t) {
                            return M(), 4294967296 * t.f_1 + function(t) {
                                return M(), t.e_1 >= 0 ? t.e_1 : 4294967296 + t.e_1
                            }(t)
                        }

                        function x(t) {
                            return M(), new d(t, t < 0 ? -1 : 0)
                        }

                        function M() {
                            s || (s = !0, x(0), x(1), x(-1), new d(-1, 2147483647), new d(0, -2147483648), x(16777216))
                        }

                        function b(t, e, i, n, r, s, l, h, c) {
                            null != r && (e.prototype = Object.create(r.prototype), e.prototype.constructor = e);
                            var u = function(t, e, i, n, r, s) {
                                return {
                                    kind: t,
                                    simpleName: e,
                                    associatedObjectKey: n,
                                    associatedObjects: r,
                                    suspendArity: s,
                                    $kClass$: o,
                                    defaultConstructor: i,
                                    iid: "interface" === t ? (a === o && (a = 0), a = a + 1 | 0) : o
                                }
                            }(t, i, n, h, c, l);
                            e.$metadata$ = u, null != s && ((f(u.iid, o) ? e.prototype : e).$imask$ = p(s))
                        }

                        function S(t, e, i, n, r, s, a, o) {
                            b("class", t, e, i, n, r, s, a, o)
                        }

                        function w(t, e, i, n, r, s, a, o) {
                            b("object", t, e, i, n, r, s, a, o)
                        }

                        function A(t) {
                            var e = t.constructor,
                                i = null == e ? null : e.$metadata$,
                                n = null == i ? null : i.errorInfo;
                            if (null != n) return n;
                            var r, s = 0;
                            if (T(t, "message") && (s |= 1), T(t, "cause") && (s |= 2), 3 !== s) {
                                var a = (r = t, Object.getPrototypeOf(r));
                                a != Error.prototype && (s |= A(a))
                            }
                            return null != i && (i.errorInfo = s), s
                        }

                        function T(t, e) {
                            return t.hasOwnProperty(e)
                        }

                        function E(t) {
                            return _(t), C.call(t), t
                        }

                        function C() {
                            g(this, C)
                        }

                        function R(t) {
                            return E(t), P.call(t), t
                        }

                        function P() {
                            g(this, P)
                        }

                        function I() {
                            var t, e = (R(t = m(v(L))), L.call(t), t);
                            return g(e, I), e
                        }

                        function L() {
                            g(this, L)
                        }

                        function U(t, e) {
                            this.j_1 = t, this.k_1 = e
                        }
                        return S(e, "Number"), w(i, "Unit"), w(u, "Companion", o, l, h, c, o, o), S(d, "Long", o, e), S(C, "Exception", (function t() {
                            var e = E(m(v(C)));
                            return g(e, t), e
                        }), Error), S(P, "RuntimeException", (function t() {
                            var e = R(m(v(P)));
                            return g(e, t), e
                        }), C), S(L, "ClassCastException", I, P), S(U, "Pair"), v(d).g = function() {
                            return y(this)
                        }, v(d).equals = function(t) {
                            return t instanceof d && function(t, e) {
                                return M(), t.f_1 === e.f_1 && t.e_1 === e.e_1
                            }(this, t)
                        }, v(d).valueOf = function() {
                            return this.g()
                        }, v(U).l = function() {
                            return this.j_1
                        }, v(U).m = function() {
                            return this.k_1
                        }, v(U).equals = function(t) {
                            if (this === t) return !0;
                            if (!(t instanceof U)) return !1;
                            var e = t instanceof U ? t : function() {
                                throw I()
                            }();
                            return !!f(this.j_1, e.j_1) && !!f(this.k_1, e.k_1)
                        }, n = new i, t.$_$ = t.$_$ || {}, t.$_$.a = n, t.$_$.b = function(t) {
                            for (var e = {}, i = 0, n = t.length; i < n;) {
                                var r = t[i];
                                i = i + 1 | 0;
                                var s = r.l(),
                                    a = r.m();
                                e[s] = a
                            }
                            return e
                        }, t.$_$.c = d, t.$_$.d = function(t, e) {
                            return new U(t, e)
                        }, t
                    }) ? i.apply(e, [e]) : i) || (t.exports = n)
                },
                822: (t, e, i) => {
                    var n, r, s;
                    r = [e, i(657), i(36)], void 0 === (s = "function" == typeof(n = function(t, e, n) {
                        "use strict";
                        var r, s, a, o, l, h, c = e.Clock,
                            u = e.PerspectiveCamera,
                            d = e.Scene,
                            p = e.Color,
                            m = e.PolarGridHelper,
                            f = e.AudioListener,
                            g = e.AmbientLight,
                            v = e.DirectionalLight,
                            _ = e.WebGLRenderer,
                            y = e.Audio,
                            x = e.AudioLoader,
                            M = n.$_$.a,
                            b = n.$_$.c,
                            S = n.$_$.d,
                            w = n.$_$.b;

                        function A() {
                            return N(), o
                        }

                        function T(t) {
                            if (N(), t.lengthComputable) {
                                var e = t.loaded / t.total * 100;
                                console.log(Math.round(e, 2) + "% downloaded")
                            }
                        }

                        function E() {
                            N();
                            // var t = document.getElementById("overlay");
                            // null == t || t.remove();
                            var e = document.createElement("div"),
                                i = document.body;
                            null == i || i.appendChild(e);
                            var n = {
                                    _v: !1
                                },
                                o = new c,
                                h = new u(45, window.innerWidth / window.innerHeight, 1, 2e3),
                                T = new d;
                            T.background = new p(new b(16777215, 0)), T.add(new m(30, 0));
                            var E = new f;
                            h.add(E), T.add(h);
                            var I = new g(new b(11184810, 0), 3);
                            T.add(I);
                            var L = new v(new b(16777215, 0), 3);
                            L.position.set(-1, 1, 1).normalize(), T.add(L);
                            var U = new _(w([S("antialias", !0)]));
                            U.setPixelRatio(window.devicePixelRatio), U.setSize(window.innerWidth, window.innerHeight), e.appendChild(U.domElement);
                            var D, O, B, z, F, k, V, H, G, W, j = (N(), l)((N(), r), U),
                                X = w([S("delayTime", 160 / 30)]),
                                q = A()((N(), a)),
                                Y = A()((N(), s)),
                                J = (D = {
                                    _v: null
                                }, O = q, B = Y, z = [mmdinfo.an.camera], F = h, k = mmdinfo.audio, V = E, H = X, G = T, W = n, function(t) {
                                    D._v = t.mesh, O.add(D._v, w([S("animation", t.animation), S("physics", !0)]));
                                    var e = function(t, e, i, n, r, s, a, o) {
                                        return function(l) {
                                            t.add(e, w([S("animation", l)]));
                                            var h = new x,
                                                c = function(t, e, i, n, r, s) {
                                                    return function(a) {
                                                        var o = new y(t).setBuffer(a);
                                                        return e.add(o, i), n.add(r._v), s._v = !0, M
                                                    }
                                                }(n, t, r, s, a, o);
                                            return h.load(i, c, C), M
                                        }
                                    }(O, F, k, V, H, G, D, W);
                                    console.log("F:");
                                    console.log(F);
                                    return B.loadAnimation(z, F, e, R)
                                });
                            Y.loadWithAnimation(mmdinfo.model.file, [mmdinfo.an.model], J, P), window.addEventListener("resize", function(t, e) {
                                return function(i) {
                                    return t.aspect = window.innerWidth / window.innerHeight, t.updateProjectionMatrix(), e.setSize(window.innerWidth, window.innerHeight), M
                                }
                            }(h, j)), U.setAnimationLoop(function(t, e, i, n, r, s) {
                                return function() {
                                    return t._v && e.update(i.getDelta()), n.render(r, s), M
                                }
                            }(n, q, o, j, T, h))
                        }

                        function C(t) {
                            return N(), T(t), M
                        }

                        function R(t) {
                            return N(), T(t), M
                        }

                        function P(t) {
                            return N(), T(t), M
                        }

                        function I(t) {
                            return N(), Ammo().then(L), M
                        }

                        function L(t) {
                            return N(), E(), M
                        }

                        function U(t) {
                            N();
                            var e = document.body;
                            return null == e || e.requestFullscreen(), M
                        }

                        function N() {
                            h || (h = !0, r = i(489).s, s = i(520).a, a = i(266).$, o = function(t) {
                                return new t
                            }, l = function(t, e) {
                                return new t(e)
                            })
                        }
                        return function() {
                            N();
                            var t = document.querySelector("#startButton");
                            null == t || t.addEventListener("click", (function() {
                                let menu = document.querySelector("#menu");
                                menu.style.top = "-200%";
                                menu.style.opacity = "0";
                                setTimeout(I, 1500);
                            }));
                            var e = document.body;
                            null == e || e.addEventListener("dblclick", U)
                        }(), t
                    }) ? n.apply(e, r) : n) || (t.exports = s)
                },
                657: (t, e) => {
                    "use strict";
                    const i = "168",
                        n = 1,
                        r = 2,
                        s = 3,
                        a = 0,
                        o = 1,
                        l = 2,
                        h = 100,
                        c = 101,
                        u = 102,
                        d = 200,
                        p = 201,
                        m = 202,
                        f = 203,
                        g = 204,
                        v = 205,
                        _ = 206,
                        y = 207,
                        x = 208,
                        M = 209,
                        b = 210,
                        S = 211,
                        w = 212,
                        A = 213,
                        T = 214,
                        E = 0,
                        C = 1,
                        R = 2,
                        P = 0,
                        I = 1,
                        L = 2,
                        U = 3,
                        N = 4,
                        D = 5,
                        O = 6,
                        B = 7,
                        z = "attached",
                        F = "detached",
                        k = 300,
                        V = 301,
                        H = 302,
                        G = 303,
                        W = 304,
                        j = 306,
                        X = 1e3,
                        q = 1001,
                        Y = 1002,
                        J = 1003,
                        Z = 1004,
                        K = 1005,
                        Q = 1006,
                        $ = 1007,
                        tt = 1008,
                        et = 1009,
                        it = 1010,
                        nt = 1011,
                        rt = 1012,
                        st = 1013,
                        at = 1014,
                        ot = 1015,
                        lt = 1016,
                        ht = 1017,
                        ct = 1018,
                        ut = 1020,
                        dt = 35902,
                        pt = 1021,
                        mt = 1022,
                        ft = 1023,
                        gt = 1024,
                        vt = 1025,
                        _t = 1026,
                        yt = 1027,
                        xt = 1028,
                        Mt = 1029,
                        bt = 1030,
                        St = 1031,
                        wt = 1033,
                        At = 33776,
                        Tt = 33777,
                        Et = 33778,
                        Ct = 33779,
                        Rt = 35840,
                        Pt = 35841,
                        It = 35842,
                        Lt = 35843,
                        Ut = 36196,
                        Nt = 37492,
                        Dt = 37496,
                        Ot = 37808,
                        Bt = 37809,
                        zt = 37810,
                        Ft = 37811,
                        kt = 37812,
                        Vt = 37813,
                        Ht = 37814,
                        Gt = 37815,
                        Wt = 37816,
                        jt = 37817,
                        Xt = 37818,
                        qt = 37819,
                        Yt = 37820,
                        Jt = 37821,
                        Zt = 36492,
                        Kt = 36494,
                        Qt = 36495,
                        $t = 36283,
                        te = 36284,
                        ee = 36285,
                        ie = 36286,
                        ne = 2300,
                        re = 2301,
                        se = 2302,
                        ae = 2400,
                        oe = 2401,
                        le = 2402,
                        he = 2501,
                        ce = "",
                        ue = "srgb",
                        de = "srgb-linear",
                        pe = "display-p3",
                        me = "display-p3-linear",
                        fe = "linear",
                        ge = "srgb",
                        ve = "rec709",
                        _e = "p3",
                        ye = 7680,
                        xe = 512,
                        Me = 513,
                        be = 514,
                        Se = 515,
                        we = 516,
                        Ae = 517,
                        Te = 518,
                        Ee = 519,
                        Ce = 35044,
                        Re = "300 es",
                        Pe = 2e3,
                        Ie = 2001;
                    class Le {
                        addEventListener(t, e) {
                            void 0 === this._listeners && (this._listeners = {});
                            const i = this._listeners;
                            void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                        }
                        hasEventListener(t, e) {
                            if (void 0 === this._listeners) return !1;
                            const i = this._listeners;
                            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                        }
                        removeEventListener(t, e) {
                            if (void 0 === this._listeners) return;
                            const i = this._listeners[t];
                            if (void 0 !== i) {
                                const t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
                            }
                        }
                        dispatchEvent(t) {
                            if (void 0 === this._listeners) return;
                            const e = this._listeners[t.type];
                            if (void 0 !== e) {
                                t.target = this;
                                const i = e.slice(0);
                                for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
                                t.target = null
                            }
                        }
                    }
                    const Ue = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                    let Ne = 1234567;
                    const De = Math.PI / 180,
                        Oe = 180 / Math.PI;

                    function Be() {
                        const t = 4294967295 * Math.random() | 0,
                            e = 4294967295 * Math.random() | 0,
                            i = 4294967295 * Math.random() | 0,
                            n = 4294967295 * Math.random() | 0;
                        return (Ue[255 & t] + Ue[t >> 8 & 255] + Ue[t >> 16 & 255] + Ue[t >> 24 & 255] + "-" + Ue[255 & e] + Ue[e >> 8 & 255] + "-" + Ue[e >> 16 & 15 | 64] + Ue[e >> 24 & 255] + "-" + Ue[63 & i | 128] + Ue[i >> 8 & 255] + "-" + Ue[i >> 16 & 255] + Ue[i >> 24 & 255] + Ue[255 & n] + Ue[n >> 8 & 255] + Ue[n >> 16 & 255] + Ue[n >> 24 & 255]).toLowerCase()
                    }

                    function ze(t, e, i) {
                        return Math.max(e, Math.min(i, t))
                    }

                    function Fe(t, e) {
                        return (t % e + e) % e
                    }

                    function ke(t, e, i) {
                        return (1 - i) * t + i * e
                    }

                    function Ve(t, e) {
                        switch (e.constructor) {
                            case Float32Array:
                                return t;
                            case Uint32Array:
                                return t / 4294967295;
                            case Uint16Array:
                                return t / 65535;
                            case Uint8Array:
                                return t / 255;
                            case Int32Array:
                                return Math.max(t / 2147483647, -1);
                            case Int16Array:
                                return Math.max(t / 32767, -1);
                            case Int8Array:
                                return Math.max(t / 127, -1);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }

                    function He(t, e) {
                        switch (e.constructor) {
                            case Float32Array:
                                return t;
                            case Uint32Array:
                                return Math.round(4294967295 * t);
                            case Uint16Array:
                                return Math.round(65535 * t);
                            case Uint8Array:
                                return Math.round(255 * t);
                            case Int32Array:
                                return Math.round(2147483647 * t);
                            case Int16Array:
                                return Math.round(32767 * t);
                            case Int8Array:
                                return Math.round(127 * t);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }
                    const Ge = {
                        DEG2RAD: De,
                        RAD2DEG: Oe,
                        generateUUID: Be,
                        clamp: ze,
                        euclideanModulo: Fe,
                        mapLinear: function(t, e, i, n, r) {
                            return n + (t - e) * (r - n) / (i - e)
                        },
                        inverseLerp: function(t, e, i) {
                            return t !== e ? (i - t) / (e - t) : 0
                        },
                        lerp: ke,
                        damp: function(t, e, i, n) {
                            return ke(t, e, 1 - Math.exp(-i * n))
                        },
                        pingpong: function(t, e = 1) {
                            return e - Math.abs(Fe(t, 2 * e) - e)
                        },
                        smoothstep: function(t, e, i) {
                            return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                        },
                        smootherstep: function(t, e, i) {
                            return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                        },
                        randInt: function(t, e) {
                            return t + Math.floor(Math.random() * (e - t + 1))
                        },
                        randFloat: function(t, e) {
                            return t + Math.random() * (e - t)
                        },
                        randFloatSpread: function(t) {
                            return t * (.5 - Math.random())
                        },
                        seededRandom: function(t) {
                            void 0 !== t && (Ne = t);
                            let e = Ne += 1831565813;
                            return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
                        },
                        degToRad: function(t) {
                            return t * De
                        },
                        radToDeg: function(t) {
                            return t * Oe
                        },
                        isPowerOfTwo: function(t) {
                            return !(t & t - 1) && 0 !== t
                        },
                        ceilPowerOfTwo: function(t) {
                            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                        },
                        floorPowerOfTwo: function(t) {
                            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                        },
                        setQuaternionFromProperEuler: function(t, e, i, n, r) {
                            const s = Math.cos,
                                a = Math.sin,
                                o = s(i / 2),
                                l = a(i / 2),
                                h = s((e + n) / 2),
                                c = a((e + n) / 2),
                                u = s((e - n) / 2),
                                d = a((e - n) / 2),
                                p = s((n - e) / 2),
                                m = a((n - e) / 2);
                            switch (r) {
                                case "XYX":
                                    t.set(o * c, l * u, l * d, o * h);
                                    break;
                                case "YZY":
                                    t.set(l * d, o * c, l * u, o * h);
                                    break;
                                case "ZXZ":
                                    t.set(l * u, l * d, o * c, o * h);
                                    break;
                                case "XZX":
                                    t.set(o * c, l * m, l * p, o * h);
                                    break;
                                case "YXY":
                                    t.set(l * p, o * c, l * m, o * h);
                                    break;
                                case "ZYZ":
                                    t.set(l * m, l * p, o * c, o * h);
                                    break;
                                default:
                                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                            }
                        },
                        normalize: He,
                        denormalize: Ve
                    };
                    class We {
                        constructor(t = 0, e = 0) {
                            We.prototype.isVector2 = !0, this.x = t, this.y = e
                        }
                        get width() {
                            return this.x
                        }
                        set width(t) {
                            this.x = t
                        }
                        get height() {
                            return this.y
                        }
                        set height(t) {
                            this.y = t
                        }
                        set(t, e) {
                            return this.x = t, this.y = e, this
                        }
                        setScalar(t) {
                            return this.x = t, this.y = t, this
                        }
                        setX(t) {
                            return this.x = t, this
                        }
                        setY(t) {
                            return this.y = t, this
                        }
                        setComponent(t, e) {
                            switch (t) {
                                case 0:
                                    this.x = e;
                                    break;
                                case 1:
                                    this.y = e;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                            return this
                        }
                        getComponent(t) {
                            switch (t) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x, this.y)
                        }
                        copy(t) {
                            return this.x = t.x, this.y = t.y, this
                        }
                        add(t) {
                            return this.x += t.x, this.y += t.y, this
                        }
                        addScalar(t) {
                            return this.x += t, this.y += t, this
                        }
                        addVectors(t, e) {
                            return this.x = t.x + e.x, this.y = t.y + e.y, this
                        }
                        addScaledVector(t, e) {
                            return this.x += t.x * e, this.y += t.y * e, this
                        }
                        sub(t) {
                            return this.x -= t.x, this.y -= t.y, this
                        }
                        subScalar(t) {
                            return this.x -= t, this.y -= t, this
                        }
                        subVectors(t, e) {
                            return this.x = t.x - e.x, this.y = t.y - e.y, this
                        }
                        multiply(t) {
                            return this.x *= t.x, this.y *= t.y, this
                        }
                        multiplyScalar(t) {
                            return this.x *= t, this.y *= t, this
                        }
                        divide(t) {
                            return this.x /= t.x, this.y /= t.y, this
                        }
                        divideScalar(t) {
                            return this.multiplyScalar(1 / t)
                        }
                        applyMatrix3(t) {
                            const e = this.x,
                                i = this.y,
                                n = t.elements;
                            return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                        }
                        min(t) {
                            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                        }
                        max(t) {
                            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                        }
                        clamp(t, e) {
                            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                        }
                        clampScalar(t, e) {
                            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                        }
                        clampLength(t, e) {
                            const i = this.length();
                            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                        }
                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                        }
                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                        }
                        negate() {
                            return this.x = -this.x, this.y = -this.y, this
                        }
                        dot(t) {
                            return this.x * t.x + this.y * t.y
                        }
                        cross(t) {
                            return this.x * t.y - this.y * t.x
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        angle() {
                            return Math.atan2(-this.y, -this.x) + Math.PI
                        }
                        angleTo(t) {
                            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                            if (0 === e) return Math.PI / 2;
                            const i = this.dot(t) / e;
                            return Math.acos(ze(i, -1, 1))
                        }
                        distanceTo(t) {
                            return Math.sqrt(this.distanceToSquared(t))
                        }
                        distanceToSquared(t) {
                            const e = this.x - t.x,
                                i = this.y - t.y;
                            return e * e + i * i
                        }
                        manhattanDistanceTo(t) {
                            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                        }
                        setLength(t) {
                            return this.normalize().multiplyScalar(t)
                        }
                        lerp(t, e) {
                            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                        }
                        lerpVectors(t, e, i) {
                            return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
                        }
                        equals(t) {
                            return t.x === this.x && t.y === this.y
                        }
                        fromArray(t, e = 0) {
                            return this.x = t[e], this.y = t[e + 1], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.x, t[e + 1] = this.y, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.x = t.getX(e), this.y = t.getY(e), this
                        }
                        rotateAround(t, e) {
                            const i = Math.cos(e),
                                n = Math.sin(e),
                                r = this.x - t.x,
                                s = this.y - t.y;
                            return this.x = r * i - s * n + t.x, this.y = r * n + s * i + t.y, this
                        }
                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this
                        }*[Symbol.iterator]() {
                            yield this.x, yield this.y
                        }
                    }
                    class je {
                        constructor(t, e, i, n, r, s, a, o, l) {
                            je.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, i, n, r, s, a, o, l)
                        }
                        set(t, e, i, n, r, s, a, o, l) {
                            const h = this.elements;
                            return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = s, h[8] = l, this
                        }
                        identity() {
                            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                        }
                        copy(t) {
                            const e = this.elements,
                                i = t.elements;
                            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                        }
                        extractBasis(t, e, i) {
                            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                        }
                        setFromMatrix4(t) {
                            const e = t.elements;
                            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                        }
                        multiply(t) {
                            return this.multiplyMatrices(this, t)
                        }
                        premultiply(t) {
                            return this.multiplyMatrices(t, this)
                        }
                        multiplyMatrices(t, e) {
                            const i = t.elements,
                                n = e.elements,
                                r = this.elements,
                                s = i[0],
                                a = i[3],
                                o = i[6],
                                l = i[1],
                                h = i[4],
                                c = i[7],
                                u = i[2],
                                d = i[5],
                                p = i[8],
                                m = n[0],
                                f = n[3],
                                g = n[6],
                                v = n[1],
                                _ = n[4],
                                y = n[7],
                                x = n[2],
                                M = n[5],
                                b = n[8];
                            return r[0] = s * m + a * v + o * x, r[3] = s * f + a * _ + o * M, r[6] = s * g + a * y + o * b, r[1] = l * m + h * v + c * x, r[4] = l * f + h * _ + c * M, r[7] = l * g + h * y + c * b, r[2] = u * m + d * v + p * x, r[5] = u * f + d * _ + p * M, r[8] = u * g + d * y + p * b, this
                        }
                        multiplyScalar(t) {
                            const e = this.elements;
                            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                        }
                        determinant() {
                            const t = this.elements,
                                e = t[0],
                                i = t[1],
                                n = t[2],
                                r = t[3],
                                s = t[4],
                                a = t[5],
                                o = t[6],
                                l = t[7],
                                h = t[8];
                            return e * s * h - e * a * l - i * r * h + i * a * o + n * r * l - n * s * o
                        }
                        invert() {
                            const t = this.elements,
                                e = t[0],
                                i = t[1],
                                n = t[2],
                                r = t[3],
                                s = t[4],
                                a = t[5],
                                o = t[6],
                                l = t[7],
                                h = t[8],
                                c = h * s - a * l,
                                u = a * o - h * r,
                                d = l * r - s * o,
                                p = e * c + i * u + n * d;
                            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const m = 1 / p;
                            return t[0] = c * m, t[1] = (n * l - h * i) * m, t[2] = (a * i - n * s) * m, t[3] = u * m, t[4] = (h * e - n * o) * m, t[5] = (n * r - a * e) * m, t[6] = d * m, t[7] = (i * o - l * e) * m, t[8] = (s * e - i * r) * m, this
                        }
                        transpose() {
                            let t;
                            const e = this.elements;
                            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                        }
                        getNormalMatrix(t) {
                            return this.setFromMatrix4(t).invert().transpose()
                        }
                        transposeIntoArray(t) {
                            const e = this.elements;
                            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                        }
                        setUvTransform(t, e, i, n, r, s, a) {
                            const o = Math.cos(r),
                                l = Math.sin(r);
                            return this.set(i * o, i * l, -i * (o * s + l * a) + s + t, -n * l, n * o, -n * (-l * s + o * a) + a + e, 0, 0, 1), this
                        }
                        scale(t, e) {
                            return this.premultiply(Xe.makeScale(t, e)), this
                        }
                        rotate(t) {
                            return this.premultiply(Xe.makeRotation(-t)), this
                        }
                        translate(t, e) {
                            return this.premultiply(Xe.makeTranslation(t, e)), this
                        }
                        makeTranslation(t, e) {
                            return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
                        }
                        makeRotation(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this
                        }
                        makeScale(t, e) {
                            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
                        }
                        equals(t) {
                            const e = this.elements,
                                i = t.elements;
                            for (let t = 0; t < 9; t++)
                                if (e[t] !== i[t]) return !1;
                            return !0
                        }
                        fromArray(t, e = 0) {
                            for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                            return this
                        }
                        toArray(t = [], e = 0) {
                            const i = this.elements;
                            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                        }
                        clone() {
                            return (new this.constructor).fromArray(this.elements)
                        }
                    }
                    const Xe = new je;

                    function qe(t) {
                        for (let e = t.length - 1; e >= 0; --e)
                            if (t[e] >= 65535) return !0;
                        return !1
                    }
                    const Ye = {
                        Int8Array,
                        Uint8Array,
                        Uint8ClampedArray,
                        Int16Array,
                        Uint16Array,
                        Int32Array,
                        Uint32Array,
                        Float32Array,
                        Float64Array
                    };

                    function Je(t, e) {
                        return new Ye[t](e)
                    }

                    function Ze(t) {
                        return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                    }

                    function Ke() {
                        const t = Ze("canvas");
                        return t.style.display = "block", t
                    }
                    const Qe = {};

                    function $e(t) {
                        t in Qe || (Qe[t] = !0, console.warn(t))
                    }
                    const ti = (new je).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
                        ei = (new je).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
                        ii = {
                            [de]: {
                                transfer: fe,
                                primaries: ve,
                                luminanceCoefficients: [.2126, .7152, .0722],
                                toReference: t => t,
                                fromReference: t => t
                            },
                            [ue]: {
                                transfer: ge,
                                primaries: ve,
                                luminanceCoefficients: [.2126, .7152, .0722],
                                toReference: t => t.convertSRGBToLinear(),
                                fromReference: t => t.convertLinearToSRGB()
                            },
                            [me]: {
                                transfer: fe,
                                primaries: _e,
                                luminanceCoefficients: [.2289, .6917, .0793],
                                toReference: t => t.applyMatrix3(ei),
                                fromReference: t => t.applyMatrix3(ti)
                            },
                            [pe]: {
                                transfer: ge,
                                primaries: _e,
                                luminanceCoefficients: [.2289, .6917, .0793],
                                toReference: t => t.convertSRGBToLinear().applyMatrix3(ei),
                                fromReference: t => t.applyMatrix3(ti).convertLinearToSRGB()
                            }
                        },
                        ni = new Set([de, me]),
                        ri = {
                            enabled: !0,
                            _workingColorSpace: de,
                            get workingColorSpace() {
                                return this._workingColorSpace
                            },
                            set workingColorSpace(t) {
                                if (!ni.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
                                this._workingColorSpace = t
                            },
                            convert: function(t, e, i) {
                                if (!1 === this.enabled || e === i || !e || !i) return t;
                                const n = ii[e].toReference;
                                return (0, ii[i].fromReference)(n(t))
                            },
                            fromWorkingColorSpace: function(t, e) {
                                return this.convert(t, this._workingColorSpace, e)
                            },
                            toWorkingColorSpace: function(t, e) {
                                return this.convert(t, e, this._workingColorSpace)
                            },
                            getPrimaries: function(t) {
                                return ii[t].primaries
                            },
                            getTransfer: function(t) {
                                return t === ce ? fe : ii[t].transfer
                            },
                            getLuminanceCoefficients: function(t, e = this._workingColorSpace) {
                                return t.fromArray(ii[e].luminanceCoefficients)
                            }
                        };

                    function si(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }

                    function ai(t) {
                        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                    }
                    let oi;
                    class li {
                        static getDataURL(t) {
                            if (/^data:/i.test(t.src)) return t.src;
                            if ("undefined" == typeof HTMLCanvasElement) return t.src;
                            let e;
                            if (t instanceof HTMLCanvasElement) e = t;
                            else {
                                void 0 === oi && (oi = Ze("canvas")), oi.width = t.width, oi.height = t.height;
                                const i = oi.getContext("2d");
                                t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = oi
                            }
                            return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                        }
                        static sRGBToLinear(t) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const e = Ze("canvas");
                                e.width = t.width, e.height = t.height;
                                const i = e.getContext("2d");
                                i.drawImage(t, 0, 0, t.width, t.height);
                                const n = i.getImageData(0, 0, t.width, t.height),
                                    r = n.data;
                                for (let t = 0; t < r.length; t++) r[t] = 255 * si(r[t] / 255);
                                return i.putImageData(n, 0, 0), e
                            }
                            if (t.data) {
                                const e = t.data.slice(0);
                                for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * si(e[t] / 255)) : e[t] = si(e[t]);
                                return {
                                    data: e,
                                    width: t.width,
                                    height: t.height
                                }
                            }
                            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                        }
                    }
                    let hi = 0;
                    class ci {
                        constructor(t = null) {
                            this.isSource = !0, Object.defineProperty(this, "id", {
                                value: hi++
                            }), this.uuid = Be(), this.data = t, this.dataReady = !0, this.version = 0
                        }
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t;
                            if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                            const i = {
                                    uuid: this.uuid,
                                    url: ""
                                },
                                n = this.data;
                            if (null !== n) {
                                let t;
                                if (Array.isArray(n)) {
                                    t = [];
                                    for (let e = 0, i = n.length; e < i; e++) n[e].isDataTexture ? t.push(ui(n[e].image)) : t.push(ui(n[e]))
                                } else t = ui(n);
                                i.url = t
                            }
                            return e || (t.images[this.uuid] = i), i
                        }
                    }

                    function ui(t) {
                        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? li.getDataURL(t) : t.data ? {
                            data: Array.from(t.data),
                            width: t.width,
                            height: t.height,
                            type: t.data.constructor.name
                        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                    }
                    let di = 0;
                    class pi extends Le {
                        constructor(t = pi.DEFAULT_IMAGE, e = pi.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, s = 1008, a = ft, o = et, l = pi.DEFAULT_ANISOTROPY, h = "") {
                            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                                value: di++
                            }), this.uuid = Be(), this.name = "", this.source = new ci(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new We(0, 0), this.repeat = new We(1, 1), this.center = new We(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new je, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
                        }
                        get image() {
                            return this.source.data
                        }
                        set image(t = null) {
                            this.source.data = t
                        }
                        updateMatrix() {
                            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t;
                            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                            const i = {
                                metadata: {
                                    version: 4.6,
                                    type: "Texture",
                                    generator: "Texture.toJSON"
                                },
                                uuid: this.uuid,
                                name: this.name,
                                image: this.source.toJSON(t).uuid,
                                mapping: this.mapping,
                                channel: this.channel,
                                repeat: [this.repeat.x, this.repeat.y],
                                offset: [this.offset.x, this.offset.y],
                                center: [this.center.x, this.center.y],
                                rotation: this.rotation,
                                wrap: [this.wrapS, this.wrapT],
                                format: this.format,
                                internalFormat: this.internalFormat,
                                type: this.type,
                                colorSpace: this.colorSpace,
                                minFilter: this.minFilter,
                                magFilter: this.magFilter,
                                anisotropy: this.anisotropy,
                                flipY: this.flipY,
                                generateMipmaps: this.generateMipmaps,
                                premultiplyAlpha: this.premultiplyAlpha,
                                unpackAlignment: this.unpackAlignment
                            };
                            return Object.keys(this.userData).length > 0 && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                        transformUv(t) {
                            if (this.mapping !== k) return t;
                            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                                case X:
                                    t.x = t.x - Math.floor(t.x);
                                    break;
                                case q:
                                    t.x = t.x < 0 ? 0 : 1;
                                    break;
                                case Y:
                                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                            }
                            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                                case X:
                                    t.y = t.y - Math.floor(t.y);
                                    break;
                                case q:
                                    t.y = t.y < 0 ? 0 : 1;
                                    break;
                                case Y:
                                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                            }
                            return this.flipY && (t.y = 1 - t.y), t
                        }
                        set needsUpdate(t) {
                            !0 === t && (this.version++, this.source.needsUpdate = !0)
                        }
                        set needsPMREMUpdate(t) {
                            !0 === t && this.pmremVersion++
                        }
                    }
                    pi.DEFAULT_IMAGE = null, pi.DEFAULT_MAPPING = k, pi.DEFAULT_ANISOTROPY = 1;
                    class mi {
                        constructor(t = 0, e = 0, i = 0, n = 1) {
                            mi.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = i, this.w = n
                        }
                        get width() {
                            return this.z
                        }
                        set width(t) {
                            this.z = t
                        }
                        get height() {
                            return this.w
                        }
                        set height(t) {
                            this.w = t
                        }
                        set(t, e, i, n) {
                            return this.x = t, this.y = e, this.z = i, this.w = n, this
                        }
                        setScalar(t) {
                            return this.x = t, this.y = t, this.z = t, this.w = t, this
                        }
                        setX(t) {
                            return this.x = t, this
                        }
                        setY(t) {
                            return this.y = t, this
                        }
                        setZ(t) {
                            return this.z = t, this
                        }
                        setW(t) {
                            return this.w = t, this
                        }
                        setComponent(t, e) {
                            switch (t) {
                                case 0:
                                    this.x = e;
                                    break;
                                case 1:
                                    this.y = e;
                                    break;
                                case 2:
                                    this.z = e;
                                    break;
                                case 3:
                                    this.w = e;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                            return this
                        }
                        getComponent(t) {
                            switch (t) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                case 3:
                                    return this.w;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x, this.y, this.z, this.w)
                        }
                        copy(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                        }
                        add(t) {
                            return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
                        }
                        addScalar(t) {
                            return this.x += t, this.y += t, this.z += t, this.w += t, this
                        }
                        addVectors(t, e) {
                            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                        }
                        addScaledVector(t, e) {
                            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                        }
                        sub(t) {
                            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
                        }
                        subScalar(t) {
                            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                        }
                        subVectors(t, e) {
                            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                        }
                        multiply(t) {
                            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                        }
                        multiplyScalar(t) {
                            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                        }
                        applyMatrix4(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = this.w,
                                s = t.elements;
                            return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r, this
                        }
                        divideScalar(t) {
                            return this.multiplyScalar(1 / t)
                        }
                        setAxisAngleFromQuaternion(t) {
                            this.w = 2 * Math.acos(t.w);
                            const e = Math.sqrt(1 - t.w * t.w);
                            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                        }
                        setAxisAngleFromRotationMatrix(t) {
                            let e, i, n, r;
                            const s = .01,
                                a = .1,
                                o = t.elements,
                                l = o[0],
                                h = o[4],
                                c = o[8],
                                u = o[1],
                                d = o[5],
                                p = o[9],
                                m = o[2],
                                f = o[6],
                                g = o[10];
                            if (Math.abs(h - u) < s && Math.abs(c - m) < s && Math.abs(p - f) < s) {
                                if (Math.abs(h + u) < a && Math.abs(c + m) < a && Math.abs(p + f) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                                e = Math.PI;
                                const t = (l + 1) / 2,
                                    o = (d + 1) / 2,
                                    v = (g + 1) / 2,
                                    _ = (h + u) / 4,
                                    y = (c + m) / 4,
                                    x = (p + f) / 4;
                                return t > o && t > v ? t < s ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(t), n = _ / i, r = y / i) : o > v ? o < s ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(o), i = _ / n, r = x / n) : v < s ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(v), i = y / r, n = x / r), this.set(i, n, r, e), this
                            }
                            let v = Math.sqrt((f - p) * (f - p) + (c - m) * (c - m) + (u - h) * (u - h));
                            return Math.abs(v) < .001 && (v = 1), this.x = (f - p) / v, this.y = (c - m) / v, this.z = (u - h) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                        }
                        setFromMatrixPosition(t) {
                            const e = t.elements;
                            return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this
                        }
                        min(t) {
                            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                        }
                        max(t) {
                            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                        }
                        clamp(t, e) {
                            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                        }
                        clampScalar(t, e) {
                            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                        }
                        clampLength(t, e) {
                            const i = this.length();
                            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                        }
                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                        }
                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                        }
                        negate() {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                        }
                        dot(t) {
                            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        setLength(t) {
                            return this.normalize().multiplyScalar(t)
                        }
                        lerp(t, e) {
                            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                        }
                        lerpVectors(t, e, i) {
                            return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
                        }
                        equals(t) {
                            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                        }
                        fromArray(t, e = 0) {
                            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                        }
                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                        }*[Symbol.iterator]() {
                            yield this.x, yield this.y, yield this.z, yield this.w
                        }
                    }
                    class fi extends Le {
                        constructor(t = 1, e = 1, i = {}) {
                            super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new mi(0, 0, t, e), this.scissorTest = !1, this.viewport = new mi(0, 0, t, e);
                            const n = {
                                width: t,
                                height: e,
                                depth: 1
                            };
                            i = Object.assign({
                                generateMipmaps: !1,
                                internalFormat: null,
                                minFilter: Q,
                                depthBuffer: !0,
                                stencilBuffer: !1,
                                resolveDepthBuffer: !0,
                                resolveStencilBuffer: !0,
                                depthTexture: null,
                                samples: 0,
                                count: 1
                            }, i);
                            const r = new pi(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
                            r.flipY = !1, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
                            const s = i.count;
                            for (let t = 0; t < s; t++) this.textures[t] = r.clone(), this.textures[t].isRenderTargetTexture = !0;
                            this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples
                        }
                        get texture() {
                            return this.textures[0]
                        }
                        set texture(t) {
                            this.textures[0] = t
                        }
                        setSize(t, e, i = 1) {
                            if (this.width !== t || this.height !== e || this.depth !== i) {
                                this.width = t, this.height = e, this.depth = i;
                                for (let n = 0, r = this.textures.length; n < r; n++) this.textures[n].image.width = t, this.textures[n].image.height = e, this.textures[n].image.depth = i;
                                this.dispose()
                            }
                            this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
                            for (let e = 0, i = t.textures.length; e < i; e++) this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0;
                            const e = Object.assign({}, t.texture.image);
                            return this.texture.source = new ci(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }
                    class gi extends fi {
                        constructor(t = 1, e = 1, i = {}) {
                            super(t, e, i), this.isWebGLRenderTarget = !0
                        }
                    }
                    class vi extends pi {
                        constructor(t = null, e = 1, i = 1, n = 1) {
                            super(null), this.isDataArrayTexture = !0, this.image = {
                                data: t,
                                width: e,
                                height: i,
                                depth: n
                            }, this.magFilter = J, this.minFilter = J, this.wrapR = q, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
                        }
                        addLayerUpdate(t) {
                            this.layerUpdates.add(t)
                        }
                        clearLayerUpdates() {
                            this.layerUpdates.clear()
                        }
                    }
                    class _i extends pi {
                        constructor(t = null, e = 1, i = 1, n = 1) {
                            super(null), this.isData3DTexture = !0, this.image = {
                                data: t,
                                width: e,
                                height: i,
                                depth: n
                            }, this.magFilter = J, this.minFilter = J, this.wrapR = q, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                        }
                    }
                    class yi {
                        constructor(t = 0, e = 0, i = 0, n = 1) {
                            this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = n
                        }
                        static slerpFlat(t, e, i, n, r, s, a) {
                            let o = i[n + 0],
                                l = i[n + 1],
                                h = i[n + 2],
                                c = i[n + 3];
                            const u = r[s + 0],
                                d = r[s + 1],
                                p = r[s + 2],
                                m = r[s + 3];
                            if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = h, void(t[e + 3] = c);
                            if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                            if (c !== m || o !== u || l !== d || h !== p) {
                                let t = 1 - a;
                                const e = o * u + l * d + h * p + c * m,
                                    i = e >= 0 ? 1 : -1,
                                    n = 1 - e * e;
                                if (n > Number.EPSILON) {
                                    const r = Math.sqrt(n),
                                        s = Math.atan2(r, e * i);
                                    t = Math.sin(t * s) / r, a = Math.sin(a * s) / r
                                }
                                const r = a * i;
                                if (o = o * t + u * r, l = l * t + d * r, h = h * t + p * r, c = c * t + m * r, t === 1 - a) {
                                    const t = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
                                    o *= t, l *= t, h *= t, c *= t
                                }
                            }
                            t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
                        }
                        static multiplyQuaternionsFlat(t, e, i, n, r, s) {
                            const a = i[n],
                                o = i[n + 1],
                                l = i[n + 2],
                                h = i[n + 3],
                                c = r[s],
                                u = r[s + 1],
                                d = r[s + 2],
                                p = r[s + 3];
                            return t[e] = a * p + h * c + o * d - l * u, t[e + 1] = o * p + h * u + l * c - a * d, t[e + 2] = l * p + h * d + a * u - o * c, t[e + 3] = h * p - a * c - o * u - l * d, t
                        }
                        get x() {
                            return this._x
                        }
                        set x(t) {
                            this._x = t, this._onChangeCallback()
                        }
                        get y() {
                            return this._y
                        }
                        set y(t) {
                            this._y = t, this._onChangeCallback()
                        }
                        get z() {
                            return this._z
                        }
                        set z(t) {
                            this._z = t, this._onChangeCallback()
                        }
                        get w() {
                            return this._w
                        }
                        set w(t) {
                            this._w = t, this._onChangeCallback()
                        }
                        set(t, e, i, n) {
                            return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
                        }
                        clone() {
                            return new this.constructor(this._x, this._y, this._z, this._w)
                        }
                        copy(t) {
                            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                        }
                        setFromEuler(t, e = !0) {
                            const i = t._x,
                                n = t._y,
                                r = t._z,
                                s = t._order,
                                a = Math.cos,
                                o = Math.sin,
                                l = a(i / 2),
                                h = a(n / 2),
                                c = a(r / 2),
                                u = o(i / 2),
                                d = o(n / 2),
                                p = o(r / 2);
                            switch (s) {
                                case "XYZ":
                                    this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                                    break;
                                case "YXZ":
                                    this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                                    break;
                                case "ZXY":
                                    this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                                    break;
                                case "ZYX":
                                    this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                                    break;
                                case "YZX":
                                    this._x = u * h * c + l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c - u * d * p;
                                    break;
                                case "XZY":
                                    this._x = u * h * c - l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c + u * d * p;
                                    break;
                                default:
                                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                            }
                            return !0 === e && this._onChangeCallback(), this
                        }
                        setFromAxisAngle(t, e) {
                            const i = e / 2,
                                n = Math.sin(i);
                            return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                        }
                        setFromRotationMatrix(t) {
                            const e = t.elements,
                                i = e[0],
                                n = e[4],
                                r = e[8],
                                s = e[1],
                                a = e[5],
                                o = e[9],
                                l = e[2],
                                h = e[6],
                                c = e[10],
                                u = i + a + c;
                            if (u > 0) {
                                const t = .5 / Math.sqrt(u + 1);
                                this._w = .25 / t, this._x = (h - o) * t, this._y = (r - l) * t, this._z = (s - n) * t
                            } else if (i > a && i > c) {
                                const t = 2 * Math.sqrt(1 + i - a - c);
                                this._w = (h - o) / t, this._x = .25 * t, this._y = (n + s) / t, this._z = (r + l) / t
                            } else if (a > c) {
                                const t = 2 * Math.sqrt(1 + a - i - c);
                                this._w = (r - l) / t, this._x = (n + s) / t, this._y = .25 * t, this._z = (o + h) / t
                            } else {
                                const t = 2 * Math.sqrt(1 + c - i - a);
                                this._w = (s - n) / t, this._x = (r + l) / t, this._y = (o + h) / t, this._z = .25 * t
                            }
                            return this._onChangeCallback(), this
                        }
                        setFromUnitVectors(t, e) {
                            let i = t.dot(e) + 1;
                            return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize()
                        }
                        angleTo(t) {
                            return 2 * Math.acos(Math.abs(ze(this.dot(t), -1, 1)))
                        }
                        rotateTowards(t, e) {
                            const i = this.angleTo(t);
                            if (0 === i) return this;
                            const n = Math.min(1, e / i);
                            return this.slerp(t, n), this
                        }
                        identity() {
                            return this.set(0, 0, 0, 1)
                        }
                        invert() {
                            return this.conjugate()
                        }
                        conjugate() {
                            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                        }
                        dot(t) {
                            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                        }
                        lengthSq() {
                            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                        }
                        length() {
                            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                        }
                        normalize() {
                            let t = this.length();
                            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                        }
                        multiply(t) {
                            return this.multiplyQuaternions(this, t)
                        }
                        premultiply(t) {
                            return this.multiplyQuaternions(t, this)
                        }
                        multiplyQuaternions(t, e) {
                            const i = t._x,
                                n = t._y,
                                r = t._z,
                                s = t._w,
                                a = e._x,
                                o = e._y,
                                l = e._z,
                                h = e._w;
                            return this._x = i * h + s * a + n * l - r * o, this._y = n * h + s * o + r * a - i * l, this._z = r * h + s * l + i * o - n * a, this._w = s * h - i * a - n * o - r * l, this._onChangeCallback(), this
                        }
                        slerp(t, e) {
                            if (0 === e) return this;
                            if (1 === e) return this.copy(t);
                            const i = this._x,
                                n = this._y,
                                r = this._z,
                                s = this._w;
                            let a = s * t._w + i * t._x + n * t._y + r * t._z;
                            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                            const o = 1 - a * a;
                            if (o <= Number.EPSILON) {
                                const t = 1 - e;
                                return this._w = t * s + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * r + e * this._z, this.normalize(), this
                            }
                            const l = Math.sqrt(o),
                                h = Math.atan2(l, a),
                                c = Math.sin((1 - e) * h) / l,
                                u = Math.sin(e * h) / l;
                            return this._w = s * c + this._w * u, this._x = i * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this
                        }
                        slerpQuaternions(t, e, i) {
                            return this.copy(t).slerp(e, i)
                        }
                        random() {
                            const t = 2 * Math.PI * Math.random(),
                                e = 2 * Math.PI * Math.random(),
                                i = Math.random(),
                                n = Math.sqrt(1 - i),
                                r = Math.sqrt(i);
                            return this.set(n * Math.sin(t), n * Math.cos(t), r * Math.sin(e), r * Math.cos(e))
                        }
                        equals(t) {
                            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                        }
                        fromArray(t, e = 0) {
                            return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                        }
                        fromBufferAttribute(t, e) {
                            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
                        }
                        toJSON() {
                            return this.toArray()
                        }
                        _onChange(t) {
                            return this._onChangeCallback = t, this
                        }
                        _onChangeCallback() {}*[Symbol.iterator]() {
                            yield this._x, yield this._y, yield this._z, yield this._w
                        }
                    }
                    class xi {
                        constructor(t = 0, e = 0, i = 0) {
                            xi.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i
                        }
                        set(t, e, i) {
                            return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
                        }
                        setScalar(t) {
                            return this.x = t, this.y = t, this.z = t, this
                        }
                        setX(t) {
                            return this.x = t, this
                        }
                        setY(t) {
                            return this.y = t, this
                        }
                        setZ(t) {
                            return this.z = t, this
                        }
                        setComponent(t, e) {
                            switch (t) {
                                case 0:
                                    this.x = e;
                                    break;
                                case 1:
                                    this.y = e;
                                    break;
                                case 2:
                                    this.z = e;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                            return this
                        }
                        getComponent(t) {
                            switch (t) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x, this.y, this.z)
                        }
                        copy(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this
                        }
                        add(t) {
                            return this.x += t.x, this.y += t.y, this.z += t.z, this
                        }
                        addScalar(t) {
                            return this.x += t, this.y += t, this.z += t, this
                        }
                        addVectors(t, e) {
                            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                        }
                        addScaledVector(t, e) {
                            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                        }
                        sub(t) {
                            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
                        }
                        subScalar(t) {
                            return this.x -= t, this.y -= t, this.z -= t, this
                        }
                        subVectors(t, e) {
                            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                        }
                        multiply(t) {
                            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
                        }
                        multiplyScalar(t) {
                            return this.x *= t, this.y *= t, this.z *= t, this
                        }
                        multiplyVectors(t, e) {
                            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                        }
                        applyEuler(t) {
                            return this.applyQuaternion(bi.setFromEuler(t))
                        }
                        applyAxisAngle(t, e) {
                            return this.applyQuaternion(bi.setFromAxisAngle(t, e))
                        }
                        applyMatrix3(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.elements;
                            return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                        }
                        applyNormalMatrix(t) {
                            return this.applyMatrix3(t).normalize()
                        }
                        applyMatrix4(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.elements,
                                s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                            return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s, this
                        }
                        applyQuaternion(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.x,
                                s = t.y,
                                a = t.z,
                                o = t.w,
                                l = 2 * (s * n - a * i),
                                h = 2 * (a * e - r * n),
                                c = 2 * (r * i - s * e);
                            return this.x = e + o * l + s * c - a * h, this.y = i + o * h + a * l - r * c, this.z = n + o * c + r * h - s * l, this
                        }
                        project(t) {
                            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                        }
                        unproject(t) {
                            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                        }
                        transformDirection(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.elements;
                            return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                        }
                        divide(t) {
                            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                        }
                        divideScalar(t) {
                            return this.multiplyScalar(1 / t)
                        }
                        min(t) {
                            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                        }
                        max(t) {
                            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                        }
                        clamp(t, e) {
                            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                        }
                        clampScalar(t, e) {
                            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                        }
                        clampLength(t, e) {
                            const i = this.length();
                            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                        }
                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                        }
                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                        }
                        negate() {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                        }
                        dot(t) {
                            return this.x * t.x + this.y * t.y + this.z * t.z
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        setLength(t) {
                            return this.normalize().multiplyScalar(t)
                        }
                        lerp(t, e) {
                            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                        }
                        lerpVectors(t, e, i) {
                            return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
                        }
                        cross(t) {
                            return this.crossVectors(this, t)
                        }
                        crossVectors(t, e) {
                            const i = t.x,
                                n = t.y,
                                r = t.z,
                                s = e.x,
                                a = e.y,
                                o = e.z;
                            return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
                        }
                        projectOnVector(t) {
                            const e = t.lengthSq();
                            if (0 === e) return this.set(0, 0, 0);
                            const i = t.dot(this) / e;
                            return this.copy(t).multiplyScalar(i)
                        }
                        projectOnPlane(t) {
                            return Mi.copy(this).projectOnVector(t), this.sub(Mi)
                        }
                        reflect(t) {
                            return this.sub(Mi.copy(t).multiplyScalar(2 * this.dot(t)))
                        }
                        angleTo(t) {
                            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                            if (0 === e) return Math.PI / 2;
                            const i = this.dot(t) / e;
                            return Math.acos(ze(i, -1, 1))
                        }
                        distanceTo(t) {
                            return Math.sqrt(this.distanceToSquared(t))
                        }
                        distanceToSquared(t) {
                            const e = this.x - t.x,
                                i = this.y - t.y,
                                n = this.z - t.z;
                            return e * e + i * i + n * n
                        }
                        manhattanDistanceTo(t) {
                            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                        }
                        setFromSpherical(t) {
                            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                        }
                        setFromSphericalCoords(t, e, i) {
                            const n = Math.sin(e) * t;
                            return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                        }
                        setFromCylindrical(t) {
                            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                        }
                        setFromCylindricalCoords(t, e, i) {
                            return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                        }
                        setFromMatrixPosition(t) {
                            const e = t.elements;
                            return this.x = e[12], this.y = e[13], this.z = e[14], this
                        }
                        setFromMatrixScale(t) {
                            const e = this.setFromMatrixColumn(t, 0).length(),
                                i = this.setFromMatrixColumn(t, 1).length(),
                                n = this.setFromMatrixColumn(t, 2).length();
                            return this.x = e, this.y = i, this.z = n, this
                        }
                        setFromMatrixColumn(t, e) {
                            return this.fromArray(t.elements, 4 * e)
                        }
                        setFromMatrix3Column(t, e) {
                            return this.fromArray(t.elements, 3 * e)
                        }
                        setFromEuler(t) {
                            return this.x = t._x, this.y = t._y, this.z = t._z, this
                        }
                        setFromColor(t) {
                            return this.x = t.r, this.y = t.g, this.z = t.b, this
                        }
                        equals(t) {
                            return t.x === this.x && t.y === this.y && t.z === this.z
                        }
                        fromArray(t, e = 0) {
                            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                        }
                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                        }
                        randomDirection() {
                            const t = Math.random() * Math.PI * 2,
                                e = 2 * Math.random() - 1,
                                i = Math.sqrt(1 - e * e);
                            return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this
                        }*[Symbol.iterator]() {
                            yield this.x, yield this.y, yield this.z
                        }
                    }
                    const Mi = new xi,
                        bi = new yi;
                    class Si {
                        constructor(t = new xi(1 / 0, 1 / 0, 1 / 0), e = new xi(-1 / 0, -1 / 0, -1 / 0)) {
                            this.isBox3 = !0, this.min = t, this.max = e
                        }
                        set(t, e) {
                            return this.min.copy(t), this.max.copy(e), this
                        }
                        setFromArray(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.length; e < i; e += 3) this.expandByPoint(Ai.fromArray(t, e));
                            return this
                        }
                        setFromBufferAttribute(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.count; e < i; e++) this.expandByPoint(Ai.fromBufferAttribute(t, e));
                            return this
                        }
                        setFromPoints(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                            return this
                        }
                        setFromCenterAndSize(t, e) {
                            const i = Ai.copy(e).multiplyScalar(.5);
                            return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                        }
                        setFromObject(t, e = !1) {
                            return this.makeEmpty(), this.expandByObject(t, e)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.min.copy(t.min), this.max.copy(t.max), this
                        }
                        makeEmpty() {
                            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                        }
                        isEmpty() {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                        }
                        getCenter(t) {
                            return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                        }
                        getSize(t) {
                            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                        }
                        expandByPoint(t) {
                            return this.min.min(t), this.max.max(t), this
                        }
                        expandByVector(t) {
                            return this.min.sub(t), this.max.add(t), this
                        }
                        expandByScalar(t) {
                            return this.min.addScalar(-t), this.max.addScalar(t), this
                        }
                        expandByObject(t, e = !1) {
                            t.updateWorldMatrix(!1, !1);
                            const i = t.geometry;
                            if (void 0 !== i) {
                                const n = i.getAttribute("position");
                                if (!0 === e && void 0 !== n && !0 !== t.isInstancedMesh)
                                    for (let e = 0, i = n.count; e < i; e++) !0 === t.isMesh ? t.getVertexPosition(e, Ai) : Ai.fromBufferAttribute(n, e), Ai.applyMatrix4(t.matrixWorld), this.expandByPoint(Ai);
                                else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), Ti.copy(t.boundingBox)) : (null === i.boundingBox && i.computeBoundingBox(), Ti.copy(i.boundingBox)), Ti.applyMatrix4(t.matrixWorld), this.union(Ti)
                            }
                            const n = t.children;
                            for (let t = 0, i = n.length; t < i; t++) this.expandByObject(n[t], e);
                            return this
                        }
                        containsPoint(t) {
                            return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z
                        }
                        containsBox(t) {
                            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                        }
                        getParameter(t, e) {
                            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                        }
                        intersectsBox(t) {
                            return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z
                        }
                        intersectsSphere(t) {
                            return this.clampPoint(t.center, Ai), Ai.distanceToSquared(t.center) <= t.radius * t.radius
                        }
                        intersectsPlane(t) {
                            let e, i;
                            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                        }
                        intersectsTriangle(t) {
                            if (this.isEmpty()) return !1;
                            this.getCenter(Ui), Ni.subVectors(this.max, Ui), Ei.subVectors(t.a, Ui), Ci.subVectors(t.b, Ui), Ri.subVectors(t.c, Ui), Pi.subVectors(Ci, Ei), Ii.subVectors(Ri, Ci), Li.subVectors(Ei, Ri);
                            let e = [0, -Pi.z, Pi.y, 0, -Ii.z, Ii.y, 0, -Li.z, Li.y, Pi.z, 0, -Pi.x, Ii.z, 0, -Ii.x, Li.z, 0, -Li.x, -Pi.y, Pi.x, 0, -Ii.y, Ii.x, 0, -Li.y, Li.x, 0];
                            return !!Bi(e, Ei, Ci, Ri, Ni) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Bi(e, Ei, Ci, Ri, Ni) && (Di.crossVectors(Pi, Ii), e = [Di.x, Di.y, Di.z], Bi(e, Ei, Ci, Ri, Ni)))
                        }
                        clampPoint(t, e) {
                            return e.copy(t).clamp(this.min, this.max)
                        }
                        distanceToPoint(t) {
                            return this.clampPoint(t, Ai).distanceTo(t)
                        }
                        getBoundingSphere(t) {
                            return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(Ai).length()), t
                        }
                        intersect(t) {
                            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                        }
                        union(t) {
                            return this.min.min(t.min), this.max.max(t.max), this
                        }
                        applyMatrix4(t) {
                            return this.isEmpty() || (wi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), wi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), wi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), wi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), wi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), wi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), wi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), wi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(wi)), this
                        }
                        translate(t) {
                            return this.min.add(t), this.max.add(t), this
                        }
                        equals(t) {
                            return t.min.equals(this.min) && t.max.equals(this.max)
                        }
                    }
                    const wi = [new xi, new xi, new xi, new xi, new xi, new xi, new xi, new xi],
                        Ai = new xi,
                        Ti = new Si,
                        Ei = new xi,
                        Ci = new xi,
                        Ri = new xi,
                        Pi = new xi,
                        Ii = new xi,
                        Li = new xi,
                        Ui = new xi,
                        Ni = new xi,
                        Di = new xi,
                        Oi = new xi;

                    function Bi(t, e, i, n, r) {
                        for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                            Oi.fromArray(t, s);
                            const a = r.x * Math.abs(Oi.x) + r.y * Math.abs(Oi.y) + r.z * Math.abs(Oi.z),
                                o = e.dot(Oi),
                                l = i.dot(Oi),
                                h = n.dot(Oi);
                            if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1
                        }
                        return !0
                    }
                    const zi = new Si,
                        Fi = new xi,
                        ki = new xi;
                    class Vi {
                        constructor(t = new xi, e = -1) {
                            this.isSphere = !0, this.center = t, this.radius = e
                        }
                        set(t, e) {
                            return this.center.copy(t), this.radius = e, this
                        }
                        setFromPoints(t, e) {
                            const i = this.center;
                            void 0 !== e ? i.copy(e) : zi.setFromPoints(t).getCenter(i);
                            let n = 0;
                            for (let e = 0, r = t.length; e < r; e++) n = Math.max(n, i.distanceToSquared(t[e]));
                            return this.radius = Math.sqrt(n), this
                        }
                        copy(t) {
                            return this.center.copy(t.center), this.radius = t.radius, this
                        }
                        isEmpty() {
                            return this.radius < 0
                        }
                        makeEmpty() {
                            return this.center.set(0, 0, 0), this.radius = -1, this
                        }
                        containsPoint(t) {
                            return t.distanceToSquared(this.center) <= this.radius * this.radius
                        }
                        distanceToPoint(t) {
                            return t.distanceTo(this.center) - this.radius
                        }
                        intersectsSphere(t) {
                            const e = this.radius + t.radius;
                            return t.center.distanceToSquared(this.center) <= e * e
                        }
                        intersectsBox(t) {
                            return t.intersectsSphere(this)
                        }
                        intersectsPlane(t) {
                            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                        }
                        clampPoint(t, e) {
                            const i = this.center.distanceToSquared(t);
                            return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                        }
                        getBoundingBox(t) {
                            return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                        }
                        applyMatrix4(t) {
                            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                        }
                        translate(t) {
                            return this.center.add(t), this
                        }
                        expandByPoint(t) {
                            if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                            Fi.subVectors(t, this.center);
                            const e = Fi.lengthSq();
                            if (e > this.radius * this.radius) {
                                const t = Math.sqrt(e),
                                    i = .5 * (t - this.radius);
                                this.center.addScaledVector(Fi, i / t), this.radius += i
                            }
                            return this
                        }
                        union(t) {
                            return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (ki.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Fi.copy(t.center).add(ki)), this.expandByPoint(Fi.copy(t.center).sub(ki))), this)
                        }
                        equals(t) {
                            return t.center.equals(this.center) && t.radius === this.radius
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const Hi = new xi,
                        Gi = new xi,
                        Wi = new xi,
                        ji = new xi,
                        Xi = new xi,
                        qi = new xi,
                        Yi = new xi;
                    class Ji {
                        constructor(t = new xi, e = new xi(0, 0, -1)) {
                            this.origin = t, this.direction = e
                        }
                        set(t, e) {
                            return this.origin.copy(t), this.direction.copy(e), this
                        }
                        copy(t) {
                            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                        }
                        at(t, e) {
                            return e.copy(this.origin).addScaledVector(this.direction, t)
                        }
                        lookAt(t) {
                            return this.direction.copy(t).sub(this.origin).normalize(), this
                        }
                        recast(t) {
                            return this.origin.copy(this.at(t, Hi)), this
                        }
                        closestPointToPoint(t, e) {
                            e.subVectors(t, this.origin);
                            const i = e.dot(this.direction);
                            return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i)
                        }
                        distanceToPoint(t) {
                            return Math.sqrt(this.distanceSqToPoint(t))
                        }
                        distanceSqToPoint(t) {
                            const e = Hi.subVectors(t, this.origin).dot(this.direction);
                            return e < 0 ? this.origin.distanceToSquared(t) : (Hi.copy(this.origin).addScaledVector(this.direction, e), Hi.distanceToSquared(t))
                        }
                        distanceSqToSegment(t, e, i, n) {
                            Gi.copy(t).add(e).multiplyScalar(.5), Wi.copy(e).sub(t).normalize(), ji.copy(this.origin).sub(Gi);
                            const r = .5 * t.distanceTo(e),
                                s = -this.direction.dot(Wi),
                                a = ji.dot(this.direction),
                                o = -ji.dot(Wi),
                                l = ji.lengthSq(),
                                h = Math.abs(1 - s * s);
                            let c, u, d, p;
                            if (h > 0)
                                if (c = s * o - a, u = s * a - o, p = r * h, c >= 0)
                                    if (u >= -p)
                                        if (u <= p) {
                                            const t = 1 / h;
                                            c *= t, u *= t, d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l
                                        } else u = r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                            else u = -r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                            else u <= -p ? (c = Math.max(0, -(-s * r + a)), u = c > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l) : u <= p ? (c = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (c = Math.max(0, -(s * r + a)), u = c > 0 ? r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l);
                            else u = s > 0 ? -r : r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                            return i && i.copy(this.origin).addScaledVector(this.direction, c), n && n.copy(Gi).addScaledVector(Wi, u), d
                        }
                        intersectSphere(t, e) {
                            Hi.subVectors(t.center, this.origin);
                            const i = Hi.dot(this.direction),
                                n = Hi.dot(Hi) - i * i,
                                r = t.radius * t.radius;
                            if (n > r) return null;
                            const s = Math.sqrt(r - n),
                                a = i - s,
                                o = i + s;
                            return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                        }
                        intersectsSphere(t) {
                            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                        }
                        distanceToPlane(t) {
                            const e = t.normal.dot(this.direction);
                            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                            const i = -(this.origin.dot(t.normal) + t.constant) / e;
                            return i >= 0 ? i : null
                        }
                        intersectPlane(t, e) {
                            const i = this.distanceToPlane(t);
                            return null === i ? null : this.at(i, e)
                        }
                        intersectsPlane(t) {
                            const e = t.distanceToPoint(this.origin);
                            return 0 === e || t.normal.dot(this.direction) * e < 0
                        }
                        intersectBox(t, e) {
                            let i, n, r, s, a, o;
                            const l = 1 / this.direction.x,
                                h = 1 / this.direction.y,
                                c = 1 / this.direction.z,
                                u = this.origin;
                            return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, s = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, s = (t.min.y - u.y) * h), i > s || r > n ? null : ((r > i || isNaN(i)) && (i = r), (s < n || isNaN(n)) && (n = s), c >= 0 ? (a = (t.min.z - u.z) * c, o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, o = (t.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                        }
                        intersectsBox(t) {
                            return null !== this.intersectBox(t, Hi)
                        }
                        intersectTriangle(t, e, i, n, r) {
                            Xi.subVectors(e, t), qi.subVectors(i, t), Yi.crossVectors(Xi, qi);
                            let s, a = this.direction.dot(Yi);
                            if (a > 0) {
                                if (n) return null;
                                s = 1
                            } else {
                                if (!(a < 0)) return null;
                                s = -1, a = -a
                            }
                            ji.subVectors(this.origin, t);
                            const o = s * this.direction.dot(qi.crossVectors(ji, qi));
                            if (o < 0) return null;
                            const l = s * this.direction.dot(Xi.cross(ji));
                            if (l < 0) return null;
                            if (o + l > a) return null;
                            const h = -s * ji.dot(Yi);
                            return h < 0 ? null : this.at(h / a, r)
                        }
                        applyMatrix4(t) {
                            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                        }
                        equals(t) {
                            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    class Zi {
                        constructor(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
                            Zi.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f)
                        }
                        set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
                            const g = this.elements;
                            return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                        }
                        identity() {
                            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                        clone() {
                            return (new Zi).fromArray(this.elements)
                        }
                        copy(t) {
                            const e = this.elements,
                                i = t.elements;
                            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                        }
                        copyPosition(t) {
                            const e = this.elements,
                                i = t.elements;
                            return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                        }
                        setFromMatrix3(t) {
                            const e = t.elements;
                            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                        }
                        extractBasis(t, e, i) {
                            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                        }
                        makeBasis(t, e, i) {
                            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                        }
                        extractRotation(t) {
                            const e = this.elements,
                                i = t.elements,
                                n = 1 / Ki.setFromMatrixColumn(t, 0).length(),
                                r = 1 / Ki.setFromMatrixColumn(t, 1).length(),
                                s = 1 / Ki.setFromMatrixColumn(t, 2).length();
                            return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * s, e[9] = i[9] * s, e[10] = i[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                        }
                        makeRotationFromEuler(t) {
                            const e = this.elements,
                                i = t.x,
                                n = t.y,
                                r = t.z,
                                s = Math.cos(i),
                                a = Math.sin(i),
                                o = Math.cos(n),
                                l = Math.sin(n),
                                h = Math.cos(r),
                                c = Math.sin(r);
                            if ("XYZ" === t.order) {
                                const t = s * h,
                                    i = s * c,
                                    n = a * h,
                                    r = a * c;
                                e[0] = o * h, e[4] = -o * c, e[8] = l, e[1] = i + n * l, e[5] = t - r * l, e[9] = -a * o, e[2] = r - t * l, e[6] = n + i * l, e[10] = s * o
                            } else if ("YXZ" === t.order) {
                                const t = o * h,
                                    i = o * c,
                                    n = l * h,
                                    r = l * c;
                                e[0] = t + r * a, e[4] = n * a - i, e[8] = s * l, e[1] = s * c, e[5] = s * h, e[9] = -a, e[2] = i * a - n, e[6] = r + t * a, e[10] = s * o
                            } else if ("ZXY" === t.order) {
                                const t = o * h,
                                    i = o * c,
                                    n = l * h,
                                    r = l * c;
                                e[0] = t - r * a, e[4] = -s * c, e[8] = n + i * a, e[1] = i + n * a, e[5] = s * h, e[9] = r - t * a, e[2] = -s * l, e[6] = a, e[10] = s * o
                            } else if ("ZYX" === t.order) {
                                const t = s * h,
                                    i = s * c,
                                    n = a * h,
                                    r = a * c;
                                e[0] = o * h, e[4] = n * l - i, e[8] = t * l + r, e[1] = o * c, e[5] = r * l + t, e[9] = i * l - n, e[2] = -l, e[6] = a * o, e[10] = s * o
                            } else if ("YZX" === t.order) {
                                const t = s * o,
                                    i = s * l,
                                    n = a * o,
                                    r = a * l;
                                e[0] = o * h, e[4] = r - t * c, e[8] = n * c + i, e[1] = c, e[5] = s * h, e[9] = -a * h, e[2] = -l * h, e[6] = i * c + n, e[10] = t - r * c
                            } else if ("XZY" === t.order) {
                                const t = s * o,
                                    i = s * l,
                                    n = a * o,
                                    r = a * l;
                                e[0] = o * h, e[4] = -c, e[8] = l * h, e[1] = t * c + r, e[5] = s * h, e[9] = i * c - n, e[2] = n * c - i, e[6] = a * h, e[10] = r * c + t
                            }
                            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                        }
                        makeRotationFromQuaternion(t) {
                            return this.compose($i, t, tn)
                        }
                        lookAt(t, e, i) {
                            const n = this.elements;
                            return rn.subVectors(t, e), 0 === rn.lengthSq() && (rn.z = 1), rn.normalize(), en.crossVectors(i, rn), 0 === en.lengthSq() && (1 === Math.abs(i.z) ? rn.x += 1e-4 : rn.z += 1e-4, rn.normalize(), en.crossVectors(i, rn)), en.normalize(), nn.crossVectors(rn, en), n[0] = en.x, n[4] = nn.x, n[8] = rn.x, n[1] = en.y, n[5] = nn.y, n[9] = rn.y, n[2] = en.z, n[6] = nn.z, n[10] = rn.z, this
                        }
                        multiply(t) {
                            return this.multiplyMatrices(this, t)
                        }
                        premultiply(t) {
                            return this.multiplyMatrices(t, this)
                        }
                        multiplyMatrices(t, e) {
                            const i = t.elements,
                                n = e.elements,
                                r = this.elements,
                                s = i[0],
                                a = i[4],
                                o = i[8],
                                l = i[12],
                                h = i[1],
                                c = i[5],
                                u = i[9],
                                d = i[13],
                                p = i[2],
                                m = i[6],
                                f = i[10],
                                g = i[14],
                                v = i[3],
                                _ = i[7],
                                y = i[11],
                                x = i[15],
                                M = n[0],
                                b = n[4],
                                S = n[8],
                                w = n[12],
                                A = n[1],
                                T = n[5],
                                E = n[9],
                                C = n[13],
                                R = n[2],
                                P = n[6],
                                I = n[10],
                                L = n[14],
                                U = n[3],
                                N = n[7],
                                D = n[11],
                                O = n[15];
                            return r[0] = s * M + a * A + o * R + l * U, r[4] = s * b + a * T + o * P + l * N, r[8] = s * S + a * E + o * I + l * D, r[12] = s * w + a * C + o * L + l * O, r[1] = h * M + c * A + u * R + d * U, r[5] = h * b + c * T + u * P + d * N, r[9] = h * S + c * E + u * I + d * D, r[13] = h * w + c * C + u * L + d * O, r[2] = p * M + m * A + f * R + g * U, r[6] = p * b + m * T + f * P + g * N, r[10] = p * S + m * E + f * I + g * D, r[14] = p * w + m * C + f * L + g * O, r[3] = v * M + _ * A + y * R + x * U, r[7] = v * b + _ * T + y * P + x * N, r[11] = v * S + _ * E + y * I + x * D, r[15] = v * w + _ * C + y * L + x * O, this
                        }
                        multiplyScalar(t) {
                            const e = this.elements;
                            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                        }
                        determinant() {
                            const t = this.elements,
                                e = t[0],
                                i = t[4],
                                n = t[8],
                                r = t[12],
                                s = t[1],
                                a = t[5],
                                o = t[9],
                                l = t[13],
                                h = t[2],
                                c = t[6],
                                u = t[10],
                                d = t[14];
                            return t[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + t[11] * (+e * l * c - e * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + t[15] * (-n * a * h - e * o * c + e * a * u + n * s * c - i * s * u + i * o * h)
                        }
                        transpose() {
                            const t = this.elements;
                            let e;
                            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                        }
                        setPosition(t, e, i) {
                            const n = this.elements;
                            return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
                        }
                        invert() {
                            const t = this.elements,
                                e = t[0],
                                i = t[1],
                                n = t[2],
                                r = t[3],
                                s = t[4],
                                a = t[5],
                                o = t[6],
                                l = t[7],
                                h = t[8],
                                c = t[9],
                                u = t[10],
                                d = t[11],
                                p = t[12],
                                m = t[13],
                                f = t[14],
                                g = t[15],
                                v = c * f * l - m * u * l + m * o * d - a * f * d - c * o * g + a * u * g,
                                _ = p * u * l - h * f * l - p * o * d + s * f * d + h * o * g - s * u * g,
                                y = h * m * l - p * c * l + p * a * d - s * m * d - h * a * g + s * c * g,
                                x = p * c * o - h * m * o - p * a * u + s * m * u + h * a * f - s * c * f,
                                M = e * v + i * _ + n * y + r * x;
                            if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const b = 1 / M;
                            return t[0] = v * b, t[1] = (m * u * r - c * f * r - m * n * d + i * f * d + c * n * g - i * u * g) * b, t[2] = (a * f * r - m * o * r + m * n * l - i * f * l - a * n * g + i * o * g) * b, t[3] = (c * o * r - a * u * r - c * n * l + i * u * l + a * n * d - i * o * d) * b, t[4] = _ * b, t[5] = (h * f * r - p * u * r + p * n * d - e * f * d - h * n * g + e * u * g) * b, t[6] = (p * o * r - s * f * r - p * n * l + e * f * l + s * n * g - e * o * g) * b, t[7] = (s * u * r - h * o * r + h * n * l - e * u * l - s * n * d + e * o * d) * b, t[8] = y * b, t[9] = (p * c * r - h * m * r - p * i * d + e * m * d + h * i * g - e * c * g) * b, t[10] = (s * m * r - p * a * r + p * i * l - e * m * l - s * i * g + e * a * g) * b, t[11] = (h * a * r - s * c * r - h * i * l + e * c * l + s * i * d - e * a * d) * b, t[12] = x * b, t[13] = (h * m * n - p * c * n + p * i * u - e * m * u - h * i * f + e * c * f) * b, t[14] = (p * a * n - s * m * n - p * i * o + e * m * o + s * i * f - e * a * f) * b, t[15] = (s * c * n - h * a * n + h * i * o - e * c * o - s * i * u + e * a * u) * b, this
                        }
                        scale(t) {
                            const e = this.elements,
                                i = t.x,
                                n = t.y,
                                r = t.z;
                            return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                        }
                        getMaxScaleOnAxis() {
                            const t = this.elements,
                                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                                i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                                n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                            return Math.sqrt(Math.max(e, i, n))
                        }
                        makeTranslation(t, e, i) {
                            return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                        }
                        makeRotationX(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                        }
                        makeRotationY(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                        }
                        makeRotationZ(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                        makeRotationAxis(t, e) {
                            const i = Math.cos(e),
                                n = Math.sin(e),
                                r = 1 - i,
                                s = t.x,
                                a = t.y,
                                o = t.z,
                                l = r * s,
                                h = r * a;
                            return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, h * a + i, h * o - n * s, 0, l * o - n * a, h * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
                        }
                        makeScale(t, e, i) {
                            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                        }
                        makeShear(t, e, i, n, r, s) {
                            return this.set(1, i, r, 0, t, 1, s, 0, e, n, 1, 0, 0, 0, 0, 1), this
                        }
                        compose(t, e, i) {
                            const n = this.elements,
                                r = e._x,
                                s = e._y,
                                a = e._z,
                                o = e._w,
                                l = r + r,
                                h = s + s,
                                c = a + a,
                                u = r * l,
                                d = r * h,
                                p = r * c,
                                m = s * h,
                                f = s * c,
                                g = a * c,
                                v = o * l,
                                _ = o * h,
                                y = o * c,
                                x = i.x,
                                M = i.y,
                                b = i.z;
                            return n[0] = (1 - (m + g)) * x, n[1] = (d + y) * x, n[2] = (p - _) * x, n[3] = 0, n[4] = (d - y) * M, n[5] = (1 - (u + g)) * M, n[6] = (f + v) * M, n[7] = 0, n[8] = (p + _) * b, n[9] = (f - v) * b, n[10] = (1 - (u + m)) * b, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                        }
                        decompose(t, e, i) {
                            const n = this.elements;
                            let r = Ki.set(n[0], n[1], n[2]).length();
                            const s = Ki.set(n[4], n[5], n[6]).length(),
                                a = Ki.set(n[8], n[9], n[10]).length();
                            this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Qi.copy(this);
                            const o = 1 / r,
                                l = 1 / s,
                                h = 1 / a;
                            return Qi.elements[0] *= o, Qi.elements[1] *= o, Qi.elements[2] *= o, Qi.elements[4] *= l, Qi.elements[5] *= l, Qi.elements[6] *= l, Qi.elements[8] *= h, Qi.elements[9] *= h, Qi.elements[10] *= h, e.setFromRotationMatrix(Qi), i.x = r, i.y = s, i.z = a, this
                        }
                        makePerspective(t, e, i, n, r, s, a = 2e3) {
                            const o = this.elements,
                                l = 2 * r / (e - t),
                                h = 2 * r / (i - n),
                                c = (e + t) / (e - t),
                                u = (i + n) / (i - n);
                            let d, p;
                            if (a === Pe) d = -(s + r) / (s - r), p = -2 * s * r / (s - r);
                            else {
                                if (a !== Ie) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                                d = -s / (s - r), p = -s * r / (s - r)
                            }
                            return o[0] = l, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = h, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                        }
                        makeOrthographic(t, e, i, n, r, s, a = 2e3) {
                            const o = this.elements,
                                l = 1 / (e - t),
                                h = 1 / (i - n),
                                c = 1 / (s - r),
                                u = (e + t) * l,
                                d = (i + n) * h;
                            let p, m;
                            if (a === Pe) p = (s + r) * c, m = -2 * c;
                            else {
                                if (a !== Ie) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                                p = r * c, m = -1 * c
                            }
                            return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * h, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = m, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                        }
                        equals(t) {
                            const e = this.elements,
                                i = t.elements;
                            for (let t = 0; t < 16; t++)
                                if (e[t] !== i[t]) return !1;
                            return !0
                        }
                        fromArray(t, e = 0) {
                            for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                            return this
                        }
                        toArray(t = [], e = 0) {
                            const i = this.elements;
                            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                        }
                    }
                    const Ki = new xi,
                        Qi = new Zi,
                        $i = new xi(0, 0, 0),
                        tn = new xi(1, 1, 1),
                        en = new xi,
                        nn = new xi,
                        rn = new xi,
                        sn = new Zi,
                        an = new yi;
                    class on {
                        constructor(t = 0, e = 0, i = 0, n = on.DEFAULT_ORDER) {
                            this.isEuler = !0, this._x = t, this._y = e, this._z = i, this._order = n
                        }
                        get x() {
                            return this._x
                        }
                        set x(t) {
                            this._x = t, this._onChangeCallback()
                        }
                        get y() {
                            return this._y
                        }
                        set y(t) {
                            this._y = t, this._onChangeCallback()
                        }
                        get z() {
                            return this._z
                        }
                        set z(t) {
                            this._z = t, this._onChangeCallback()
                        }
                        get order() {
                            return this._order
                        }
                        set order(t) {
                            this._order = t, this._onChangeCallback()
                        }
                        set(t, e, i, n = this._order) {
                            return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this
                        }
                        clone() {
                            return new this.constructor(this._x, this._y, this._z, this._order)
                        }
                        copy(t) {
                            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                        }
                        setFromRotationMatrix(t, e = this._order, i = !0) {
                            const n = t.elements,
                                r = n[0],
                                s = n[4],
                                a = n[8],
                                o = n[1],
                                l = n[5],
                                h = n[9],
                                c = n[2],
                                u = n[6],
                                d = n[10];
                            switch (e) {
                                case "XYZ":
                                    this._y = Math.asin(ze(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                    break;
                                case "YXZ":
                                    this._x = Math.asin(-ze(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, r), this._z = 0);
                                    break;
                                case "ZXY":
                                    this._x = Math.asin(ze(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                                    break;
                                case "ZYX":
                                    this._y = Math.asin(-ze(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                    break;
                                case "YZX":
                                    this._z = Math.asin(ze(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                                    break;
                                case "XZY":
                                    this._z = Math.asin(-ze(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, d), this._y = 0);
                                    break;
                                default:
                                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                            }
                            return this._order = e, !0 === i && this._onChangeCallback(), this
                        }
                        setFromQuaternion(t, e, i) {
                            return sn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(sn, e, i)
                        }
                        setFromVector3(t, e = this._order) {
                            return this.set(t.x, t.y, t.z, e)
                        }
                        reorder(t) {
                            return an.setFromEuler(this), this.setFromQuaternion(an, t)
                        }
                        equals(t) {
                            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                        }
                        fromArray(t) {
                            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                        }
                        _onChange(t) {
                            return this._onChangeCallback = t, this
                        }
                        _onChangeCallback() {}*[Symbol.iterator]() {
                            yield this._x, yield this._y, yield this._z, yield this._order
                        }
                    }
                    on.DEFAULT_ORDER = "XYZ";
                    class ln {
                        constructor() {
                            this.mask = 1
                        }
                        set(t) {
                            this.mask = 1 << t >>> 0
                        }
                        enable(t) {
                            this.mask |= 1 << t
                        }
                        enableAll() {
                            this.mask = -1
                        }
                        toggle(t) {
                            this.mask ^= 1 << t
                        }
                        disable(t) {
                            this.mask &= ~(1 << t)
                        }
                        disableAll() {
                            this.mask = 0
                        }
                        test(t) {
                            return !!(this.mask & t.mask)
                        }
                        isEnabled(t) {
                            return !!(this.mask & 1 << t)
                        }
                    }
                    let hn = 0;
                    const cn = new xi,
                        un = new yi,
                        dn = new Zi,
                        pn = new xi,
                        mn = new xi,
                        fn = new xi,
                        gn = new yi,
                        vn = new xi(1, 0, 0),
                        _n = new xi(0, 1, 0),
                        yn = new xi(0, 0, 1),
                        xn = {
                            type: "added"
                        },
                        Mn = {
                            type: "removed"
                        },
                        bn = {
                            type: "childadded",
                            child: null
                        },
                        Sn = {
                            type: "childremoved",
                            child: null
                        };
                    class wn extends Le {
                        constructor() {
                            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                                value: hn++
                            }), this.uuid = Be(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = wn.DEFAULT_UP.clone();
                            const t = new xi,
                                e = new on,
                                i = new yi,
                                n = new xi(1, 1, 1);
                            e._onChange((function() {
                                i.setFromEuler(e, !1)
                            })), i._onChange((function() {
                                e.setFromQuaternion(i, void 0, !1)
                            })), Object.defineProperties(this, {
                                position: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: t
                                },
                                rotation: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: e
                                },
                                quaternion: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: i
                                },
                                scale: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: n
                                },
                                modelViewMatrix: {
                                    value: new Zi
                                },
                                normalMatrix: {
                                    value: new je
                                }
                            }), this.matrix = new Zi, this.matrixWorld = new Zi, this.matrixAutoUpdate = wn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new ln, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                        }
                        onBeforeShadow() {}
                        onAfterShadow() {}
                        onBeforeRender() {}
                        onAfterRender() {}
                        applyMatrix4(t) {
                            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                        }
                        applyQuaternion(t) {
                            return this.quaternion.premultiply(t), this
                        }
                        setRotationFromAxisAngle(t, e) {
                            this.quaternion.setFromAxisAngle(t, e)
                        }
                        setRotationFromEuler(t) {
                            this.quaternion.setFromEuler(t, !0)
                        }
                        setRotationFromMatrix(t) {
                            this.quaternion.setFromRotationMatrix(t)
                        }
                        setRotationFromQuaternion(t) {
                            this.quaternion.copy(t)
                        }
                        rotateOnAxis(t, e) {
                            return un.setFromAxisAngle(t, e), this.quaternion.multiply(un), this
                        }
                        rotateOnWorldAxis(t, e) {
                            return un.setFromAxisAngle(t, e), this.quaternion.premultiply(un), this
                        }
                        rotateX(t) {
                            return this.rotateOnAxis(vn, t)
                        }
                        rotateY(t) {
                            return this.rotateOnAxis(_n, t)
                        }
                        rotateZ(t) {
                            return this.rotateOnAxis(yn, t)
                        }
                        translateOnAxis(t, e) {
                            return cn.copy(t).applyQuaternion(this.quaternion), this.position.add(cn.multiplyScalar(e)), this
                        }
                        translateX(t) {
                            return this.translateOnAxis(vn, t)
                        }
                        translateY(t) {
                            return this.translateOnAxis(_n, t)
                        }
                        translateZ(t) {
                            return this.translateOnAxis(yn, t)
                        }
                        localToWorld(t) {
                            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
                        }
                        worldToLocal(t) {
                            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(dn.copy(this.matrixWorld).invert())
                        }
                        lookAt(t, e, i) {
                            t.isVector3 ? pn.copy(t) : pn.set(t, e, i);
                            const n = this.parent;
                            this.updateWorldMatrix(!0, !1), mn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? dn.lookAt(mn, pn, this.up) : dn.lookAt(pn, mn, this.up), this.quaternion.setFromRotationMatrix(dn), n && (dn.extractRotation(n.matrixWorld), un.setFromRotationMatrix(dn), this.quaternion.premultiply(un.invert()))
                        }
                        add(t) {
                            if (arguments.length > 1) {
                                for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                                return this
                            }
                            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(xn), bn.child = t, this.dispatchEvent(bn), bn.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                        }
                        remove(t) {
                            if (arguments.length > 1) {
                                for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                                return this
                            }
                            const e = this.children.indexOf(t);
                            return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Mn), Sn.child = t, this.dispatchEvent(Sn), Sn.child = null), this
                        }
                        removeFromParent() {
                            const t = this.parent;
                            return null !== t && t.remove(this), this
                        }
                        clear() {
                            return this.remove(...this.children)
                        }
                        attach(t) {
                            return this.updateWorldMatrix(!0, !1), dn.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), dn.multiply(t.parent.matrixWorld)), t.applyMatrix4(dn), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(xn), bn.child = t, this.dispatchEvent(bn), bn.child = null, this
                        }
                        getObjectById(t) {
                            return this.getObjectByProperty("id", t)
                        }
                        getObjectByName(t) {
                            return this.getObjectByProperty("name", t)
                        }
                        getObjectByProperty(t, e) {
                            if (this[t] === e) return this;
                            for (let i = 0, n = this.children.length; i < n; i++) {
                                const n = this.children[i].getObjectByProperty(t, e);
                                if (void 0 !== n) return n
                            }
                        }
                        getObjectsByProperty(t, e, i = []) {
                            this[t] === e && i.push(this);
                            const n = this.children;
                            for (let r = 0, s = n.length; r < s; r++) n[r].getObjectsByProperty(t, e, i);
                            return i
                        }
                        getWorldPosition(t) {
                            return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                        }
                        getWorldQuaternion(t) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(mn, t, fn), t
                        }
                        getWorldScale(t) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(mn, gn, t), t
                        }
                        getWorldDirection(t) {
                            this.updateWorldMatrix(!0, !1);
                            const e = this.matrixWorld.elements;
                            return t.set(e[8], e[9], e[10]).normalize()
                        }
                        raycast() {}
                        traverse(t) {
                            t(this);
                            const e = this.children;
                            for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                        }
                        traverseVisible(t) {
                            if (!1 === this.visible) return;
                            t(this);
                            const e = this.children;
                            for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                        }
                        traverseAncestors(t) {
                            const e = this.parent;
                            null !== e && (t(e), e.traverseAncestors(t))
                        }
                        updateMatrix() {
                            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                        }
                        updateMatrixWorld(t) {
                            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
                            const e = this.children;
                            for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                        }
                        updateWorldMatrix(t, e) {
                            const i = this.parent;
                            if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === e) {
                                const t = this.children;
                                for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
                            }
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t,
                                i = {};
                            e && (t = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            }, i.metadata = {
                                version: 4.6,
                                type: "Object",
                                generator: "Object3D.toJSON"
                            });
                            const n = {};

                            function r(e, i) {
                                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                            }
                            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((t => ({
                                    boxInitialized: t.boxInitialized,
                                    boxMin: t.box.min.toArray(),
                                    boxMax: t.box.max.toArray(),
                                    sphereInitialized: t.sphereInitialized,
                                    sphereRadius: t.sphere.radius,
                                    sphereCenter: t.sphere.center.toArray()
                                }))), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(t), null !== this._colorsTexture && (n.colorsTexture = this._colorsTexture.toJSON(t)), null !== this.boundingSphere && (n.boundingSphere = {
                                    center: n.boundingSphere.center.toArray(),
                                    radius: n.boundingSphere.radius
                                }), null !== this.boundingBox && (n.boundingBox = {
                                    min: n.boundingBox.min.toArray(),
                                    max: n.boundingBox.max.toArray()
                                })), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(t).uuid);
                            else if (this.isMesh || this.isLine || this.isPoints) {
                                n.geometry = r(t.geometries, this.geometry);
                                const e = this.geometry.parameters;
                                if (void 0 !== e && void 0 !== e.shapes) {
                                    const i = e.shapes;
                                    if (Array.isArray(i))
                                        for (let e = 0, n = i.length; e < n; e++) {
                                            const n = i[e];
                                            r(t.shapes, n)
                                        } else r(t.shapes, i)
                                }
                            }
                            if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                                if (Array.isArray(this.material)) {
                                    const e = [];
                                    for (let i = 0, n = this.material.length; i < n; i++) e.push(r(t.materials, this.material[i]));
                                    n.material = e
                                } else n.material = r(t.materials, this.material);
                            if (this.children.length > 0) {
                                n.children = [];
                                for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object)
                            }
                            if (this.animations.length > 0) {
                                n.animations = [];
                                for (let e = 0; e < this.animations.length; e++) {
                                    const i = this.animations[e];
                                    n.animations.push(r(t.animations, i))
                                }
                            }
                            if (e) {
                                const e = s(t.geometries),
                                    n = s(t.materials),
                                    r = s(t.textures),
                                    a = s(t.images),
                                    o = s(t.shapes),
                                    l = s(t.skeletons),
                                    h = s(t.animations),
                                    c = s(t.nodes);
                                e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), h.length > 0 && (i.animations = h), c.length > 0 && (i.nodes = c)
                            }
                            return i.object = n, i;

                            function s(t) {
                                const e = [];
                                for (const i in t) {
                                    const n = t[i];
                                    delete n.metadata, e.push(n)
                                }
                                return e
                            }
                        }
                        clone(t) {
                            return (new this.constructor).copy(this, t)
                        }
                        copy(t, e = !0) {
                            if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                                for (let e = 0; e < t.children.length; e++) {
                                    const i = t.children[e];
                                    this.add(i.clone())
                                }
                            return this
                        }
                    }
                    wn.DEFAULT_UP = new xi(0, 1, 0), wn.DEFAULT_MATRIX_AUTO_UPDATE = !0, wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                    const An = new xi,
                        Tn = new xi,
                        En = new xi,
                        Cn = new xi,
                        Rn = new xi,
                        Pn = new xi,
                        In = new xi,
                        Ln = new xi,
                        Un = new xi,
                        Nn = new xi;
                    class Dn {
                        constructor(t = new xi, e = new xi, i = new xi) {
                            this.a = t, this.b = e, this.c = i
                        }
                        static getNormal(t, e, i, n) {
                            n.subVectors(i, e), An.subVectors(t, e), n.cross(An);
                            const r = n.lengthSq();
                            return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                        }
                        static getBarycoord(t, e, i, n, r) {
                            An.subVectors(n, e), Tn.subVectors(i, e), En.subVectors(t, e);
                            const s = An.dot(An),
                                a = An.dot(Tn),
                                o = An.dot(En),
                                l = Tn.dot(Tn),
                                h = Tn.dot(En),
                                c = s * l - a * a;
                            if (0 === c) return r.set(0, 0, 0), null;
                            const u = 1 / c,
                                d = (l * o - a * h) * u,
                                p = (s * h - a * o) * u;
                            return r.set(1 - d - p, p, d)
                        }
                        static containsPoint(t, e, i, n) {
                            return null !== this.getBarycoord(t, e, i, n, Cn) && Cn.x >= 0 && Cn.y >= 0 && Cn.x + Cn.y <= 1
                        }
                        static getInterpolation(t, e, i, n, r, s, a, o) {
                            return null === this.getBarycoord(t, e, i, n, Cn) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, Cn.x), o.addScaledVector(s, Cn.y), o.addScaledVector(a, Cn.z), o)
                        }
                        static isFrontFacing(t, e, i, n) {
                            return An.subVectors(i, e), Tn.subVectors(t, e), An.cross(Tn).dot(n) < 0
                        }
                        set(t, e, i) {
                            return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                        }
                        setFromPointsAndIndices(t, e, i, n) {
                            return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                        }
                        setFromAttributeAndIndices(t, e, i, n) {
                            return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, n), this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                        }
                        getArea() {
                            return An.subVectors(this.c, this.b), Tn.subVectors(this.a, this.b), .5 * An.cross(Tn).length()
                        }
                        getMidpoint(t) {
                            return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                        }
                        getNormal(t) {
                            return Dn.getNormal(this.a, this.b, this.c, t)
                        }
                        getPlane(t) {
                            return t.setFromCoplanarPoints(this.a, this.b, this.c)
                        }
                        getBarycoord(t, e) {
                            return Dn.getBarycoord(t, this.a, this.b, this.c, e)
                        }
                        getInterpolation(t, e, i, n, r) {
                            return Dn.getInterpolation(t, this.a, this.b, this.c, e, i, n, r)
                        }
                        containsPoint(t) {
                            return Dn.containsPoint(t, this.a, this.b, this.c)
                        }
                        isFrontFacing(t) {
                            return Dn.isFrontFacing(this.a, this.b, this.c, t)
                        }
                        intersectsBox(t) {
                            return t.intersectsTriangle(this)
                        }
                        closestPointToPoint(t, e) {
                            const i = this.a,
                                n = this.b,
                                r = this.c;
                            let s, a;
                            Rn.subVectors(n, i), Pn.subVectors(r, i), Ln.subVectors(t, i);
                            const o = Rn.dot(Ln),
                                l = Pn.dot(Ln);
                            if (o <= 0 && l <= 0) return e.copy(i);
                            Un.subVectors(t, n);
                            const h = Rn.dot(Un),
                                c = Pn.dot(Un);
                            if (h >= 0 && c <= h) return e.copy(n);
                            const u = o * c - h * l;
                            if (u <= 0 && o >= 0 && h <= 0) return s = o / (o - h), e.copy(i).addScaledVector(Rn, s);
                            Nn.subVectors(t, r);
                            const d = Rn.dot(Nn),
                                p = Pn.dot(Nn);
                            if (p >= 0 && d <= p) return e.copy(r);
                            const m = d * l - o * p;
                            if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(i).addScaledVector(Pn, a);
                            const f = h * p - d * c;
                            if (f <= 0 && c - h >= 0 && d - p >= 0) return In.subVectors(r, n), a = (c - h) / (c - h + (d - p)), e.copy(n).addScaledVector(In, a);
                            const g = 1 / (f + m + u);
                            return s = m * g, a = u * g, e.copy(i).addScaledVector(Rn, s).addScaledVector(Pn, a)
                        }
                        equals(t) {
                            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                        }
                    }
                    const On = {
                            aliceblue: 15792383,
                            antiquewhite: 16444375,
                            aqua: 65535,
                            aquamarine: 8388564,
                            azure: 15794175,
                            beige: 16119260,
                            bisque: 16770244,
                            black: 0,
                            blanchedalmond: 16772045,
                            blue: 255,
                            blueviolet: 9055202,
                            brown: 10824234,
                            burlywood: 14596231,
                            cadetblue: 6266528,
                            chartreuse: 8388352,
                            chocolate: 13789470,
                            coral: 16744272,
                            cornflowerblue: 6591981,
                            cornsilk: 16775388,
                            crimson: 14423100,
                            cyan: 65535,
                            darkblue: 139,
                            darkcyan: 35723,
                            darkgoldenrod: 12092939,
                            darkgray: 11119017,
                            darkgreen: 25600,
                            darkgrey: 11119017,
                            darkkhaki: 12433259,
                            darkmagenta: 9109643,
                            darkolivegreen: 5597999,
                            darkorange: 16747520,
                            darkorchid: 10040012,
                            darkred: 9109504,
                            darksalmon: 15308410,
                            darkseagreen: 9419919,
                            darkslateblue: 4734347,
                            darkslategray: 3100495,
                            darkslategrey: 3100495,
                            darkturquoise: 52945,
                            darkviolet: 9699539,
                            deeppink: 16716947,
                            deepskyblue: 49151,
                            dimgray: 6908265,
                            dimgrey: 6908265,
                            dodgerblue: 2003199,
                            firebrick: 11674146,
                            floralwhite: 16775920,
                            forestgreen: 2263842,
                            fuchsia: 16711935,
                            gainsboro: 14474460,
                            ghostwhite: 16316671,
                            gold: 16766720,
                            goldenrod: 14329120,
                            gray: 8421504,
                            green: 32768,
                            greenyellow: 11403055,
                            grey: 8421504,
                            honeydew: 15794160,
                            hotpink: 16738740,
                            indianred: 13458524,
                            indigo: 4915330,
                            ivory: 16777200,
                            khaki: 15787660,
                            lavender: 15132410,
                            lavenderblush: 16773365,
                            lawngreen: 8190976,
                            lemonchiffon: 16775885,
                            lightblue: 11393254,
                            lightcoral: 15761536,
                            lightcyan: 14745599,
                            lightgoldenrodyellow: 16448210,
                            lightgray: 13882323,
                            lightgreen: 9498256,
                            lightgrey: 13882323,
                            lightpink: 16758465,
                            lightsalmon: 16752762,
                            lightseagreen: 2142890,
                            lightskyblue: 8900346,
                            lightslategray: 7833753,
                            lightslategrey: 7833753,
                            lightsteelblue: 11584734,
                            lightyellow: 16777184,
                            lime: 65280,
                            limegreen: 3329330,
                            linen: 16445670,
                            magenta: 16711935,
                            maroon: 8388608,
                            mediumaquamarine: 6737322,
                            mediumblue: 205,
                            mediumorchid: 12211667,
                            mediumpurple: 9662683,
                            mediumseagreen: 3978097,
                            mediumslateblue: 8087790,
                            mediumspringgreen: 64154,
                            mediumturquoise: 4772300,
                            mediumvioletred: 13047173,
                            midnightblue: 1644912,
                            mintcream: 16121850,
                            mistyrose: 16770273,
                            moccasin: 16770229,
                            navajowhite: 16768685,
                            navy: 128,
                            oldlace: 16643558,
                            olive: 8421376,
                            olivedrab: 7048739,
                            orange: 16753920,
                            orangered: 16729344,
                            orchid: 14315734,
                            palegoldenrod: 15657130,
                            palegreen: 10025880,
                            paleturquoise: 11529966,
                            palevioletred: 14381203,
                            papayawhip: 16773077,
                            peachpuff: 16767673,
                            peru: 13468991,
                            pink: 16761035,
                            plum: 14524637,
                            powderblue: 11591910,
                            purple: 8388736,
                            rebeccapurple: 6697881,
                            red: 16711680,
                            rosybrown: 12357519,
                            royalblue: 4286945,
                            saddlebrown: 9127187,
                            salmon: 16416882,
                            sandybrown: 16032864,
                            seagreen: 3050327,
                            seashell: 16774638,
                            sienna: 10506797,
                            silver: 12632256,
                            skyblue: 8900331,
                            slateblue: 6970061,
                            slategray: 7372944,
                            slategrey: 7372944,
                            snow: 16775930,
                            springgreen: 65407,
                            steelblue: 4620980,
                            tan: 13808780,
                            teal: 32896,
                            thistle: 14204888,
                            tomato: 16737095,
                            turquoise: 4251856,
                            violet: 15631086,
                            wheat: 16113331,
                            white: 16777215,
                            whitesmoke: 16119285,
                            yellow: 16776960,
                            yellowgreen: 10145074
                        },
                        Bn = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        zn = {
                            h: 0,
                            s: 0,
                            l: 0
                        };

                    function Fn(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                    }
                    class kn {
                        constructor(t, e, i) {
                            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, i)
                        }
                        set(t, e, i) {
                            if (void 0 === e && void 0 === i) {
                                const e = t;
                                e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                            } else this.setRGB(t, e, i);
                            return this
                        }
                        setScalar(t) {
                            return this.r = t, this.g = t, this.b = t, this
                        }
                        setHex(t, e = ue) {
                            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, ri.toWorkingColorSpace(this, e), this
                        }
                        setRGB(t, e, i, n = ri.workingColorSpace) {
                            return this.r = t, this.g = e, this.b = i, ri.toWorkingColorSpace(this, n), this
                        }
                        setHSL(t, e, i, n = ri.workingColorSpace) {
                            if (t = Fe(t, 1), e = ze(e, 0, 1), i = ze(i, 0, 1), 0 === e) this.r = this.g = this.b = i;
                            else {
                                const n = i <= .5 ? i * (1 + e) : i + e - i * e,
                                    r = 2 * i - n;
                                this.r = Fn(r, n, t + 1 / 3), this.g = Fn(r, n, t), this.b = Fn(r, n, t - 1 / 3)
                            }
                            return ri.toWorkingColorSpace(this, n), this
                        }
                        setStyle(t, e = ue) {
                            function i(e) {
                                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                            }
                            let n;
                            if (n = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                                let r;
                                const s = n[1],
                                    a = n[2];
                                switch (s) {
                                    case "rgb":
                                    case "rgba":
                                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                                        break;
                                    case "hsl":
                                    case "hsla":
                                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                                        break;
                                    default:
                                        console.warn("THREE.Color: Unknown color model " + t)
                                }
                            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                                const i = n[1],
                                    r = i.length;
                                if (3 === r) return this.setRGB(parseInt(i.charAt(0), 16) / 15, parseInt(i.charAt(1), 16) / 15, parseInt(i.charAt(2), 16) / 15, e);
                                if (6 === r) return this.setHex(parseInt(i, 16), e);
                                console.warn("THREE.Color: Invalid hex color " + t)
                            } else if (t && t.length > 0) return this.setColorName(t, e);
                            return this
                        }
                        setColorName(t, e = ue) {
                            const i = On[t.toLowerCase()];
                            return void 0 !== i ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this
                        }
                        clone() {
                            return new this.constructor(this.r, this.g, this.b)
                        }
                        copy(t) {
                            return this.r = t.r, this.g = t.g, this.b = t.b, this
                        }
                        copySRGBToLinear(t) {
                            return this.r = si(t.r), this.g = si(t.g), this.b = si(t.b), this
                        }
                        copyLinearToSRGB(t) {
                            return this.r = ai(t.r), this.g = ai(t.g), this.b = ai(t.b), this
                        }
                        convertSRGBToLinear() {
                            return this.copySRGBToLinear(this), this
                        }
                        convertLinearToSRGB() {
                            return this.copyLinearToSRGB(this), this
                        }
                        getHex(t = ue) {
                            return ri.fromWorkingColorSpace(Vn.copy(this), t), 65536 * Math.round(ze(255 * Vn.r, 0, 255)) + 256 * Math.round(ze(255 * Vn.g, 0, 255)) + Math.round(ze(255 * Vn.b, 0, 255))
                        }
                        getHexString(t = ue) {
                            return ("000000" + this.getHex(t).toString(16)).slice(-6)
                        }
                        getHSL(t, e = ri.workingColorSpace) {
                            ri.fromWorkingColorSpace(Vn.copy(this), e);
                            const i = Vn.r,
                                n = Vn.g,
                                r = Vn.b,
                                s = Math.max(i, n, r),
                                a = Math.min(i, n, r);
                            let o, l;
                            const h = (a + s) / 2;
                            if (a === s) o = 0, l = 0;
                            else {
                                const t = s - a;
                                switch (l = h <= .5 ? t / (s + a) : t / (2 - s - a), s) {
                                    case i:
                                        o = (n - r) / t + (n < r ? 6 : 0);
                                        break;
                                    case n:
                                        o = (r - i) / t + 2;
                                        break;
                                    case r:
                                        o = (i - n) / t + 4
                                }
                                o /= 6
                            }
                            return t.h = o, t.s = l, t.l = h, t
                        }
                        getRGB(t, e = ri.workingColorSpace) {
                            return ri.fromWorkingColorSpace(Vn.copy(this), e), t.r = Vn.r, t.g = Vn.g, t.b = Vn.b, t
                        }
                        getStyle(t = ue) {
                            ri.fromWorkingColorSpace(Vn.copy(this), t);
                            const e = Vn.r,
                                i = Vn.g,
                                n = Vn.b;
                            return t !== ue ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*i)},${Math.round(255*n)})`
                        }
                        offsetHSL(t, e, i) {
                            return this.getHSL(Bn), this.setHSL(Bn.h + t, Bn.s + e, Bn.l + i)
                        }
                        add(t) {
                            return this.r += t.r, this.g += t.g, this.b += t.b, this
                        }
                        addColors(t, e) {
                            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                        }
                        addScalar(t) {
                            return this.r += t, this.g += t, this.b += t, this
                        }
                        sub(t) {
                            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                        }
                        multiply(t) {
                            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                        }
                        multiplyScalar(t) {
                            return this.r *= t, this.g *= t, this.b *= t, this
                        }
                        lerp(t, e) {
                            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                        }
                        lerpColors(t, e, i) {
                            return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this
                        }
                        lerpHSL(t, e) {
                            this.getHSL(Bn), t.getHSL(zn);
                            const i = ke(Bn.h, zn.h, e),
                                n = ke(Bn.s, zn.s, e),
                                r = ke(Bn.l, zn.l, e);
                            return this.setHSL(i, n, r), this
                        }
                        setFromVector3(t) {
                            return this.r = t.x, this.g = t.y, this.b = t.z, this
                        }
                        applyMatrix3(t) {
                            const e = this.r,
                                i = this.g,
                                n = this.b,
                                r = t.elements;
                            return this.r = r[0] * e + r[3] * i + r[6] * n, this.g = r[1] * e + r[4] * i + r[7] * n, this.b = r[2] * e + r[5] * i + r[8] * n, this
                        }
                        equals(t) {
                            return t.r === this.r && t.g === this.g && t.b === this.b
                        }
                        fromArray(t, e = 0) {
                            return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
                        }
                        toJSON() {
                            return this.getHex()
                        }*[Symbol.iterator]() {
                            yield this.r, yield this.g, yield this.b
                        }
                    }
                    const Vn = new kn;
                    kn.NAMES = On;
                    let Hn = 0;
                    class Gn extends Le {
                        constructor() {
                            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                                value: Hn++
                            }), this.uuid = Be(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = g, this.blendDst = v, this.blendEquation = h, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new kn(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ye, this.stencilZFail = ye, this.stencilZPass = ye, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                        }
                        get alphaTest() {
                            return this._alphaTest
                        }
                        set alphaTest(t) {
                            this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                        }
                        onBeforeRender() {}
                        onBeforeCompile() {}
                        customProgramCacheKey() {
                            return this.onBeforeCompile.toString()
                        }
                        setValues(t) {
                            if (void 0 !== t)
                                for (const e in t) {
                                    const i = t[e];
                                    if (void 0 === i) {
                                        console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                                        continue
                                    }
                                    const n = this[e];
                                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                                }
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t;
                            e && (t = {
                                textures: {},
                                images: {}
                            });
                            const i = {
                                metadata: {
                                    version: 4.6,
                                    type: "Material",
                                    generator: "Material.toJSON"
                                }
                            };

                            function n(t) {
                                const e = [];
                                for (const i in t) {
                                    const n = t[i];
                                    delete n.metadata, e.push(n)
                                }
                                return e
                            }
                            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (i.dispersion = this.dispersion), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), !0 === this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = !0), this.blendSrc !== g && (i.blendSrc = this.blendSrc), this.blendDst !== v && (i.blendDst = this.blendDst), this.blendEquation !== h && (i.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (i.depthFunc = this.depthFunc), !1 === this.depthTest && (i.depthTest = this.depthTest), !1 === this.depthWrite && (i.depthWrite = this.depthWrite), !1 === this.colorWrite && (i.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (i.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ye && (i.stencilFail = this.stencilFail), this.stencilZFail !== ye && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== ye && (i.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaHash && (i.alphaHash = !0), !0 === this.alphaToCoverage && (i.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0), !0 === this.forceSinglePass && (i.forceSinglePass = !0), !0 === this.wireframe && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), e) {
                                const e = n(t.textures),
                                    r = n(t.images);
                                e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r)
                            }
                            return i
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                            const e = t.clippingPlanes;
                            let i = null;
                            if (null !== e) {
                                const t = e.length;
                                i = new Array(t);
                                for (let n = 0; n !== t; ++n) i[n] = e[n].clone()
                            }
                            return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        onBuild() {
                            console.warn("Material: onBuild() has been removed.")
                        }
                    }
                    class Wn extends Gn {
                        constructor(t) {
                            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new kn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new on, this.combine = E, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
                        }
                    }
                    const jn = Xn();

                    function Xn() {
                        const t = new ArrayBuffer(4),
                            e = new Float32Array(t),
                            i = new Uint32Array(t),
                            n = new Uint32Array(512),
                            r = new Uint32Array(512);
                        for (let t = 0; t < 256; ++t) {
                            const e = t - 127;
                            e < -27 ? (n[t] = 0, n[256 | t] = 32768, r[t] = 24, r[256 | t] = 24) : e < -14 ? (n[t] = 1024 >> -e - 14, n[256 | t] = 1024 >> -e - 14 | 32768, r[t] = -e - 1, r[256 | t] = -e - 1) : e <= 15 ? (n[t] = e + 15 << 10, n[256 | t] = e + 15 << 10 | 32768, r[t] = 13, r[256 | t] = 13) : e < 128 ? (n[t] = 31744, n[256 | t] = 64512, r[t] = 24, r[256 | t] = 24) : (n[t] = 31744, n[256 | t] = 64512, r[t] = 13, r[256 | t] = 13)
                        }
                        const s = new Uint32Array(2048),
                            a = new Uint32Array(64),
                            o = new Uint32Array(64);
                        for (let t = 1; t < 1024; ++t) {
                            let e = t << 13,
                                i = 0;
                            for (; !(8388608 & e);) e <<= 1, i -= 8388608;
                            e &= -8388609, i += 947912704, s[t] = e | i
                        }
                        for (let t = 1024; t < 2048; ++t) s[t] = 939524096 + (t - 1024 << 13);
                        for (let t = 1; t < 31; ++t) a[t] = t << 23;
                        a[31] = 1199570944, a[32] = 2147483648;
                        for (let t = 33; t < 63; ++t) a[t] = 2147483648 + (t - 32 << 23);
                        a[63] = 3347054592;
                        for (let t = 1; t < 64; ++t) 32 !== t && (o[t] = 1024);
                        return {
                            floatView: e,
                            uint32View: i,
                            baseTable: n,
                            shiftTable: r,
                            mantissaTable: s,
                            exponentTable: a,
                            offsetTable: o
                        }
                    }

                    function qn(t) {
                        Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = ze(t, -65504, 65504), jn.floatView[0] = t;
                        const e = jn.uint32View[0],
                            i = e >> 23 & 511;
                        return jn.baseTable[i] + ((8388607 & e) >> jn.shiftTable[i])
                    }

                    function Yn(t) {
                        const e = t >> 10;
                        return jn.uint32View[0] = jn.mantissaTable[jn.offsetTable[e] + (1023 & t)] + jn.exponentTable[e], jn.floatView[0]
                    }
                    const Jn = {
                            toHalfFloat: qn,
                            fromHalfFloat: Yn
                        },
                        Zn = new xi,
                        Kn = new We;
                    class Qn {
                        constructor(t, e, i = !1) {
                            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                            this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = i, this.usage = Ce, this._updateRange = {
                                offset: 0,
                                count: -1
                            }, this.updateRanges = [], this.gpuType = ot, this.version = 0
                        }
                        onUploadCallback() {}
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        get updateRange() {
                            return $e("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
                        }
                        setUsage(t) {
                            return this.usage = t, this
                        }
                        addUpdateRange(t, e) {
                            this.updateRanges.push({
                                start: t,
                                count: e
                            })
                        }
                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }
                        copy(t) {
                            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
                        }
                        copyAt(t, e, i) {
                            t *= this.itemSize, i *= e.itemSize;
                            for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                            return this
                        }
                        copyArray(t) {
                            return this.array.set(t), this
                        }
                        applyMatrix3(t) {
                            if (2 === this.itemSize)
                                for (let e = 0, i = this.count; e < i; e++) Kn.fromBufferAttribute(this, e), Kn.applyMatrix3(t), this.setXY(e, Kn.x, Kn.y);
                            else if (3 === this.itemSize)
                                for (let e = 0, i = this.count; e < i; e++) Zn.fromBufferAttribute(this, e), Zn.applyMatrix3(t), this.setXYZ(e, Zn.x, Zn.y, Zn.z);
                            return this
                        }
                        applyMatrix4(t) {
                            for (let e = 0, i = this.count; e < i; e++) Zn.fromBufferAttribute(this, e), Zn.applyMatrix4(t), this.setXYZ(e, Zn.x, Zn.y, Zn.z);
                            return this
                        }
                        applyNormalMatrix(t) {
                            for (let e = 0, i = this.count; e < i; e++) Zn.fromBufferAttribute(this, e), Zn.applyNormalMatrix(t), this.setXYZ(e, Zn.x, Zn.y, Zn.z);
                            return this
                        }
                        transformDirection(t) {
                            for (let e = 0, i = this.count; e < i; e++) Zn.fromBufferAttribute(this, e), Zn.transformDirection(t), this.setXYZ(e, Zn.x, Zn.y, Zn.z);
                            return this
                        }
                        set(t, e = 0) {
                            return this.array.set(t, e), this
                        }
                        getComponent(t, e) {
                            let i = this.array[t * this.itemSize + e];
                            return this.normalized && (i = Ve(i, this.array)), i
                        }
                        setComponent(t, e, i) {
                            return this.normalized && (i = He(i, this.array)), this.array[t * this.itemSize + e] = i, this
                        }
                        getX(t) {
                            let e = this.array[t * this.itemSize];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setX(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize] = e, this
                        }
                        getY(t) {
                            let e = this.array[t * this.itemSize + 1];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setY(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize + 1] = e, this
                        }
                        getZ(t) {
                            let e = this.array[t * this.itemSize + 2];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setZ(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize + 2] = e, this
                        }
                        getW(t) {
                            let e = this.array[t * this.itemSize + 3];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setW(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize + 3] = e, this
                        }
                        setXY(t, e, i) {
                            return t *= this.itemSize, this.normalized && (e = He(e, this.array), i = He(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this
                        }
                        setXYZ(t, e, i, n) {
                            return t *= this.itemSize, this.normalized && (e = He(e, this.array), i = He(i, this.array), n = He(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                        }
                        setXYZW(t, e, i, n, r) {
                            return t *= this.itemSize, this.normalized && (e = He(e, this.array), i = He(i, this.array), n = He(n, this.array), r = He(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                        }
                        onUpload(t) {
                            return this.onUploadCallback = t, this
                        }
                        clone() {
                            return new this.constructor(this.array, this.itemSize).copy(this)
                        }
                        toJSON() {
                            const t = {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: Array.from(this.array),
                                normalized: this.normalized
                            };
                            return "" !== this.name && (t.name = this.name), this.usage !== Ce && (t.usage = this.usage), t
                        }
                    }
                    class $n extends Qn {
                        constructor(t, e, i) {
                            super(new Uint16Array(t), e, i)
                        }
                    }
                    class tr extends Qn {
                        constructor(t, e, i) {
                            super(new Uint32Array(t), e, i)
                        }
                    }
                    class er extends Qn {
                        constructor(t, e, i) {
                            super(new Float32Array(t), e, i)
                        }
                    }
                    let ir = 0;
                    const nr = new Zi,
                        rr = new wn,
                        sr = new xi,
                        ar = new Si,
                        or = new Si,
                        lr = new xi;
                    class hr extends Le {
                        constructor() {
                            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                                value: ir++
                            }), this.uuid = Be(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                                start: 0,
                                count: 1 / 0
                            }, this.userData = {}
                        }
                        getIndex() {
                            return this.index
                        }
                        setIndex(t) {
                            return Array.isArray(t) ? this.index = new(qe(t) ? tr : $n)(t, 1) : this.index = t, this
                        }
                        getAttribute(t) {
                            return this.attributes[t]
                        }
                        setAttribute(t, e) {
                            return this.attributes[t] = e, this
                        }
                        deleteAttribute(t) {
                            return delete this.attributes[t], this
                        }
                        hasAttribute(t) {
                            return void 0 !== this.attributes[t]
                        }
                        addGroup(t, e, i = 0) {
                            this.groups.push({
                                start: t,
                                count: e,
                                materialIndex: i
                            })
                        }
                        clearGroups() {
                            this.groups = []
                        }
                        setDrawRange(t, e) {
                            this.drawRange.start = t, this.drawRange.count = e
                        }
                        applyMatrix4(t) {
                            const e = this.attributes.position;
                            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                            const i = this.attributes.normal;
                            if (void 0 !== i) {
                                const e = (new je).getNormalMatrix(t);
                                i.applyNormalMatrix(e), i.needsUpdate = !0
                            }
                            const n = this.attributes.tangent;
                            return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                        }
                        applyQuaternion(t) {
                            return nr.makeRotationFromQuaternion(t), this.applyMatrix4(nr), this
                        }
                        rotateX(t) {
                            return nr.makeRotationX(t), this.applyMatrix4(nr), this
                        }
                        rotateY(t) {
                            return nr.makeRotationY(t), this.applyMatrix4(nr), this
                        }
                        rotateZ(t) {
                            return nr.makeRotationZ(t), this.applyMatrix4(nr), this
                        }
                        translate(t, e, i) {
                            return nr.makeTranslation(t, e, i), this.applyMatrix4(nr), this
                        }
                        scale(t, e, i) {
                            return nr.makeScale(t, e, i), this.applyMatrix4(nr), this
                        }
                        lookAt(t) {
                            return rr.lookAt(t), rr.updateMatrix(), this.applyMatrix4(rr.matrix), this
                        }
                        center() {
                            return this.computeBoundingBox(), this.boundingBox.getCenter(sr).negate(), this.translate(sr.x, sr.y, sr.z), this
                        }
                        setFromPoints(t) {
                            const e = [];
                            for (let i = 0, n = t.length; i < n; i++) {
                                const n = t[i];
                                e.push(n.x, n.y, n.z || 0)
                            }
                            return this.setAttribute("position", new er(e, 3)), this
                        }
                        computeBoundingBox() {
                            null === this.boundingBox && (this.boundingBox = new Si);
                            const t = this.attributes.position,
                                e = this.morphAttributes.position;
                            if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new xi(-1 / 0, -1 / 0, -1 / 0), new xi(1 / 0, 1 / 0, 1 / 0));
                            if (void 0 !== t) {
                                if (this.boundingBox.setFromBufferAttribute(t), e)
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t];
                                        ar.setFromBufferAttribute(i), this.morphTargetsRelative ? (lr.addVectors(this.boundingBox.min, ar.min), this.boundingBox.expandByPoint(lr), lr.addVectors(this.boundingBox.max, ar.max), this.boundingBox.expandByPoint(lr)) : (this.boundingBox.expandByPoint(ar.min), this.boundingBox.expandByPoint(ar.max))
                                    }
                            } else this.boundingBox.makeEmpty();
                            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }
                        computeBoundingSphere() {
                            null === this.boundingSphere && (this.boundingSphere = new Vi);
                            const t = this.attributes.position,
                                e = this.morphAttributes.position;
                            if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new xi, 1 / 0);
                            if (t) {
                                const i = this.boundingSphere.center;
                                if (ar.setFromBufferAttribute(t), e)
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t];
                                        or.setFromBufferAttribute(i), this.morphTargetsRelative ? (lr.addVectors(ar.min, or.min), ar.expandByPoint(lr), lr.addVectors(ar.max, or.max), ar.expandByPoint(lr)) : (ar.expandByPoint(or.min), ar.expandByPoint(or.max))
                                    }
                                ar.getCenter(i);
                                let n = 0;
                                for (let e = 0, r = t.count; e < r; e++) lr.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(lr));
                                if (e)
                                    for (let r = 0, s = e.length; r < s; r++) {
                                        const s = e[r],
                                            a = this.morphTargetsRelative;
                                        for (let e = 0, r = s.count; e < r; e++) lr.fromBufferAttribute(s, e), a && (sr.fromBufferAttribute(t, e), lr.add(sr)), n = Math.max(n, i.distanceToSquared(lr))
                                    }
                                this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                        computeTangents() {
                            const t = this.index,
                                e = this.attributes;
                            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            const i = e.position,
                                n = e.normal,
                                r = e.uv;
                            !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Qn(new Float32Array(4 * i.count), 4));
                            const s = this.getAttribute("tangent"),
                                a = [],
                                o = [];
                            for (let t = 0; t < i.count; t++) a[t] = new xi, o[t] = new xi;
                            const l = new xi,
                                h = new xi,
                                c = new xi,
                                u = new We,
                                d = new We,
                                p = new We,
                                m = new xi,
                                f = new xi;

                            function g(t, e, n) {
                                l.fromBufferAttribute(i, t), h.fromBufferAttribute(i, e), c.fromBufferAttribute(i, n), u.fromBufferAttribute(r, t), d.fromBufferAttribute(r, e), p.fromBufferAttribute(r, n), h.sub(l), c.sub(l), d.sub(u), p.sub(u);
                                const s = 1 / (d.x * p.y - p.x * d.y);
                                isFinite(s) && (m.copy(h).multiplyScalar(p.y).addScaledVector(c, -d.y).multiplyScalar(s), f.copy(c).multiplyScalar(d.x).addScaledVector(h, -p.x).multiplyScalar(s), a[t].add(m), a[e].add(m), a[n].add(m), o[t].add(f), o[e].add(f), o[n].add(f))
                            }
                            let v = this.groups;
                            0 === v.length && (v = [{
                                start: 0,
                                count: t.count
                            }]);
                            for (let e = 0, i = v.length; e < i; ++e) {
                                const i = v[e],
                                    n = i.start;
                                for (let e = n, r = n + i.count; e < r; e += 3) g(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
                            }
                            const _ = new xi,
                                y = new xi,
                                x = new xi,
                                M = new xi;

                            function b(t) {
                                x.fromBufferAttribute(n, t), M.copy(x);
                                const e = a[t];
                                _.copy(e), _.sub(x.multiplyScalar(x.dot(e))).normalize(), y.crossVectors(M, e);
                                const i = y.dot(o[t]) < 0 ? -1 : 1;
                                s.setXYZW(t, _.x, _.y, _.z, i)
                            }
                            for (let e = 0, i = v.length; e < i; ++e) {
                                const i = v[e],
                                    n = i.start;
                                for (let e = n, r = n + i.count; e < r; e += 3) b(t.getX(e + 0)), b(t.getX(e + 1)), b(t.getX(e + 2))
                            }
                        }
                        computeVertexNormals() {
                            const t = this.index,
                                e = this.getAttribute("position");
                            if (void 0 !== e) {
                                let i = this.getAttribute("normal");
                                if (void 0 === i) i = new Qn(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                                else
                                    for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
                                const n = new xi,
                                    r = new xi,
                                    s = new xi,
                                    a = new xi,
                                    o = new xi,
                                    l = new xi,
                                    h = new xi,
                                    c = new xi;
                                if (t)
                                    for (let u = 0, d = t.count; u < d; u += 3) {
                                        const d = t.getX(u + 0),
                                            p = t.getX(u + 1),
                                            m = t.getX(u + 2);
                                        n.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, p), l.fromBufferAttribute(i, m), a.add(h), o.add(h), l.add(h), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(m, l.x, l.y, l.z)
                                    } else
                                        for (let t = 0, a = e.count; t < a; t += 3) n.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), i.setXYZ(t + 0, h.x, h.y, h.z), i.setXYZ(t + 1, h.x, h.y, h.z), i.setXYZ(t + 2, h.x, h.y, h.z);
                                this.normalizeNormals(), i.needsUpdate = !0
                            }
                        }
                        normalizeNormals() {
                            const t = this.attributes.normal;
                            for (let e = 0, i = t.count; e < i; e++) lr.fromBufferAttribute(t, e), lr.normalize(), t.setXYZ(e, lr.x, lr.y, lr.z)
                        }
                        toNonIndexed() {
                            function t(t, e) {
                                const i = t.array,
                                    n = t.itemSize,
                                    r = t.normalized,
                                    s = new i.constructor(e.length * n);
                                let a = 0,
                                    o = 0;
                                for (let r = 0, l = e.length; r < l; r++) {
                                    a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * n;
                                    for (let t = 0; t < n; t++) s[o++] = i[a++]
                                }
                                return new Qn(s, n, r)
                            }
                            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                            const e = new hr,
                                i = this.index.array,
                                n = this.attributes;
                            for (const r in n) {
                                const s = t(n[r], i);
                                e.setAttribute(r, s)
                            }
                            const r = this.morphAttributes;
                            for (const n in r) {
                                const s = [],
                                    a = r[n];
                                for (let e = 0, n = a.length; e < n; e++) {
                                    const n = t(a[e], i);
                                    s.push(n)
                                }
                                e.morphAttributes[n] = s
                            }
                            e.morphTargetsRelative = this.morphTargetsRelative;
                            const s = this.groups;
                            for (let t = 0, i = s.length; t < i; t++) {
                                const i = s[t];
                                e.addGroup(i.start, i.count, i.materialIndex)
                            }
                            return e
                        }
                        toJSON() {
                            const t = {
                                metadata: {
                                    version: 4.6,
                                    type: "BufferGeometry",
                                    generator: "BufferGeometry.toJSON"
                                }
                            };
                            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                                const e = this.parameters;
                                for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
                                return t
                            }
                            t.data = {
                                attributes: {}
                            };
                            const e = this.index;
                            null !== e && (t.data.index = {
                                type: e.array.constructor.name,
                                array: Array.prototype.slice.call(e.array)
                            });
                            const i = this.attributes;
                            for (const e in i) {
                                const n = i[e];
                                t.data.attributes[e] = n.toJSON(t.data)
                            }
                            const n = {};
                            let r = !1;
                            for (const e in this.morphAttributes) {
                                const i = this.morphAttributes[e],
                                    s = [];
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    s.push(n.toJSON(t.data))
                                }
                                s.length > 0 && (n[e] = s, r = !0)
                            }
                            r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
                            const s = this.groups;
                            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                            const a = this.boundingSphere;
                            return null !== a && (t.data.boundingSphere = {
                                center: a.center.toArray(),
                                radius: a.radius
                            }), t
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                            const e = {};
                            this.name = t.name;
                            const i = t.index;
                            null !== i && this.setIndex(i.clone(e));
                            const n = t.attributes;
                            for (const t in n) {
                                const i = n[t];
                                this.setAttribute(t, i.clone(e))
                            }
                            const r = t.morphAttributes;
                            for (const t in r) {
                                const i = [],
                                    n = r[t];
                                for (let t = 0, r = n.length; t < r; t++) i.push(n[t].clone(e));
                                this.morphAttributes[t] = i
                            }
                            this.morphTargetsRelative = t.morphTargetsRelative;
                            const s = t.groups;
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t];
                                this.addGroup(e.start, e.count, e.materialIndex)
                            }
                            const a = t.boundingBox;
                            null !== a && (this.boundingBox = a.clone());
                            const o = t.boundingSphere;
                            return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }
                    const cr = new Zi,
                        ur = new Ji,
                        dr = new Vi,
                        pr = new xi,
                        mr = new xi,
                        fr = new xi,
                        gr = new xi,
                        vr = new xi,
                        _r = new xi,
                        yr = new We,
                        xr = new We,
                        Mr = new We,
                        br = new xi,
                        Sr = new xi,
                        wr = new xi,
                        Ar = new xi,
                        Tr = new xi;
                    class Er extends wn {
                        constructor(t = new hr, e = new Wn) {
                            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                        }
                        copy(t, e) {
                            return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                        }
                        updateMorphTargets() {
                            const t = this.geometry.morphAttributes,
                                e = Object.keys(t);
                            if (e.length > 0) {
                                const i = t[e[0]];
                                if (void 0 !== i) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t].name || String(t);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                    }
                                }
                            }
                        }
                        getVertexPosition(t, e) {
                            const i = this.geometry,
                                n = i.attributes.position,
                                r = i.morphAttributes.position,
                                s = i.morphTargetsRelative;
                            e.fromBufferAttribute(n, t);
                            const a = this.morphTargetInfluences;
                            if (r && a) {
                                _r.set(0, 0, 0);
                                for (let i = 0, n = r.length; i < n; i++) {
                                    const n = a[i],
                                        o = r[i];
                                    0 !== n && (vr.fromBufferAttribute(o, t), s ? _r.addScaledVector(vr, n) : _r.addScaledVector(vr.sub(e), n))
                                }
                                e.add(_r)
                            }
                            return e
                        }
                        raycast(t, e) {
                            const i = this.geometry,
                                n = this.material,
                                r = this.matrixWorld;
                            if (void 0 !== n) {
                                if (null === i.boundingSphere && i.computeBoundingSphere(), dr.copy(i.boundingSphere), dr.applyMatrix4(r), ur.copy(t.ray).recast(t.near), !1 === dr.containsPoint(ur.origin)) {
                                    if (null === ur.intersectSphere(dr, pr)) return;
                                    if (ur.origin.distanceToSquared(pr) > (t.far - t.near) ** 2) return
                                }
                                cr.copy(r).invert(), ur.copy(t.ray).applyMatrix4(cr), null !== i.boundingBox && !1 === ur.intersectsBox(i.boundingBox) || this._computeIntersections(t, e, ur)
                            }
                        }
                        _computeIntersections(t, e, i) {
                            let n;
                            const r = this.geometry,
                                s = this.material,
                                a = r.index,
                                o = r.attributes.position,
                                l = r.attributes.uv,
                                h = r.attributes.uv1,
                                c = r.attributes.normal,
                                u = r.groups,
                                d = r.drawRange;
                            if (null !== a)
                                if (Array.isArray(s))
                                    for (let r = 0, o = u.length; r < o; r++) {
                                        const o = u[r],
                                            p = s[o.materialIndex];
                                        for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) n = Cr(this, p, t, i, l, h, c, a.getX(r), a.getX(r + 1), a.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = o.materialIndex, e.push(n))
                                    } else
                                        for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) n = Cr(this, s, t, i, l, h, c, a.getX(r), a.getX(r + 1), a.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), e.push(n));
                                else if (void 0 !== o)
                                if (Array.isArray(s))
                                    for (let r = 0, a = u.length; r < a; r++) {
                                        const a = u[r],
                                            p = s[a.materialIndex];
                                        for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) n = Cr(this, p, t, i, l, h, c, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = a.materialIndex, e.push(n))
                                    } else
                                        for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) n = Cr(this, s, t, i, l, h, c, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), e.push(n))
                        }
                    }

                    function Cr(t, e, i, n, r, s, a, o, l, h) {
                        t.getVertexPosition(o, mr), t.getVertexPosition(l, fr), t.getVertexPosition(h, gr);
                        const c = function(t, e, i, n, r, s, a, o) {
                            let l;
                            if (l = 1 === e.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 0 === e.side, o), null === l) return null;
                            Tr.copy(o), Tr.applyMatrix4(t.matrixWorld);
                            const h = i.ray.origin.distanceTo(Tr);
                            return h < i.near || h > i.far ? null : {
                                distance: h,
                                point: Tr.clone(),
                                object: t
                            }
                        }(t, e, i, n, mr, fr, gr, Ar);
                        if (c) {
                            r && (yr.fromBufferAttribute(r, o), xr.fromBufferAttribute(r, l), Mr.fromBufferAttribute(r, h), c.uv = Dn.getInterpolation(Ar, mr, fr, gr, yr, xr, Mr, new We)), s && (yr.fromBufferAttribute(s, o), xr.fromBufferAttribute(s, l), Mr.fromBufferAttribute(s, h), c.uv1 = Dn.getInterpolation(Ar, mr, fr, gr, yr, xr, Mr, new We)), a && (br.fromBufferAttribute(a, o), Sr.fromBufferAttribute(a, l), wr.fromBufferAttribute(a, h), c.normal = Dn.getInterpolation(Ar, mr, fr, gr, br, Sr, wr, new xi), c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1));
                            const t = {
                                a: o,
                                b: l,
                                c: h,
                                normal: new xi,
                                materialIndex: 0
                            };
                            Dn.getNormal(mr, fr, gr, t.normal), c.face = t
                        }
                        return c
                    }
                    class Rr extends hr {
                        constructor(t = 1, e = 1, i = 1, n = 1, r = 1, s = 1) {
                            super(), this.type = "BoxGeometry", this.parameters = {
                                width: t,
                                height: e,
                                depth: i,
                                widthSegments: n,
                                heightSegments: r,
                                depthSegments: s
                            };
                            const a = this;
                            n = Math.floor(n), r = Math.floor(r), s = Math.floor(s);
                            const o = [],
                                l = [],
                                h = [],
                                c = [];
                            let u = 0,
                                d = 0;

                            function p(t, e, i, n, r, s, p, m, f, g, v) {
                                const _ = s / f,
                                    y = p / g,
                                    x = s / 2,
                                    M = p / 2,
                                    b = m / 2,
                                    S = f + 1,
                                    w = g + 1;
                                let A = 0,
                                    T = 0;
                                const E = new xi;
                                for (let s = 0; s < w; s++) {
                                    const a = s * y - M;
                                    for (let o = 0; o < S; o++) {
                                        const u = o * _ - x;
                                        E[t] = u * n, E[e] = a * r, E[i] = b, l.push(E.x, E.y, E.z), E[t] = 0, E[e] = 0, E[i] = m > 0 ? 1 : -1, h.push(E.x, E.y, E.z), c.push(o / f), c.push(1 - s / g), A += 1
                                    }
                                }
                                for (let t = 0; t < g; t++)
                                    for (let e = 0; e < f; e++) {
                                        const i = u + e + S * t,
                                            n = u + e + S * (t + 1),
                                            r = u + (e + 1) + S * (t + 1),
                                            s = u + (e + 1) + S * t;
                                        o.push(i, n, s), o.push(n, r, s), T += 6
                                    }
                                a.addGroup(d, T, v), d += T, u += A
                            }
                            p("z", "y", "x", -1, -1, i, e, t, s, r, 0), p("z", "y", "x", 1, -1, i, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, s, 2), p("x", "z", "y", 1, -1, t, i, -e, n, s, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new er(l, 3)), this.setAttribute("normal", new er(h, 3)), this.setAttribute("uv", new er(c, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Rr(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                        }
                    }

                    function Pr(t) {
                        const e = {};
                        for (const i in t) {
                            e[i] = {};
                            for (const n in t[i]) {
                                const r = t[i][n];
                                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                            }
                        }
                        return e
                    }

                    function Ir(t) {
                        const e = {};
                        for (let i = 0; i < t.length; i++) {
                            const n = Pr(t[i]);
                            for (const t in n) e[t] = n[t]
                        }
                        return e
                    }

                    function Lr(t) {
                        const e = t.getRenderTarget();
                        return null === e ? t.outputColorSpace : !0 === e.isXRRenderTarget ? e.texture.colorSpace : ri.workingColorSpace
                    }
                    const Ur = {
                        clone: Pr,
                        merge: Ir
                    };
                    class Nr extends Gn {
                        constructor(t) {
                            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                                clipCullDistance: !1,
                                multiDraw: !1
                            }, this.defaultAttributeValues = {
                                color: [1, 1, 1],
                                uv: [0, 0],
                                uv1: [0, 0]
                            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Pr(t.uniforms), this.uniformsGroups = function(t) {
                                const e = [];
                                for (let i = 0; i < t.length; i++) e.push(t[i].clone());
                                return e
                            }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            e.glslVersion = this.glslVersion, e.uniforms = {};
                            for (const i in this.uniforms) {
                                const n = this.uniforms[i].value;
                                n && n.isTexture ? e.uniforms[i] = {
                                    type: "t",
                                    value: n.toJSON(t).uuid
                                } : n && n.isColor ? e.uniforms[i] = {
                                    type: "c",
                                    value: n.getHex()
                                } : n && n.isVector2 ? e.uniforms[i] = {
                                    type: "v2",
                                    value: n.toArray()
                                } : n && n.isVector3 ? e.uniforms[i] = {
                                    type: "v3",
                                    value: n.toArray()
                                } : n && n.isVector4 ? e.uniforms[i] = {
                                    type: "v4",
                                    value: n.toArray()
                                } : n && n.isMatrix3 ? e.uniforms[i] = {
                                    type: "m3",
                                    value: n.toArray()
                                } : n && n.isMatrix4 ? e.uniforms[i] = {
                                    type: "m4",
                                    value: n.toArray()
                                } : e.uniforms[i] = {
                                    value: n
                                }
                            }
                            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                            const i = {};
                            for (const t in this.extensions) !0 === this.extensions[t] && (i[t] = !0);
                            return Object.keys(i).length > 0 && (e.extensions = i), e
                        }
                    }
                    class Dr extends wn {
                        constructor() {
                            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Zi, this.projectionMatrix = new Zi, this.projectionMatrixInverse = new Zi, this.coordinateSystem = Pe
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
                        }
                        getWorldDirection(t) {
                            return super.getWorldDirection(t).negate()
                        }
                        updateMatrixWorld(t) {
                            super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }
                        updateWorldMatrix(t, e) {
                            super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const Or = new xi,
                        Br = new We,
                        zr = new We;
                    class Fr extends Dr {
                        constructor(t = 50, e = 1, i = .1, n = 2e3) {
                            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                        }
                        setFocalLength(t) {
                            const e = .5 * this.getFilmHeight() / t;
                            this.fov = 2 * Oe * Math.atan(e), this.updateProjectionMatrix()
                        }
                        getFocalLength() {
                            const t = Math.tan(.5 * De * this.fov);
                            return .5 * this.getFilmHeight() / t
                        }
                        getEffectiveFOV() {
                            return 2 * Oe * Math.atan(Math.tan(.5 * De * this.fov) / this.zoom)
                        }
                        getFilmWidth() {
                            return this.filmGauge * Math.min(this.aspect, 1)
                        }
                        getFilmHeight() {
                            return this.filmGauge / Math.max(this.aspect, 1)
                        }
                        getViewBounds(t, e, i) {
                            Or.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(Or.x, Or.y).multiplyScalar(-t / Or.z), Or.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(Or.x, Or.y).multiplyScalar(-t / Or.z)
                        }
                        getViewSize(t, e) {
                            return this.getViewBounds(t, Br, zr), e.subVectors(zr, Br)
                        }
                        setViewOffset(t, e, i, n, r, s) {
                            this.aspect = t / e, null === this.view && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                        }
                        clearViewOffset() {
                            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                        }
                        updateProjectionMatrix() {
                            const t = this.near;
                            let e = t * Math.tan(.5 * De * this.fov) / this.zoom,
                                i = 2 * e,
                                n = this.aspect * i,
                                r = -.5 * n;
                            const s = this.view;
                            if (null !== this.view && this.view.enabled) {
                                const t = s.fullWidth,
                                    a = s.fullHeight;
                                r += s.offsetX * n / t, e -= s.offsetY * i / a, n *= s.width / t, i *= s.height / a
                            }
                            const a = this.filmOffset;
                            0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                        }
                    }
                    const kr = -90;
                    class Vr extends wn {
                        constructor(t, e, i) {
                            super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                            const n = new Fr(kr, 1, t, e);
                            n.layers = this.layers, this.add(n);
                            const r = new Fr(kr, 1, t, e);
                            r.layers = this.layers, this.add(r);
                            const s = new Fr(kr, 1, t, e);
                            s.layers = this.layers, this.add(s);
                            const a = new Fr(kr, 1, t, e);
                            a.layers = this.layers, this.add(a);
                            const o = new Fr(kr, 1, t, e);
                            o.layers = this.layers, this.add(o);
                            const l = new Fr(kr, 1, t, e);
                            l.layers = this.layers, this.add(l)
                        }
                        updateCoordinateSystem() {
                            const t = this.coordinateSystem,
                                e = this.children.concat(),
                                [i, n, r, s, a, o] = e;
                            for (const t of e) this.remove(t);
                            if (t === Pe) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
                            else {
                                if (t !== Ie) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                                i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1)
                            }
                            for (const t of e) this.add(t), t.updateMatrixWorld()
                        }
                        update(t, e) {
                            null === this.parent && this.updateMatrixWorld();
                            const {
                                renderTarget: i,
                                activeMipmapLevel: n
                            } = this;
                            this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
                            const [r, s, a, o, l, h] = this.children, c = t.getRenderTarget(), u = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), p = t.xr.enabled;
                            t.xr.enabled = !1;
                            const m = i.texture.generateMipmaps;
                            i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0, n), t.render(e, r), t.setRenderTarget(i, 1, n), t.render(e, s), t.setRenderTarget(i, 2, n), t.render(e, a), t.setRenderTarget(i, 3, n), t.render(e, o), t.setRenderTarget(i, 4, n), t.render(e, l), i.texture.generateMipmaps = m, t.setRenderTarget(i, 5, n), t.render(e, h), t.setRenderTarget(c, u, d), t.xr.enabled = p, i.texture.needsPMREMUpdate = !0
                        }
                    }
                    class Hr extends pi {
                        constructor(t, e, i, n, r, s, a, o, l, h) {
                            super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : V, i, n, r, s, a, o, l, h), this.isCubeTexture = !0, this.flipY = !1
                        }
                        get images() {
                            return this.image
                        }
                        set images(t) {
                            this.image = t
                        }
                    }
                    class Gr extends gi {
                        constructor(t = 1, e = {}) {
                            super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                            const i = {
                                    width: t,
                                    height: t,
                                    depth: 1
                                },
                                n = [i, i, i, i, i, i];
                            this.texture = new Hr(n, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Q
                        }
                        fromEquirectangularTexture(t, e) {
                            this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                            const i = {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                                r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                                s = new Rr(5, 5, 5),
                                a = new Nr({
                                    name: "CubemapFromEquirect",
                                    uniforms: Pr(i),
                                    vertexShader: n,
                                    fragmentShader: r,
                                    side: 1,
                                    blending: 0
                                });
                            a.uniforms.tEquirect.value = e;
                            const o = new Er(s, a),
                                l = e.minFilter;
                            return e.minFilter === tt && (e.minFilter = Q), new Vr(1, 10, this).update(t, o), e.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
                        }
                        clear(t, e, i, n) {
                            const r = t.getRenderTarget();
                            for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, i, n);
                            t.setRenderTarget(r)
                        }
                    }
                    const Wr = new xi,
                        jr = new xi,
                        Xr = new je;
                    class qr {
                        constructor(t = new xi(1, 0, 0), e = 0) {
                            this.isPlane = !0, this.normal = t, this.constant = e
                        }
                        set(t, e) {
                            return this.normal.copy(t), this.constant = e, this
                        }
                        setComponents(t, e, i, n) {
                            return this.normal.set(t, e, i), this.constant = n, this
                        }
                        setFromNormalAndCoplanarPoint(t, e) {
                            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                        }
                        setFromCoplanarPoints(t, e, i) {
                            const n = Wr.subVectors(i, e).cross(jr.subVectors(t, e)).normalize();
                            return this.setFromNormalAndCoplanarPoint(n, t), this
                        }
                        copy(t) {
                            return this.normal.copy(t.normal), this.constant = t.constant, this
                        }
                        normalize() {
                            const t = 1 / this.normal.length();
                            return this.normal.multiplyScalar(t), this.constant *= t, this
                        }
                        negate() {
                            return this.constant *= -1, this.normal.negate(), this
                        }
                        distanceToPoint(t) {
                            return this.normal.dot(t) + this.constant
                        }
                        distanceToSphere(t) {
                            return this.distanceToPoint(t.center) - t.radius
                        }
                        projectPoint(t, e) {
                            return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
                        }
                        intersectLine(t, e) {
                            const i = t.delta(Wr),
                                n = this.normal.dot(i);
                            if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                            const r = -(t.start.dot(this.normal) + this.constant) / n;
                            return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(i, r)
                        }
                        intersectsLine(t) {
                            const e = this.distanceToPoint(t.start),
                                i = this.distanceToPoint(t.end);
                            return e < 0 && i > 0 || i < 0 && e > 0
                        }
                        intersectsBox(t) {
                            return t.intersectsPlane(this)
                        }
                        intersectsSphere(t) {
                            return t.intersectsPlane(this)
                        }
                        coplanarPoint(t) {
                            return t.copy(this.normal).multiplyScalar(-this.constant)
                        }
                        applyMatrix4(t, e) {
                            const i = e || Xr.getNormalMatrix(t),
                                n = this.coplanarPoint(Wr).applyMatrix4(t),
                                r = this.normal.applyMatrix3(i).normalize();
                            return this.constant = -n.dot(r), this
                        }
                        translate(t) {
                            return this.constant -= t.dot(this.normal), this
                        }
                        equals(t) {
                            return t.normal.equals(this.normal) && t.constant === this.constant
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const Yr = new Vi,
                        Jr = new xi;
                    class Zr {
                        constructor(t = new qr, e = new qr, i = new qr, n = new qr, r = new qr, s = new qr) {
                            this.planes = [t, e, i, n, r, s]
                        }
                        set(t, e, i, n, r, s) {
                            const a = this.planes;
                            return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this
                        }
                        copy(t) {
                            const e = this.planes;
                            for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                            return this
                        }
                        setFromProjectionMatrix(t, e = 2e3) {
                            const i = this.planes,
                                n = t.elements,
                                r = n[0],
                                s = n[1],
                                a = n[2],
                                o = n[3],
                                l = n[4],
                                h = n[5],
                                c = n[6],
                                u = n[7],
                                d = n[8],
                                p = n[9],
                                m = n[10],
                                f = n[11],
                                g = n[12],
                                v = n[13],
                                _ = n[14],
                                y = n[15];
                            if (i[0].setComponents(o - r, u - l, f - d, y - g).normalize(), i[1].setComponents(o + r, u + l, f + d, y + g).normalize(), i[2].setComponents(o + s, u + h, f + p, y + v).normalize(), i[3].setComponents(o - s, u - h, f - p, y - v).normalize(), i[4].setComponents(o - a, u - c, f - m, y - _).normalize(), e === Pe) i[5].setComponents(o + a, u + c, f + m, y + _).normalize();
                            else {
                                if (e !== Ie) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                                i[5].setComponents(a, c, m, _).normalize()
                            }
                            return this
                        }
                        intersectsObject(t) {
                            if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), Yr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                            else {
                                const e = t.geometry;
                                null === e.boundingSphere && e.computeBoundingSphere(), Yr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                            }
                            return this.intersectsSphere(Yr)
                        }
                        intersectsSprite(t) {
                            return Yr.center.set(0, 0, 0), Yr.radius = .7071067811865476, Yr.applyMatrix4(t.matrixWorld), this.intersectsSphere(Yr)
                        }
                        intersectsSphere(t) {
                            const e = this.planes,
                                i = t.center,
                                n = -t.radius;
                            for (let t = 0; t < 6; t++)
                                if (e[t].distanceToPoint(i) < n) return !1;
                            return !0
                        }
                        intersectsBox(t) {
                            const e = this.planes;
                            for (let i = 0; i < 6; i++) {
                                const n = e[i];
                                if (Jr.x = n.normal.x > 0 ? t.max.x : t.min.x, Jr.y = n.normal.y > 0 ? t.max.y : t.min.y, Jr.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(Jr) < 0) return !1
                            }
                            return !0
                        }
                        containsPoint(t) {
                            const e = this.planes;
                            for (let i = 0; i < 6; i++)
                                if (e[i].distanceToPoint(t) < 0) return !1;
                            return !0
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }

                    function Kr() {
                        let t = null,
                            e = !1,
                            i = null,
                            n = null;

                        function r(e, s) {
                            i(e, s), n = t.requestAnimationFrame(r)
                        }
                        return {
                            start: function() {
                                !0 !== e && null !== i && (n = t.requestAnimationFrame(r), e = !0)
                            },
                            stop: function() {
                                t.cancelAnimationFrame(n), e = !1
                            },
                            setAnimationLoop: function(t) {
                                i = t
                            },
                            setContext: function(e) {
                                t = e
                            }
                        }
                    }

                    function Qr(t) {
                        const e = new WeakMap;
                        return {
                            get: function(t) {
                                return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                            },
                            remove: function(i) {
                                i.isInterleavedBufferAttribute && (i = i.data);
                                const n = e.get(i);
                                n && (t.deleteBuffer(n.buffer), e.delete(i))
                            },
                            update: function(i, n) {
                                if (i.isInterleavedBufferAttribute && (i = i.data), i.isGLBufferAttribute) {
                                    const t = e.get(i);
                                    return void((!t || t.version < i.version) && e.set(i, {
                                        buffer: i.buffer,
                                        type: i.type,
                                        bytesPerElement: i.elementSize,
                                        version: i.version
                                    }))
                                }
                                const r = e.get(i);
                                if (void 0 === r) e.set(i, function(e, i) {
                                    const n = e.array,
                                        r = e.usage,
                                        s = n.byteLength,
                                        a = t.createBuffer();
                                    let o;
                                    if (t.bindBuffer(i, a), t.bufferData(i, n, r), e.onUploadCallback(), n instanceof Float32Array) o = t.FLOAT;
                                    else if (n instanceof Uint16Array) o = e.isFloat16BufferAttribute ? t.HALF_FLOAT : t.UNSIGNED_SHORT;
                                    else if (n instanceof Int16Array) o = t.SHORT;
                                    else if (n instanceof Uint32Array) o = t.UNSIGNED_INT;
                                    else if (n instanceof Int32Array) o = t.INT;
                                    else if (n instanceof Int8Array) o = t.BYTE;
                                    else if (n instanceof Uint8Array) o = t.UNSIGNED_BYTE;
                                    else {
                                        if (!(n instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + n);
                                        o = t.UNSIGNED_BYTE
                                    }
                                    return {
                                        buffer: a,
                                        type: o,
                                        bytesPerElement: n.BYTES_PER_ELEMENT,
                                        version: e.version,
                                        size: s
                                    }
                                }(i, n));
                                else if (r.version < i.version) {
                                    if (r.size !== i.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                                    ! function(e, i, n) {
                                        const r = i.array,
                                            s = i._updateRange,
                                            a = i.updateRanges;
                                        if (t.bindBuffer(n, e), -1 === s.count && 0 === a.length && t.bufferSubData(n, 0, r), 0 !== a.length) {
                                            for (let e = 0, i = a.length; e < i; e++) {
                                                const i = a[e];
                                                t.bufferSubData(n, i.start * r.BYTES_PER_ELEMENT, r, i.start, i.count)
                                            }
                                            i.clearUpdateRanges()
                                        } - 1 !== s.count && (t.bufferSubData(n, s.offset * r.BYTES_PER_ELEMENT, r, s.offset, s.count), s.count = -1), i.onUploadCallback()
                                    }(r.buffer, i, n), r.version = i.version
                                }
                            }
                        }
                    }
                    class $r extends hr {
                        constructor(t = 1, e = 1, i = 1, n = 1) {
                            super(), this.type = "PlaneGeometry", this.parameters = {
                                width: t,
                                height: e,
                                widthSegments: i,
                                heightSegments: n
                            };
                            const r = t / 2,
                                s = e / 2,
                                a = Math.floor(i),
                                o = Math.floor(n),
                                l = a + 1,
                                h = o + 1,
                                c = t / a,
                                u = e / o,
                                d = [],
                                p = [],
                                m = [],
                                f = [];
                            for (let t = 0; t < h; t++) {
                                const e = t * u - s;
                                for (let i = 0; i < l; i++) {
                                    const n = i * c - r;
                                    p.push(n, -e, 0), m.push(0, 0, 1), f.push(i / a), f.push(1 - t / o)
                                }
                            }
                            for (let t = 0; t < o; t++)
                                for (let e = 0; e < a; e++) {
                                    const i = e + l * t,
                                        n = e + l * (t + 1),
                                        r = e + 1 + l * (t + 1),
                                        s = e + 1 + l * t;
                                    d.push(i, n, s), d.push(n, r, s)
                                }
                            this.setIndex(d), this.setAttribute("position", new er(p, 3)), this.setAttribute("normal", new er(m, 3)), this.setAttribute("uv", new er(f, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new $r(t.width, t.height, t.widthSegments, t.heightSegments)
                        }
                    }
                    const ts = {
                            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                            alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                            batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
                            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
                            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
                            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                            colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
                            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                            morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                            morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
                            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
                            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
                            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
                        },
                        es = {
                            common: {
                                diffuse: {
                                    value: new kn(16777215)
                                },
                                opacity: {
                                    value: 1
                                },
                                map: {
                                    value: null
                                },
                                mapTransform: {
                                    value: new je
                                },
                                alphaMap: {
                                    value: null
                                },
                                alphaMapTransform: {
                                    value: new je
                                },
                                alphaTest: {
                                    value: 0
                                }
                            },
                            specularmap: {
                                specularMap: {
                                    value: null
                                },
                                specularMapTransform: {
                                    value: new je
                                }
                            },
                            envmap: {
                                envMap: {
                                    value: null
                                },
                                envMapRotation: {
                                    value: new je
                                },
                                flipEnvMap: {
                                    value: -1
                                },
                                reflectivity: {
                                    value: 1
                                },
                                ior: {
                                    value: 1.5
                                },
                                refractionRatio: {
                                    value: .98
                                }
                            },
                            aomap: {
                                aoMap: {
                                    value: null
                                },
                                aoMapIntensity: {
                                    value: 1
                                },
                                aoMapTransform: {
                                    value: new je
                                }
                            },
                            lightmap: {
                                lightMap: {
                                    value: null
                                },
                                lightMapIntensity: {
                                    value: 1
                                },
                                lightMapTransform: {
                                    value: new je
                                }
                            },
                            bumpmap: {
                                bumpMap: {
                                    value: null
                                },
                                bumpMapTransform: {
                                    value: new je
                                },
                                bumpScale: {
                                    value: 1
                                }
                            },
                            normalmap: {
                                normalMap: {
                                    value: null
                                },
                                normalMapTransform: {
                                    value: new je
                                },
                                normalScale: {
                                    value: new We(1, 1)
                                }
                            },
                            displacementmap: {
                                displacementMap: {
                                    value: null
                                },
                                displacementMapTransform: {
                                    value: new je
                                },
                                displacementScale: {
                                    value: 1
                                },
                                displacementBias: {
                                    value: 0
                                }
                            },
                            emissivemap: {
                                emissiveMap: {
                                    value: null
                                },
                                emissiveMapTransform: {
                                    value: new je
                                }
                            },
                            metalnessmap: {
                                metalnessMap: {
                                    value: null
                                },
                                metalnessMapTransform: {
                                    value: new je
                                }
                            },
                            roughnessmap: {
                                roughnessMap: {
                                    value: null
                                },
                                roughnessMapTransform: {
                                    value: new je
                                }
                            },
                            gradientmap: {
                                gradientMap: {
                                    value: null
                                }
                            },
                            fog: {
                                fogDensity: {
                                    value: 25e-5
                                },
                                fogNear: {
                                    value: 1
                                },
                                fogFar: {
                                    value: 2e3
                                },
                                fogColor: {
                                    value: new kn(16777215)
                                }
                            },
                            lights: {
                                ambientLightColor: {
                                    value: []
                                },
                                lightProbe: {
                                    value: []
                                },
                                directionalLights: {
                                    value: [],
                                    properties: {
                                        direction: {},
                                        color: {}
                                    }
                                },
                                directionalLightShadows: {
                                    value: [],
                                    properties: {
                                        shadowIntensity: 1,
                                        shadowBias: {},
                                        shadowNormalBias: {},
                                        shadowRadius: {},
                                        shadowMapSize: {}
                                    }
                                },
                                directionalShadowMap: {
                                    value: []
                                },
                                directionalShadowMatrix: {
                                    value: []
                                },
                                spotLights: {
                                    value: [],
                                    properties: {
                                        color: {},
                                        position: {},
                                        direction: {},
                                        distance: {},
                                        coneCos: {},
                                        penumbraCos: {},
                                        decay: {}
                                    }
                                },
                                spotLightShadows: {
                                    value: [],
                                    properties: {
                                        shadowIntensity: 1,
                                        shadowBias: {},
                                        shadowNormalBias: {},
                                        shadowRadius: {},
                                        shadowMapSize: {}
                                    }
                                },
                                spotLightMap: {
                                    value: []
                                },
                                spotShadowMap: {
                                    value: []
                                },
                                spotLightMatrix: {
                                    value: []
                                },
                                pointLights: {
                                    value: [],
                                    properties: {
                                        color: {},
                                        position: {},
                                        decay: {},
                                        distance: {}
                                    }
                                },
                                pointLightShadows: {
                                    value: [],
                                    properties: {
                                        shadowIntensity: 1,
                                        shadowBias: {},
                                        shadowNormalBias: {},
                                        shadowRadius: {},
                                        shadowMapSize: {},
                                        shadowCameraNear: {},
                                        shadowCameraFar: {}
                                    }
                                },
                                pointShadowMap: {
                                    value: []
                                },
                                pointShadowMatrix: {
                                    value: []
                                },
                                hemisphereLights: {
                                    value: [],
                                    properties: {
                                        direction: {},
                                        skyColor: {},
                                        groundColor: {}
                                    }
                                },
                                rectAreaLights: {
                                    value: [],
                                    properties: {
                                        color: {},
                                        position: {},
                                        width: {},
                                        height: {}
                                    }
                                },
                                ltc_1: {
                                    value: null
                                },
                                ltc_2: {
                                    value: null
                                }
                            },
                            points: {
                                diffuse: {
                                    value: new kn(16777215)
                                },
                                opacity: {
                                    value: 1
                                },
                                size: {
                                    value: 1
                                },
                                scale: {
                                    value: 1
                                },
                                map: {
                                    value: null
                                },
                                alphaMap: {
                                    value: null
                                },
                                alphaMapTransform: {
                                    value: new je
                                },
                                alphaTest: {
                                    value: 0
                                },
                                uvTransform: {
                                    value: new je
                                }
                            },
                            sprite: {
                                diffuse: {
                                    value: new kn(16777215)
                                },
                                opacity: {
                                    value: 1
                                },
                                center: {
                                    value: new We(.5, .5)
                                },
                                rotation: {
                                    value: 0
                                },
                                map: {
                                    value: null
                                },
                                mapTransform: {
                                    value: new je
                                },
                                alphaMap: {
                                    value: null
                                },
                                alphaMapTransform: {
                                    value: new je
                                },
                                alphaTest: {
                                    value: 0
                                }
                            }
                        },
                        is = {
                            basic: {
                                uniforms: Ir([es.common, es.specularmap, es.envmap, es.aomap, es.lightmap, es.fog]),
                                vertexShader: ts.meshbasic_vert,
                                fragmentShader: ts.meshbasic_frag
                            },
                            lambert: {
                                uniforms: Ir([es.common, es.specularmap, es.envmap, es.aomap, es.lightmap, es.emissivemap, es.bumpmap, es.normalmap, es.displacementmap, es.fog, es.lights, {
                                    emissive: {
                                        value: new kn(0)
                                    }
                                }]),
                                vertexShader: ts.meshlambert_vert,
                                fragmentShader: ts.meshlambert_frag
                            },
                            phong: {
                                uniforms: Ir([es.common, es.specularmap, es.envmap, es.aomap, es.lightmap, es.emissivemap, es.bumpmap, es.normalmap, es.displacementmap, es.fog, es.lights, {
                                    emissive: {
                                        value: new kn(0)
                                    },
                                    specular: {
                                        value: new kn(1118481)
                                    },
                                    shininess: {
                                        value: 30
                                    }
                                }]),
                                vertexShader: ts.meshphong_vert,
                                fragmentShader: ts.meshphong_frag
                            },
                            standard: {
                                uniforms: Ir([es.common, es.envmap, es.aomap, es.lightmap, es.emissivemap, es.bumpmap, es.normalmap, es.displacementmap, es.roughnessmap, es.metalnessmap, es.fog, es.lights, {
                                    emissive: {
                                        value: new kn(0)
                                    },
                                    roughness: {
                                        value: 1
                                    },
                                    metalness: {
                                        value: 0
                                    },
                                    envMapIntensity: {
                                        value: 1
                                    }
                                }]),
                                vertexShader: ts.meshphysical_vert,
                                fragmentShader: ts.meshphysical_frag
                            },
                            toon: {
                                uniforms: Ir([es.common, es.aomap, es.lightmap, es.emissivemap, es.bumpmap, es.normalmap, es.displacementmap, es.gradientmap, es.fog, es.lights, {
                                    emissive: {
                                        value: new kn(0)
                                    }
                                }]),
                                vertexShader: ts.meshtoon_vert,
                                fragmentShader: ts.meshtoon_frag
                            },
                            matcap: {
                                uniforms: Ir([es.common, es.bumpmap, es.normalmap, es.displacementmap, es.fog, {
                                    matcap: {
                                        value: null
                                    }
                                }]),
                                vertexShader: ts.meshmatcap_vert,
                                fragmentShader: ts.meshmatcap_frag
                            },
                            points: {
                                uniforms: Ir([es.points, es.fog]),
                                vertexShader: ts.points_vert,
                                fragmentShader: ts.points_frag
                            },
                            dashed: {
                                uniforms: Ir([es.common, es.fog, {
                                    scale: {
                                        value: 1
                                    },
                                    dashSize: {
                                        value: 1
                                    },
                                    totalSize: {
                                        value: 2
                                    }
                                }]),
                                vertexShader: ts.linedashed_vert,
                                fragmentShader: ts.linedashed_frag
                            },
                            depth: {
                                uniforms: Ir([es.common, es.displacementmap]),
                                vertexShader: ts.depth_vert,
                                fragmentShader: ts.depth_frag
                            },
                            normal: {
                                uniforms: Ir([es.common, es.bumpmap, es.normalmap, es.displacementmap, {
                                    opacity: {
                                        value: 1
                                    }
                                }]),
                                vertexShader: ts.meshnormal_vert,
                                fragmentShader: ts.meshnormal_frag
                            },
                            sprite: {
                                uniforms: Ir([es.sprite, es.fog]),
                                vertexShader: ts.sprite_vert,
                                fragmentShader: ts.sprite_frag
                            },
                            background: {
                                uniforms: {
                                    uvTransform: {
                                        value: new je
                                    },
                                    t2D: {
                                        value: null
                                    },
                                    backgroundIntensity: {
                                        value: 1
                                    }
                                },
                                vertexShader: ts.background_vert,
                                fragmentShader: ts.background_frag
                            },
                            backgroundCube: {
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    flipEnvMap: {
                                        value: -1
                                    },
                                    backgroundBlurriness: {
                                        value: 0
                                    },
                                    backgroundIntensity: {
                                        value: 1
                                    },
                                    backgroundRotation: {
                                        value: new je
                                    }
                                },
                                vertexShader: ts.backgroundCube_vert,
                                fragmentShader: ts.backgroundCube_frag
                            },
                            cube: {
                                uniforms: {
                                    tCube: {
                                        value: null
                                    },
                                    tFlip: {
                                        value: -1
                                    },
                                    opacity: {
                                        value: 1
                                    }
                                },
                                vertexShader: ts.cube_vert,
                                fragmentShader: ts.cube_frag
                            },
                            equirect: {
                                uniforms: {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                vertexShader: ts.equirect_vert,
                                fragmentShader: ts.equirect_frag
                            },
                            distanceRGBA: {
                                uniforms: Ir([es.common, es.displacementmap, {
                                    referencePosition: {
                                        value: new xi
                                    },
                                    nearDistance: {
                                        value: 1
                                    },
                                    farDistance: {
                                        value: 1e3
                                    }
                                }]),
                                vertexShader: ts.distanceRGBA_vert,
                                fragmentShader: ts.distanceRGBA_frag
                            },
                            shadow: {
                                uniforms: Ir([es.lights, es.fog, {
                                    color: {
                                        value: new kn(0)
                                    },
                                    opacity: {
                                        value: 1
                                    }
                                }]),
                                vertexShader: ts.shadow_vert,
                                fragmentShader: ts.shadow_frag
                            }
                        };
                    is.physical = {
                        uniforms: Ir([is.standard.uniforms, {
                            clearcoat: {
                                value: 0
                            },
                            clearcoatMap: {
                                value: null
                            },
                            clearcoatMapTransform: {
                                value: new je
                            },
                            clearcoatNormalMap: {
                                value: null
                            },
                            clearcoatNormalMapTransform: {
                                value: new je
                            },
                            clearcoatNormalScale: {
                                value: new We(1, 1)
                            },
                            clearcoatRoughness: {
                                value: 0
                            },
                            clearcoatRoughnessMap: {
                                value: null
                            },
                            clearcoatRoughnessMapTransform: {
                                value: new je
                            },
                            dispersion: {
                                value: 0
                            },
                            iridescence: {
                                value: 0
                            },
                            iridescenceMap: {
                                value: null
                            },
                            iridescenceMapTransform: {
                                value: new je
                            },
                            iridescenceIOR: {
                                value: 1.3
                            },
                            iridescenceThicknessMinimum: {
                                value: 100
                            },
                            iridescenceThicknessMaximum: {
                                value: 400
                            },
                            iridescenceThicknessMap: {
                                value: null
                            },
                            iridescenceThicknessMapTransform: {
                                value: new je
                            },
                            sheen: {
                                value: 0
                            },
                            sheenColor: {
                                value: new kn(0)
                            },
                            sheenColorMap: {
                                value: null
                            },
                            sheenColorMapTransform: {
                                value: new je
                            },
                            sheenRoughness: {
                                value: 1
                            },
                            sheenRoughnessMap: {
                                value: null
                            },
                            sheenRoughnessMapTransform: {
                                value: new je
                            },
                            transmission: {
                                value: 0
                            },
                            transmissionMap: {
                                value: null
                            },
                            transmissionMapTransform: {
                                value: new je
                            },
                            transmissionSamplerSize: {
                                value: new We
                            },
                            transmissionSamplerMap: {
                                value: null
                            },
                            thickness: {
                                value: 0
                            },
                            thicknessMap: {
                                value: null
                            },
                            thicknessMapTransform: {
                                value: new je
                            },
                            attenuationDistance: {
                                value: 0
                            },
                            attenuationColor: {
                                value: new kn(0)
                            },
                            specularColor: {
                                value: new kn(1, 1, 1)
                            },
                            specularColorMap: {
                                value: null
                            },
                            specularColorMapTransform: {
                                value: new je
                            },
                            specularIntensity: {
                                value: 1
                            },
                            specularIntensityMap: {
                                value: null
                            },
                            specularIntensityMapTransform: {
                                value: new je
                            },
                            anisotropyVector: {
                                value: new We
                            },
                            anisotropyMap: {
                                value: null
                            },
                            anisotropyMapTransform: {
                                value: new je
                            }
                        }]),
                        vertexShader: ts.meshphysical_vert,
                        fragmentShader: ts.meshphysical_frag
                    };
                    const ns = {
                            r: 0,
                            b: 0,
                            g: 0
                        },
                        rs = new on,
                        ss = new Zi;

                    function as(t, e, i, n, r, s, a) {
                        const o = new kn(0);
                        let l, h, c = !0 === s ? 0 : 1,
                            u = null,
                            d = 0,
                            p = null;

                        function m(t) {
                            let n = !0 === t.isScene ? t.background : null;
                            return n && n.isTexture && (n = (t.backgroundBlurriness > 0 ? i : e).get(n)), n
                        }

                        function f(e, i) {
                            e.getRGB(ns, Lr(t)), n.buffers.color.setClear(ns.r, ns.g, ns.b, i, a)
                        }
                        return {
                            getClearColor: function() {
                                return o
                            },
                            setClearColor: function(t, e = 1) {
                                o.set(t), c = e, f(o, c)
                            },
                            getClearAlpha: function() {
                                return c
                            },
                            setClearAlpha: function(t) {
                                c = t, f(o, c)
                            },
                            render: function(e) {
                                let i = !1;
                                const r = m(e);
                                null === r ? f(o, c) : r && r.isColor && (f(r, 1), i = !0);
                                const s = t.xr.getEnvironmentBlendMode();
                                "additive" === s ? n.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === s && n.buffers.color.setClear(0, 0, 0, 0, a), (t.autoClear || i) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil))
                            },
                            addToRenderList: function(e, i) {
                                const n = m(i);
                                n && (n.isCubeTexture || n.mapping === j) ? (void 0 === h && (h = new Er(new Rr(1, 1, 1), new Nr({
                                    name: "BackgroundCubeMaterial",
                                    uniforms: Pr(is.backgroundCube.uniforms),
                                    vertexShader: is.backgroundCube.vertexShader,
                                    fragmentShader: is.backgroundCube.fragmentShader,
                                    side: 1,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(t, e, i) {
                                    this.matrixWorld.copyPosition(i.matrixWorld)
                                }, Object.defineProperty(h.material, "envMap", {
                                    get: function() {
                                        return this.uniforms.envMap.value
                                    }
                                }), r.update(h)), rs.copy(i.backgroundRotation), rs.x *= -1, rs.y *= -1, rs.z *= -1, n.isCubeTexture && !1 === n.isRenderTargetTexture && (rs.y *= -1, rs.z *= -1), h.material.uniforms.envMap.value = n, h.material.uniforms.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = i.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = i.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(ss.makeRotationFromEuler(rs)), h.material.toneMapped = ri.getTransfer(n.colorSpace) !== ge, u === n && d === n.version && p === t.toneMapping || (h.material.needsUpdate = !0, u = n, d = n.version, p = t.toneMapping), h.layers.enableAll(), e.unshift(h, h.geometry, h.material, 0, 0, null)) : n && n.isTexture && (void 0 === l && (l = new Er(new $r(2, 2), new Nr({
                                    name: "BackgroundMaterial",
                                    uniforms: Pr(is.background.uniforms),
                                    vertexShader: is.background.vertexShader,
                                    fragmentShader: is.background.fragmentShader,
                                    side: 0,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                                    get: function() {
                                        return this.uniforms.t2D.value
                                    }
                                }), r.update(l)), l.material.uniforms.t2D.value = n, l.material.uniforms.backgroundIntensity.value = i.backgroundIntensity, l.material.toneMapped = ri.getTransfer(n.colorSpace) !== ge, !0 === n.matrixAutoUpdate && n.updateMatrix(), l.material.uniforms.uvTransform.value.copy(n.matrix), u === n && d === n.version && p === t.toneMapping || (l.material.needsUpdate = !0, u = n, d = n.version, p = t.toneMapping), l.layers.enableAll(), e.unshift(l, l.geometry, l.material, 0, 0, null))
                            }
                        }
                    }

                    function os(t, e) {
                        const i = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                            n = {},
                            r = h(null);
                        let s = r,
                            a = !1;

                        function o(e) {
                            return t.bindVertexArray(e)
                        }

                        function l(e) {
                            return t.deleteVertexArray(e)
                        }

                        function h(t) {
                            const e = [],
                                n = [],
                                r = [];
                            for (let t = 0; t < i; t++) e[t] = 0, n[t] = 0, r[t] = 0;
                            return {
                                geometry: null,
                                program: null,
                                wireframe: !1,
                                newAttributes: e,
                                enabledAttributes: n,
                                attributeDivisors: r,
                                object: t,
                                attributes: {},
                                index: null
                            }
                        }

                        function c() {
                            const t = s.newAttributes;
                            for (let e = 0, i = t.length; e < i; e++) t[e] = 0
                        }

                        function u(t) {
                            d(t, 0)
                        }

                        function d(e, i) {
                            const n = s.newAttributes,
                                r = s.enabledAttributes,
                                a = s.attributeDivisors;
                            n[e] = 1, 0 === r[e] && (t.enableVertexAttribArray(e), r[e] = 1), a[e] !== i && (t.vertexAttribDivisor(e, i), a[e] = i)
                        }

                        function p() {
                            const e = s.newAttributes,
                                i = s.enabledAttributes;
                            for (let n = 0, r = i.length; n < r; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), i[n] = 0)
                        }

                        function m(e, i, n, r, s, a, o) {
                            !0 === o ? t.vertexAttribIPointer(e, i, n, s, a) : t.vertexAttribPointer(e, i, n, r, s, a)
                        }

                        function f() {
                            g(), a = !0, s !== r && (s = r, o(s.object))
                        }

                        function g() {
                            r.geometry = null, r.program = null, r.wireframe = !1
                        }
                        return {
                            setup: function(i, r, l, f, g) {
                                let v = !1;
                                const _ = function(e, i, r) {
                                    const s = !0 === r.wireframe;
                                    let a = n[e.id];
                                    void 0 === a && (a = {}, n[e.id] = a);
                                    let o = a[i.id];
                                    void 0 === o && (o = {}, a[i.id] = o);
                                    let l = o[s];
                                    return void 0 === l && (l = h(t.createVertexArray()), o[s] = l), l
                                }(f, l, r);
                                s !== _ && (s = _, o(s.object)), v = function(t, e, i, n) {
                                    const r = s.attributes,
                                        a = e.attributes;
                                    let o = 0;
                                    const l = i.getAttributes();
                                    for (const e in l)
                                        if (l[e].location >= 0) {
                                            const i = r[e];
                                            let n = a[e];
                                            if (void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor)), void 0 === i) return !0;
                                            if (i.attribute !== n) return !0;
                                            if (n && i.data !== n.data) return !0;
                                            o++
                                        } return s.attributesNum !== o || s.index !== n
                                }(i, f, l, g), v && function(t, e, i, n) {
                                    const r = {},
                                        a = e.attributes;
                                    let o = 0;
                                    const l = i.getAttributes();
                                    for (const e in l)
                                        if (l[e].location >= 0) {
                                            let i = a[e];
                                            void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor));
                                            const n = {};
                                            n.attribute = i, i && i.data && (n.data = i.data), r[e] = n, o++
                                        } s.attributes = r, s.attributesNum = o, s.index = n
                                }(i, f, l, g), null !== g && e.update(g, t.ELEMENT_ARRAY_BUFFER), (v || a) && (a = !1, function(i, n, r, s) {
                                    c();
                                    const a = s.attributes,
                                        o = r.getAttributes(),
                                        l = n.defaultAttributeValues;
                                    for (const n in o) {
                                        const r = o[n];
                                        if (r.location >= 0) {
                                            let o = a[n];
                                            if (void 0 === o && ("instanceMatrix" === n && i.instanceMatrix && (o = i.instanceMatrix), "instanceColor" === n && i.instanceColor && (o = i.instanceColor)), void 0 !== o) {
                                                const n = o.normalized,
                                                    a = o.itemSize,
                                                    l = e.get(o);
                                                if (void 0 === l) continue;
                                                const h = l.buffer,
                                                    c = l.type,
                                                    p = l.bytesPerElement,
                                                    f = c === t.INT || c === t.UNSIGNED_INT || o.gpuType === st;
                                                if (o.isInterleavedBufferAttribute) {
                                                    const e = o.data,
                                                        l = e.stride,
                                                        g = o.offset;
                                                    if (e.isInstancedInterleavedBuffer) {
                                                        for (let t = 0; t < r.locationSize; t++) d(r.location + t, e.meshPerAttribute);
                                                        !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = e.meshPerAttribute * e.count)
                                                    } else
                                                        for (let t = 0; t < r.locationSize; t++) u(r.location + t);
                                                    t.bindBuffer(t.ARRAY_BUFFER, h);
                                                    for (let t = 0; t < r.locationSize; t++) m(r.location + t, a / r.locationSize, c, n, l * p, (g + a / r.locationSize * t) * p, f)
                                                } else {
                                                    if (o.isInstancedBufferAttribute) {
                                                        for (let t = 0; t < r.locationSize; t++) d(r.location + t, o.meshPerAttribute);
                                                        !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)
                                                    } else
                                                        for (let t = 0; t < r.locationSize; t++) u(r.location + t);
                                                    t.bindBuffer(t.ARRAY_BUFFER, h);
                                                    for (let t = 0; t < r.locationSize; t++) m(r.location + t, a / r.locationSize, c, n, a * p, a / r.locationSize * t * p, f)
                                                }
                                            } else if (void 0 !== l) {
                                                const e = l[n];
                                                if (void 0 !== e) switch (e.length) {
                                                    case 2:
                                                        t.vertexAttrib2fv(r.location, e);
                                                        break;
                                                    case 3:
                                                        t.vertexAttrib3fv(r.location, e);
                                                        break;
                                                    case 4:
                                                        t.vertexAttrib4fv(r.location, e);
                                                        break;
                                                    default:
                                                        t.vertexAttrib1fv(r.location, e)
                                                }
                                            }
                                        }
                                    }
                                    p()
                                }(i, r, l, f), null !== g && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(g).buffer))
                            },
                            reset: f,
                            resetDefaultState: g,
                            dispose: function() {
                                f();
                                for (const t in n) {
                                    const e = n[t];
                                    for (const t in e) {
                                        const i = e[t];
                                        for (const t in i) l(i[t].object), delete i[t];
                                        delete e[t]
                                    }
                                    delete n[t]
                                }
                            },
                            releaseStatesOfGeometry: function(t) {
                                if (void 0 === n[t.id]) return;
                                const e = n[t.id];
                                for (const t in e) {
                                    const i = e[t];
                                    for (const t in i) l(i[t].object), delete i[t];
                                    delete e[t]
                                }
                                delete n[t.id]
                            },
                            releaseStatesOfProgram: function(t) {
                                for (const e in n) {
                                    const i = n[e];
                                    if (void 0 === i[t.id]) continue;
                                    const r = i[t.id];
                                    for (const t in r) l(r[t].object), delete r[t];
                                    delete i[t.id]
                                }
                            },
                            initAttributes: c,
                            enableAttribute: u,
                            disableUnusedAttributes: p
                        }
                    }

                    function ls(t, e, i) {
                        let n;

                        function r(e, r, s) {
                            0 !== s && (t.drawArraysInstanced(n, e, r, s), i.update(r, n, s))
                        }
                        this.setMode = function(t) {
                            n = t
                        }, this.render = function(e, r) {
                            t.drawArrays(n, e, r), i.update(r, n, 1)
                        }, this.renderInstances = r, this.renderMultiDraw = function(t, r, s) {
                            if (0 === s) return;
                            e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, t, 0, r, 0, s);
                            let a = 0;
                            for (let t = 0; t < s; t++) a += r[t];
                            i.update(a, n, 1)
                        }, this.renderMultiDrawInstances = function(t, s, a, o) {
                            if (0 === a) return;
                            const l = e.get("WEBGL_multi_draw");
                            if (null === l)
                                for (let e = 0; e < t.length; e++) r(t[e], s[e], o[e]);
                            else {
                                l.multiDrawArraysInstancedWEBGL(n, t, 0, s, 0, o, 0, a);
                                let e = 0;
                                for (let t = 0; t < a; t++) e += s[t];
                                for (let t = 0; t < o.length; t++) i.update(e, n, o[t])
                            }
                        }
                    }

                    function hs(t, e, i, n) {
                        let r;

                        function s(e) {
                            if ("highp" === e) {
                                if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                                e = "mediump"
                            }
                            return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                        }
                        let a = void 0 !== i.precision ? i.precision : "highp";
                        const o = s(a);
                        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
                        const l = !0 === i.logarithmicDepthBuffer,
                            h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                            c = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                        return {
                            isWebGL2: !0,
                            getMaxAnisotropy: function() {
                                if (void 0 !== r) return r;
                                if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                    const i = e.get("EXT_texture_filter_anisotropic");
                                    r = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                                } else r = 0;
                                return r
                            },
                            getMaxPrecision: s,
                            textureFormatReadable: function(e) {
                                return e === ft || n.convert(e) === t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)
                            },
                            textureTypeReadable: function(i) {
                                const r = i === lt && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
                                return !(i !== et && n.convert(i) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) && i !== ot && !r)
                            },
                            precision: a,
                            logarithmicDepthBuffer: l,
                            maxTextures: h,
                            maxVertexTextures: c,
                            maxTextureSize: t.getParameter(t.MAX_TEXTURE_SIZE),
                            maxCubemapSize: t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                            maxAttributes: t.getParameter(t.MAX_VERTEX_ATTRIBS),
                            maxVertexUniforms: t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                            maxVaryings: t.getParameter(t.MAX_VARYING_VECTORS),
                            maxFragmentUniforms: t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                            vertexTextures: c > 0,
                            maxSamples: t.getParameter(t.MAX_SAMPLES)
                        }
                    }

                    function cs(t) {
                        const e = this;
                        let i = null,
                            n = 0,
                            r = !1,
                            s = !1;
                        const a = new qr,
                            o = new je,
                            l = {
                                value: null,
                                needsUpdate: !1
                            };

                        function h(t, i, n, r) {
                            const s = null !== t ? t.length : 0;
                            let h = null;
                            if (0 !== s) {
                                if (h = l.value, !0 !== r || null === h) {
                                    const e = n + 4 * s,
                                        r = i.matrixWorldInverse;
                                    o.getNormalMatrix(r), (null === h || h.length < e) && (h = new Float32Array(e));
                                    for (let e = 0, i = n; e !== s; ++e, i += 4) a.copy(t[e]).applyMatrix4(r, o), a.normal.toArray(h, i), h[i + 3] = a.constant
                                }
                                l.value = h, l.needsUpdate = !0
                            }
                            return e.numPlanes = s, e.numIntersection = 0, h
                        }
                        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e) {
                            const i = 0 !== t.length || e || 0 !== n || r;
                            return r = e, n = t.length, i
                        }, this.beginShadows = function() {
                            s = !0, h(null)
                        }, this.endShadows = function() {
                            s = !1
                        }, this.setGlobalState = function(t, e) {
                            i = h(t, e, 0)
                        }, this.setState = function(a, o, c) {
                            const u = a.clippingPlanes,
                                d = a.clipIntersection,
                                p = a.clipShadows,
                                m = t.get(a);
                            if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : (l.value !== i && (l.value = i, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0);
                            else {
                                const t = s ? 0 : n,
                                    e = 4 * t;
                                let r = m.clippingState || null;
                                l.value = r, r = h(u, o, e, c);
                                for (let t = 0; t !== e; ++t) r[t] = i[t];
                                m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                            }
                        }
                    }

                    function us(t) {
                        let e = new WeakMap;

                        function i(t, e) {
                            return e === G ? t.mapping = V : e === W && (t.mapping = H), t
                        }

                        function n(t) {
                            const i = t.target;
                            i.removeEventListener("dispose", n);
                            const r = e.get(i);
                            void 0 !== r && (e.delete(i), r.dispose())
                        }
                        return {
                            get: function(r) {
                                if (r && r.isTexture) {
                                    const s = r.mapping;
                                    if (s === G || s === W) {
                                        if (e.has(r)) return i(e.get(r).texture, r.mapping);
                                        {
                                            const s = r.image;
                                            if (s && s.height > 0) {
                                                const a = new Gr(s.height);
                                                return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", n), i(a.texture, r.mapping)
                                            }
                                            return null
                                        }
                                    }
                                }
                                return r
                            },
                            dispose: function() {
                                e = new WeakMap
                            }
                        }
                    }
                    class ds extends Dr {
                        constructor(t = -1, e = 1, i = 1, n = -1, r = .1, s = 2e3) {
                            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = r, this.far = s, this.updateProjectionMatrix()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                        }
                        setViewOffset(t, e, i, n, r, s) {
                            null === this.view && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                        }
                        clearViewOffset() {
                            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                        }
                        updateProjectionMatrix() {
                            const t = (this.right - this.left) / (2 * this.zoom),
                                e = (this.top - this.bottom) / (2 * this.zoom),
                                i = (this.right + this.left) / 2,
                                n = (this.top + this.bottom) / 2;
                            let r = i - t,
                                s = i + t,
                                a = n + e,
                                o = n - e;
                            if (null !== this.view && this.view.enabled) {
                                const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                    e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                                r += t * this.view.offsetX, s = r + t * this.view.width, a -= e * this.view.offsetY, o = a - e * this.view.height
                            }
                            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                        }
                    }
                    const ps = [.125, .215, .35, .446, .526, .582],
                        ms = new ds,
                        fs = new kn;
                    let gs = null,
                        vs = 0,
                        _s = 0,
                        ys = !1;
                    const xs = (1 + Math.sqrt(5)) / 2,
                        Ms = 1 / xs,
                        bs = [new xi(-xs, Ms, 0), new xi(xs, Ms, 0), new xi(-Ms, 0, xs), new xi(Ms, 0, xs), new xi(0, xs, -Ms), new xi(0, xs, Ms), new xi(-1, 1, -1), new xi(1, 1, -1), new xi(-1, 1, 1), new xi(1, 1, 1)];
                    class Ss {
                        constructor(t) {
                            this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                        }
                        fromScene(t, e = 0, i = .1, n = 100) {
                            gs = this._renderer.getRenderTarget(), vs = this._renderer.getActiveCubeFace(), _s = this._renderer.getActiveMipmapLevel(), ys = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
                            const r = this._allocateTargets();
                            return r.depthBuffer = !0, this._sceneToCubeUV(t, i, n, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                        }
                        fromEquirectangular(t, e = null) {
                            return this._fromTexture(t, e)
                        }
                        fromCubemap(t, e = null) {
                            return this._fromTexture(t, e)
                        }
                        compileCubemapShader() {
                            null === this._cubemapMaterial && (this._cubemapMaterial = Es(), this._compileMaterial(this._cubemapMaterial))
                        }
                        compileEquirectangularShader() {
                            null === this._equirectMaterial && (this._equirectMaterial = Ts(), this._compileMaterial(this._equirectMaterial))
                        }
                        dispose() {
                            this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                        }
                        _setSize(t) {
                            this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
                        }
                        _dispose() {
                            null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                            for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
                        }
                        _cleanup(t) {
                            this._renderer.setRenderTarget(gs, vs, _s), this._renderer.xr.enabled = ys, t.scissorTest = !1, As(t, 0, 0, t.width, t.height)
                        }
                        _fromTexture(t, e) {
                            t.mapping === V || t.mapping === H ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), gs = this._renderer.getRenderTarget(), vs = this._renderer.getActiveCubeFace(), _s = this._renderer.getActiveMipmapLevel(), ys = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                            const i = e || this._allocateTargets();
                            return this._textureToCubeUV(t, i), this._applyPMREM(i), this._cleanup(i), i
                        }
                        _allocateTargets() {
                            const t = 3 * Math.max(this._cubeSize, 112),
                                e = 4 * this._cubeSize,
                                i = {
                                    magFilter: Q,
                                    minFilter: Q,
                                    generateMipmaps: !1,
                                    type: lt,
                                    format: ft,
                                    colorSpace: de,
                                    depthBuffer: !1
                                },
                                n = ws(t, e, i);
                            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                                null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = ws(t, e, i);
                                const {
                                    _lodMax: n
                                } = this;
                                ({
                                    sizeLods: this._sizeLods,
                                    lodPlanes: this._lodPlanes,
                                    sigmas: this._sigmas
                                } = function(t) {
                                    const e = [],
                                        i = [],
                                        n = [];
                                    let r = t;
                                    const s = t - 4 + 1 + ps.length;
                                    for (let a = 0; a < s; a++) {
                                        const s = Math.pow(2, r);
                                        i.push(s);
                                        let o = 1 / s;
                                        a > t - 4 ? o = ps[a - t + 4 - 1] : 0 === a && (o = 0), n.push(o);
                                        const l = 1 / (s - 2),
                                            h = -l,
                                            c = 1 + l,
                                            u = [h, h, c, h, c, c, h, h, c, c, h, c],
                                            d = 6,
                                            p = 6,
                                            m = 3,
                                            f = 2,
                                            g = 1,
                                            v = new Float32Array(m * p * d),
                                            _ = new Float32Array(f * p * d),
                                            y = new Float32Array(g * p * d);
                                        for (let t = 0; t < d; t++) {
                                            const e = t % 3 * 2 / 3 - 1,
                                                i = t > 2 ? 0 : -1,
                                                n = [e, i, 0, e + 2 / 3, i, 0, e + 2 / 3, i + 1, 0, e, i, 0, e + 2 / 3, i + 1, 0, e, i + 1, 0];
                                            v.set(n, m * p * t), _.set(u, f * p * t);
                                            const r = [t, t, t, t, t, t];
                                            y.set(r, g * p * t)
                                        }
                                        const x = new hr;
                                        x.setAttribute("position", new Qn(v, m)), x.setAttribute("uv", new Qn(_, f)), x.setAttribute("faceIndex", new Qn(y, g)), e.push(x), r > 4 && r--
                                    }
                                    return {
                                        lodPlanes: e,
                                        sizeLods: i,
                                        sigmas: n
                                    }
                                }(n)), this._blurMaterial = function(t, e, i) {
                                    const n = new Float32Array(20),
                                        r = new xi(0, 1, 0);
                                    return new Nr({
                                        name: "SphericalGaussianBlur",
                                        defines: {
                                            n: 20,
                                            CUBEUV_TEXEL_WIDTH: 1 / e,
                                            CUBEUV_TEXEL_HEIGHT: 1 / i,
                                            CUBEUV_MAX_MIP: `${t}.0`
                                        },
                                        uniforms: {
                                            envMap: {
                                                value: null
                                            },
                                            samples: {
                                                value: 1
                                            },
                                            weights: {
                                                value: n
                                            },
                                            latitudinal: {
                                                value: !1
                                            },
                                            dTheta: {
                                                value: 0
                                            },
                                            mipInt: {
                                                value: 0
                                            },
                                            poleAxis: {
                                                value: r
                                            }
                                        },
                                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                        blending: 0,
                                        depthTest: !1,
                                        depthWrite: !1
                                    })
                                }(n, t, e)
                            }
                            return n
                        }
                        _compileMaterial(t) {
                            const e = new Er(this._lodPlanes[0], t);
                            this._renderer.compile(e, ms)
                        }
                        _sceneToCubeUV(t, e, i, n) {
                            const r = new Fr(90, 1, e, i),
                                s = [1, -1, 1, 1, 1, 1],
                                a = [1, 1, 1, -1, -1, -1],
                                o = this._renderer,
                                l = o.autoClear,
                                h = o.toneMapping;
                            o.getClearColor(fs), o.toneMapping = P, o.autoClear = !1;
                            const c = new Wn({
                                    name: "PMREM.Background",
                                    side: 1,
                                    depthWrite: !1,
                                    depthTest: !1
                                }),
                                u = new Er(new Rr, c);
                            let d = !1;
                            const p = t.background;
                            p ? p.isColor && (c.color.copy(p), t.background = null, d = !0) : (c.color.copy(fs), d = !0);
                            for (let e = 0; e < 6; e++) {
                                const i = e % 3;
                                0 === i ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === i ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e]));
                                const l = this._cubeSize;
                                As(n, i * l, e > 2 ? l : 0, l, l), o.setRenderTarget(n), d && o.render(u, r), o.render(t, r)
                            }
                            u.geometry.dispose(), u.material.dispose(), o.toneMapping = h, o.autoClear = l, t.background = p
                        }
                        _textureToCubeUV(t, e) {
                            const i = this._renderer,
                                n = t.mapping === V || t.mapping === H;
                            n ? (null === this._cubemapMaterial && (this._cubemapMaterial = Es()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Ts());
                            const r = n ? this._cubemapMaterial : this._equirectMaterial,
                                s = new Er(this._lodPlanes[0], r);
                            r.uniforms.envMap.value = t;
                            const a = this._cubeSize;
                            As(e, 0, 0, 3 * a, 2 * a), i.setRenderTarget(e), i.render(s, ms)
                        }
                        _applyPMREM(t) {
                            const e = this._renderer,
                                i = e.autoClear;
                            e.autoClear = !1;
                            const n = this._lodPlanes.length;
                            for (let e = 1; e < n; e++) {
                                const i = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                                    r = bs[(n - e - 1) % bs.length];
                                this._blur(t, e - 1, e, i, r)
                            }
                            e.autoClear = i
                        }
                        _blur(t, e, i, n, r) {
                            const s = this._pingPongRenderTarget;
                            this._halfBlur(t, s, e, i, n, "latitudinal", r), this._halfBlur(s, t, i, i, n, "longitudinal", r)
                        }
                        _halfBlur(t, e, i, n, r, s, a) {
                            const o = this._renderer,
                                l = this._blurMaterial;
                            "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                            const h = new Er(this._lodPlanes[n], l),
                                c = l.uniforms,
                                u = this._sizeLods[i] - 1,
                                d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                                p = r / d,
                                m = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                            m > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
                            const f = [];
                            let g = 0;
                            for (let t = 0; t < 20; ++t) {
                                const e = t / p,
                                    i = Math.exp(-e * e / 2);
                                f.push(i), 0 === t ? g += i : t < m && (g += 2 * i)
                            }
                            for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
                            c.envMap.value = t.texture, c.samples.value = m, c.weights.value = f, c.latitudinal.value = "latitudinal" === s, a && (c.poleAxis.value = a);
                            const {
                                _lodMax: v
                            } = this;
                            c.dTheta.value = d, c.mipInt.value = v - i;
                            const _ = this._sizeLods[n];
                            As(e, 3 * _ * (n > v - 4 ? n - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _), o.setRenderTarget(e), o.render(h, ms)
                        }
                    }

                    function ws(t, e, i) {
                        const n = new gi(t, e, i);
                        return n.texture.mapping = j, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
                    }

                    function As(t, e, i, n, r) {
                        t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r)
                    }

                    function Ts() {
                        return new Nr({
                            name: "EquirectangularToCubeUV",
                            uniforms: {
                                envMap: {
                                    value: null
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }

                    function Es() {
                        return new Nr({
                            name: "CubemapToCubeUV",
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                flipEnvMap: {
                                    value: -1
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }

                    function Cs(t) {
                        let e = new WeakMap,
                            i = null;

                        function n(t) {
                            const i = t.target;
                            i.removeEventListener("dispose", n);
                            const r = e.get(i);
                            void 0 !== r && (e.delete(i), r.dispose())
                        }
                        return {
                            get: function(r) {
                                if (r && r.isTexture) {
                                    const s = r.mapping,
                                        a = s === G || s === W,
                                        o = s === V || s === H;
                                    if (a || o) {
                                        let s = e.get(r);
                                        const l = void 0 !== s ? s.texture.pmremVersion : 0;
                                        if (r.isRenderTargetTexture && r.pmremVersion !== l) return null === i && (i = new Ss(t)), s = a ? i.fromEquirectangular(r, s) : i.fromCubemap(r, s), s.texture.pmremVersion = r.pmremVersion, e.set(r, s), s.texture;
                                        if (void 0 !== s) return s.texture;
                                        {
                                            const l = r.image;
                                            return a && l && l.height > 0 || o && l && function(t) {
                                                let e = 0;
                                                for (let i = 0; i < 6; i++) void 0 !== t[i] && e++;
                                                return 6 === e
                                            }(l) ? (null === i && (i = new Ss(t)), s = a ? i.fromEquirectangular(r) : i.fromCubemap(r), s.texture.pmremVersion = r.pmremVersion, e.set(r, s), r.addEventListener("dispose", n), s.texture) : null
                                        }
                                    }
                                }
                                return r
                            },
                            dispose: function() {
                                e = new WeakMap, null !== i && (i.dispose(), i = null)
                            }
                        }
                    }

                    function Rs(t) {
                        const e = {};

                        function i(i) {
                            if (void 0 !== e[i]) return e[i];
                            let n;
                            switch (i) {
                                case "WEBGL_depth_texture":
                                    n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                    break;
                                case "EXT_texture_filter_anisotropic":
                                    n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                    break;
                                case "WEBGL_compressed_texture_s3tc":
                                    n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                    break;
                                case "WEBGL_compressed_texture_pvrtc":
                                    n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                    break;
                                default:
                                    n = t.getExtension(i)
                            }
                            return e[i] = n, n
                        }
                        return {
                            has: function(t) {
                                return null !== i(t)
                            },
                            init: function() {
                                i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent")
                            },
                            get: function(t) {
                                const e = i(t);
                                return null === e && $e("THREE.WebGLRenderer: " + t + " extension not supported."), e
                            }
                        }
                    }

                    function Ps(t, e, i, n) {
                        const r = {},
                            s = new WeakMap;

                        function a(t) {
                            const o = t.target;
                            null !== o.index && e.remove(o.index);
                            for (const t in o.attributes) e.remove(o.attributes[t]);
                            for (const t in o.morphAttributes) {
                                const i = o.morphAttributes[t];
                                for (let t = 0, n = i.length; t < n; t++) e.remove(i[t])
                            }
                            o.removeEventListener("dispose", a), delete r[o.id];
                            const l = s.get(o);
                            l && (e.remove(l), s.delete(o)), n.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, i.memory.geometries--
                        }

                        function o(t) {
                            const i = [],
                                n = t.index,
                                r = t.attributes.position;
                            let a = 0;
                            if (null !== n) {
                                const t = n.array;
                                a = n.version;
                                for (let e = 0, n = t.length; e < n; e += 3) {
                                    const n = t[e + 0],
                                        r = t[e + 1],
                                        s = t[e + 2];
                                    i.push(n, r, r, s, s, n)
                                }
                            } else {
                                if (void 0 === r) return;
                                {
                                    const t = r.array;
                                    a = r.version;
                                    for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
                                        const t = e + 0,
                                            n = e + 1,
                                            r = e + 2;
                                        i.push(t, n, n, r, r, t)
                                    }
                                }
                            }
                            const o = new(qe(i) ? tr : $n)(i, 1);
                            o.version = a;
                            const l = s.get(t);
                            l && e.remove(l), s.set(t, o)
                        }
                        return {
                            get: function(t, e) {
                                return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, i.memory.geometries++), e
                            },
                            update: function(i) {
                                const n = i.attributes;
                                for (const i in n) e.update(n[i], t.ARRAY_BUFFER);
                                const r = i.morphAttributes;
                                for (const i in r) {
                                    const n = r[i];
                                    for (let i = 0, r = n.length; i < r; i++) e.update(n[i], t.ARRAY_BUFFER)
                                }
                            },
                            getWireframeAttribute: function(t) {
                                const e = s.get(t);
                                if (e) {
                                    const i = t.index;
                                    null !== i && e.version < i.version && o(t)
                                } else o(t);
                                return s.get(t)
                            }
                        }
                    }

                    function Is(t, e, i) {
                        let n, r, s;

                        function a(e, a, o) {
                            0 !== o && (t.drawElementsInstanced(n, a, r, e * s, o), i.update(a, n, o))
                        }
                        this.setMode = function(t) {
                            n = t
                        }, this.setIndex = function(t) {
                            r = t.type, s = t.bytesPerElement
                        }, this.render = function(e, a) {
                            t.drawElements(n, a, r, e * s), i.update(a, n, 1)
                        }, this.renderInstances = a, this.renderMultiDraw = function(t, s, a) {
                            if (0 === a) return;
                            e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, s, 0, r, t, 0, a);
                            let o = 0;
                            for (let t = 0; t < a; t++) o += s[t];
                            i.update(o, n, 1)
                        }, this.renderMultiDrawInstances = function(t, o, l, h) {
                            if (0 === l) return;
                            const c = e.get("WEBGL_multi_draw");
                            if (null === c)
                                for (let e = 0; e < t.length; e++) a(t[e] / s, o[e], h[e]);
                            else {
                                c.multiDrawElementsInstancedWEBGL(n, o, 0, r, t, 0, h, 0, l);
                                let e = 0;
                                for (let t = 0; t < l; t++) e += o[t];
                                for (let t = 0; t < h.length; t++) i.update(e, n, h[t])
                            }
                        }
                    }

                    function Ls(t) {
                        const e = {
                            frame: 0,
                            calls: 0,
                            triangles: 0,
                            points: 0,
                            lines: 0
                        };
                        return {
                            memory: {
                                geometries: 0,
                                textures: 0
                            },
                            render: e,
                            programs: null,
                            autoReset: !0,
                            reset: function() {
                                e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                            },
                            update: function(i, n, r) {
                                switch (e.calls++, n) {
                                    case t.TRIANGLES:
                                        e.triangles += r * (i / 3);
                                        break;
                                    case t.LINES:
                                        e.lines += r * (i / 2);
                                        break;
                                    case t.LINE_STRIP:
                                        e.lines += r * (i - 1);
                                        break;
                                    case t.LINE_LOOP:
                                        e.lines += r * i;
                                        break;
                                    case t.POINTS:
                                        e.points += r * i;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                                }
                            }
                        }
                    }

                    function Us(t, e, i) {
                        const n = new WeakMap,
                            r = new mi;
                        return {
                            update: function(s, a, o) {
                                const l = s.morphTargetInfluences,
                                    h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
                                    c = void 0 !== h ? h.length : 0;
                                let u = n.get(a);
                                if (void 0 === u || u.count !== c) {
                                    void 0 !== u && u.texture.dispose();
                                    const d = void 0 !== a.morphAttributes.position,
                                        p = void 0 !== a.morphAttributes.normal,
                                        m = void 0 !== a.morphAttributes.color,
                                        f = a.morphAttributes.position || [],
                                        g = a.morphAttributes.normal || [],
                                        v = a.morphAttributes.color || [];
                                    let _ = 0;
                                    !0 === d && (_ = 1), !0 === p && (_ = 2), !0 === m && (_ = 3);
                                    let y = a.attributes.position.count * _,
                                        x = 1;
                                    y > e.maxTextureSize && (x = Math.ceil(y / e.maxTextureSize), y = e.maxTextureSize);
                                    const M = new Float32Array(y * x * 4 * c),
                                        b = new vi(M, y, x, c);
                                    b.type = ot, b.needsUpdate = !0;
                                    const S = 4 * _;
                                    for (let A = 0; A < c; A++) {
                                        const T = f[A],
                                            E = g[A],
                                            C = v[A],
                                            R = y * x * 4 * A;
                                        for (let P = 0; P < T.count; P++) {
                                            const I = P * S;
                                            !0 === d && (r.fromBufferAttribute(T, P), M[R + I + 0] = r.x, M[R + I + 1] = r.y, M[R + I + 2] = r.z, M[R + I + 3] = 0), !0 === p && (r.fromBufferAttribute(E, P), M[R + I + 4] = r.x, M[R + I + 5] = r.y, M[R + I + 6] = r.z, M[R + I + 7] = 0), !0 === m && (r.fromBufferAttribute(C, P), M[R + I + 8] = r.x, M[R + I + 9] = r.y, M[R + I + 10] = r.z, M[R + I + 11] = 4 === C.itemSize ? r.w : 1)
                                        }
                                    }

                                    function w() {
                                        b.dispose(), n.delete(a), a.removeEventListener("dispose", w)
                                    }
                                    u = {
                                        count: c,
                                        texture: b,
                                        size: new We(y, x)
                                    }, n.set(a, u), a.addEventListener("dispose", w)
                                }
                                if (!0 === s.isInstancedMesh && null !== s.morphTexture) o.getUniforms().setValue(t, "morphTexture", s.morphTexture, i);
                                else {
                                    let L = 0;
                                    for (let N = 0; N < l.length; N++) L += l[N];
                                    const U = a.morphTargetsRelative ? 1 : 1 - L;
                                    o.getUniforms().setValue(t, "morphTargetBaseInfluence", U), o.getUniforms().setValue(t, "morphTargetInfluences", l)
                                }
                                o.getUniforms().setValue(t, "morphTargetsTexture", u.texture, i), o.getUniforms().setValue(t, "morphTargetsTextureSize", u.size)
                            }
                        }
                    }

                    function Ns(t, e, i, n) {
                        let r = new WeakMap;

                        function s(t) {
                            const e = t.target;
                            e.removeEventListener("dispose", s), i.remove(e.instanceMatrix), null !== e.instanceColor && i.remove(e.instanceColor)
                        }
                        return {
                            update: function(a) {
                                const o = n.render.frame,
                                    l = a.geometry,
                                    h = e.get(a, l);
                                if (r.get(h) !== o && (e.update(h), r.set(h, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), r.get(a) !== o && (i.update(a.instanceMatrix, t.ARRAY_BUFFER), null !== a.instanceColor && i.update(a.instanceColor, t.ARRAY_BUFFER), r.set(a, o))), a.isSkinnedMesh) {
                                    const t = a.skeleton;
                                    r.get(t) !== o && (t.update(), r.set(t, o))
                                }
                                return h
                            },
                            dispose: function() {
                                r = new WeakMap
                            }
                        }
                    }
                    class Ds extends pi {
                        constructor(t, e, i, n, r, s, a, o, l, h = 1026) {
                            if (h !== _t && h !== yt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                            void 0 === i && h === _t && (i = at), void 0 === i && h === yt && (i = ut), super(null, n, r, s, a, o, h, i, l), this.isDepthTexture = !0, this.image = {
                                width: t,
                                height: e
                            }, this.magFilter = void 0 !== a ? a : J, this.minFilter = void 0 !== o ? o : J, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
                        }
                        copy(t) {
                            return super.copy(t), this.compareFunction = t.compareFunction, this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
                        }
                    }
                    const Os = new pi,
                        Bs = new Ds(1, 1),
                        zs = new vi,
                        Fs = new _i,
                        ks = new Hr,
                        Vs = [],
                        Hs = [],
                        Gs = new Float32Array(16),
                        Ws = new Float32Array(9),
                        js = new Float32Array(4);

                    function Xs(t, e, i) {
                        const n = t[0];
                        if (n <= 0 || n > 0) return t;
                        const r = e * i;
                        let s = Vs[r];
                        if (void 0 === s && (s = new Float32Array(r), Vs[r] = s), 0 !== e) {
                            n.toArray(s, 0);
                            for (let n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(s, r)
                        }
                        return s
                    }

                    function qs(t, e) {
                        if (t.length !== e.length) return !1;
                        for (let i = 0, n = t.length; i < n; i++)
                            if (t[i] !== e[i]) return !1;
                        return !0
                    }

                    function Ys(t, e) {
                        for (let i = 0, n = e.length; i < n; i++) t[i] = e[i]
                    }

                    function Js(t, e) {
                        let i = Hs[e];
                        void 0 === i && (i = new Int32Array(e), Hs[e] = i);
                        for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
                        return i
                    }

                    function Zs(t, e) {
                        const i = this.cache;
                        i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
                    }

                    function Ks(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                        else {
                            if (qs(i, e)) return;
                            t.uniform2fv(this.addr, e), Ys(i, e)
                        }
                    }

                    function Qs(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                        else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
                        else {
                            if (qs(i, e)) return;
                            t.uniform3fv(this.addr, e), Ys(i, e)
                        }
                    }

                    function $s(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                        else {
                            if (qs(i, e)) return;
                            t.uniform4fv(this.addr, e), Ys(i, e)
                        }
                    }

                    function ta(t, e) {
                        const i = this.cache,
                            n = e.elements;
                        if (void 0 === n) {
                            if (qs(i, e)) return;
                            t.uniformMatrix2fv(this.addr, !1, e), Ys(i, e)
                        } else {
                            if (qs(i, n)) return;
                            js.set(n), t.uniformMatrix2fv(this.addr, !1, js), Ys(i, n)
                        }
                    }

                    function ea(t, e) {
                        const i = this.cache,
                            n = e.elements;
                        if (void 0 === n) {
                            if (qs(i, e)) return;
                            t.uniformMatrix3fv(this.addr, !1, e), Ys(i, e)
                        } else {
                            if (qs(i, n)) return;
                            Ws.set(n), t.uniformMatrix3fv(this.addr, !1, Ws), Ys(i, n)
                        }
                    }

                    function ia(t, e) {
                        const i = this.cache,
                            n = e.elements;
                        if (void 0 === n) {
                            if (qs(i, e)) return;
                            t.uniformMatrix4fv(this.addr, !1, e), Ys(i, e)
                        } else {
                            if (qs(i, n)) return;
                            Gs.set(n), t.uniformMatrix4fv(this.addr, !1, Gs), Ys(i, n)
                        }
                    }

                    function na(t, e) {
                        const i = this.cache;
                        i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
                    }

                    function ra(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                        else {
                            if (qs(i, e)) return;
                            t.uniform2iv(this.addr, e), Ys(i, e)
                        }
                    }

                    function sa(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                        else {
                            if (qs(i, e)) return;
                            t.uniform3iv(this.addr, e), Ys(i, e)
                        }
                    }

                    function aa(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                        else {
                            if (qs(i, e)) return;
                            t.uniform4iv(this.addr, e), Ys(i, e)
                        }
                    }

                    function oa(t, e) {
                        const i = this.cache;
                        i[0] !== e && (t.uniform1ui(this.addr, e), i[0] = e)
                    }

                    function la(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                        else {
                            if (qs(i, e)) return;
                            t.uniform2uiv(this.addr, e), Ys(i, e)
                        }
                    }

                    function ha(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                        else {
                            if (qs(i, e)) return;
                            t.uniform3uiv(this.addr, e), Ys(i, e)
                        }
                    }

                    function ca(t, e) {
                        const i = this.cache;
                        if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                        else {
                            if (qs(i, e)) return;
                            t.uniform4uiv(this.addr, e), Ys(i, e)
                        }
                    }

                    function ua(t, e, i) {
                        const n = this.cache,
                            r = i.allocateTextureUnit();
                        let s;
                        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), this.type === t.SAMPLER_2D_SHADOW ? (Bs.compareFunction = 515, s = Bs) : s = Os, i.setTexture2D(e || s, r)
                    }

                    function da(t, e, i) {
                        const n = this.cache,
                            r = i.allocateTextureUnit();
                        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Fs, r)
                    }

                    function pa(t, e, i) {
                        const n = this.cache,
                            r = i.allocateTextureUnit();
                        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || ks, r)
                    }

                    function ma(t, e, i) {
                        const n = this.cache,
                            r = i.allocateTextureUnit();
                        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || zs, r)
                    }

                    function fa(t, e) {
                        t.uniform1fv(this.addr, e)
                    }

                    function ga(t, e) {
                        const i = Xs(e, this.size, 2);
                        t.uniform2fv(this.addr, i)
                    }

                    function va(t, e) {
                        const i = Xs(e, this.size, 3);
                        t.uniform3fv(this.addr, i)
                    }

                    function _a(t, e) {
                        const i = Xs(e, this.size, 4);
                        t.uniform4fv(this.addr, i)
                    }

                    function ya(t, e) {
                        const i = Xs(e, this.size, 4);
                        t.uniformMatrix2fv(this.addr, !1, i)
                    }

                    function xa(t, e) {
                        const i = Xs(e, this.size, 9);
                        t.uniformMatrix3fv(this.addr, !1, i)
                    }

                    function Ma(t, e) {
                        const i = Xs(e, this.size, 16);
                        t.uniformMatrix4fv(this.addr, !1, i)
                    }

                    function ba(t, e) {
                        t.uniform1iv(this.addr, e)
                    }

                    function Sa(t, e) {
                        t.uniform2iv(this.addr, e)
                    }

                    function wa(t, e) {
                        t.uniform3iv(this.addr, e)
                    }

                    function Aa(t, e) {
                        t.uniform4iv(this.addr, e)
                    }

                    function Ta(t, e) {
                        t.uniform1uiv(this.addr, e)
                    }

                    function Ea(t, e) {
                        t.uniform2uiv(this.addr, e)
                    }

                    function Ca(t, e) {
                        t.uniform3uiv(this.addr, e)
                    }

                    function Ra(t, e) {
                        t.uniform4uiv(this.addr, e)
                    }

                    function Pa(t, e, i) {
                        const n = this.cache,
                            r = e.length,
                            s = Js(i, r);
                        qs(n, s) || (t.uniform1iv(this.addr, s), Ys(n, s));
                        for (let t = 0; t !== r; ++t) i.setTexture2D(e[t] || Os, s[t])
                    }

                    function Ia(t, e, i) {
                        const n = this.cache,
                            r = e.length,
                            s = Js(i, r);
                        qs(n, s) || (t.uniform1iv(this.addr, s), Ys(n, s));
                        for (let t = 0; t !== r; ++t) i.setTexture3D(e[t] || Fs, s[t])
                    }

                    function La(t, e, i) {
                        const n = this.cache,
                            r = e.length,
                            s = Js(i, r);
                        qs(n, s) || (t.uniform1iv(this.addr, s), Ys(n, s));
                        for (let t = 0; t !== r; ++t) i.setTextureCube(e[t] || ks, s[t])
                    }

                    function Ua(t, e, i) {
                        const n = this.cache,
                            r = e.length,
                            s = Js(i, r);
                        qs(n, s) || (t.uniform1iv(this.addr, s), Ys(n, s));
                        for (let t = 0; t !== r; ++t) i.setTexture2DArray(e[t] || zs, s[t])
                    }
                    class Na {
                        constructor(t, e, i) {
                            this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.setValue = function(t) {
                                switch (t) {
                                    case 5126:
                                        return Zs;
                                    case 35664:
                                        return Ks;
                                    case 35665:
                                        return Qs;
                                    case 35666:
                                        return $s;
                                    case 35674:
                                        return ta;
                                    case 35675:
                                        return ea;
                                    case 35676:
                                        return ia;
                                    case 5124:
                                    case 35670:
                                        return na;
                                    case 35667:
                                    case 35671:
                                        return ra;
                                    case 35668:
                                    case 35672:
                                        return sa;
                                    case 35669:
                                    case 35673:
                                        return aa;
                                    case 5125:
                                        return oa;
                                    case 36294:
                                        return la;
                                    case 36295:
                                        return ha;
                                    case 36296:
                                        return ca;
                                    case 35678:
                                    case 36198:
                                    case 36298:
                                    case 36306:
                                    case 35682:
                                        return ua;
                                    case 35679:
                                    case 36299:
                                    case 36307:
                                        return da;
                                    case 35680:
                                    case 36300:
                                    case 36308:
                                    case 36293:
                                        return pa;
                                    case 36289:
                                    case 36303:
                                    case 36311:
                                    case 36292:
                                        return ma
                                }
                            }(e.type)
                        }
                    }
                    class Da {
                        constructor(t, e, i) {
                            this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = function(t) {
                                switch (t) {
                                    case 5126:
                                        return fa;
                                    case 35664:
                                        return ga;
                                    case 35665:
                                        return va;
                                    case 35666:
                                        return _a;
                                    case 35674:
                                        return ya;
                                    case 35675:
                                        return xa;
                                    case 35676:
                                        return Ma;
                                    case 5124:
                                    case 35670:
                                        return ba;
                                    case 35667:
                                    case 35671:
                                        return Sa;
                                    case 35668:
                                    case 35672:
                                        return wa;
                                    case 35669:
                                    case 35673:
                                        return Aa;
                                    case 5125:
                                        return Ta;
                                    case 36294:
                                        return Ea;
                                    case 36295:
                                        return Ca;
                                    case 36296:
                                        return Ra;
                                    case 35678:
                                    case 36198:
                                    case 36298:
                                    case 36306:
                                    case 35682:
                                        return Pa;
                                    case 35679:
                                    case 36299:
                                    case 36307:
                                        return Ia;
                                    case 35680:
                                    case 36300:
                                    case 36308:
                                    case 36293:
                                        return La;
                                    case 36289:
                                    case 36303:
                                    case 36311:
                                    case 36292:
                                        return Ua
                                }
                            }(e.type)
                        }
                    }
                    class Oa {
                        constructor(t) {
                            this.id = t, this.seq = [], this.map = {}
                        }
                        setValue(t, e, i) {
                            const n = this.seq;
                            for (let r = 0, s = n.length; r !== s; ++r) {
                                const s = n[r];
                                s.setValue(t, e[s.id], i)
                            }
                        }
                    }
                    const Ba = /(\w+)(\])?(\[|\.)?/g;

                    function za(t, e) {
                        t.seq.push(e), t.map[e.id] = e
                    }

                    function Fa(t, e, i) {
                        const n = t.name,
                            r = n.length;
                        for (Ba.lastIndex = 0;;) {
                            const s = Ba.exec(n),
                                a = Ba.lastIndex;
                            let o = s[1];
                            const l = "]" === s[2],
                                h = s[3];
                            if (l && (o |= 0), void 0 === h || "[" === h && a + 2 === r) {
                                za(i, void 0 === h ? new Na(o, t, e) : new Da(o, t, e));
                                break
                            } {
                                let t = i.map[o];
                                void 0 === t && (t = new Oa(o), za(i, t)), i = t
                            }
                        }
                    }
                    class ka {
                        constructor(t, e) {
                            this.seq = [], this.map = {};
                            const i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                            for (let n = 0; n < i; ++n) {
                                const i = t.getActiveUniform(e, n);
                                Fa(i, t.getUniformLocation(e, i.name), this)
                            }
                        }
                        setValue(t, e, i, n) {
                            const r = this.map[e];
                            void 0 !== r && r.setValue(t, i, n)
                        }
                        setOptional(t, e, i) {
                            const n = e[i];
                            void 0 !== n && this.setValue(t, i, n)
                        }
                        static upload(t, e, i, n) {
                            for (let r = 0, s = e.length; r !== s; ++r) {
                                const s = e[r],
                                    a = i[s.id];
                                !1 !== a.needsUpdate && s.setValue(t, a.value, n)
                            }
                        }
                        static seqWithValue(t, e) {
                            const i = [];
                            for (let n = 0, r = t.length; n !== r; ++n) {
                                const r = t[n];
                                r.id in e && i.push(r)
                            }
                            return i
                        }
                    }

                    function Va(t, e, i) {
                        const n = t.createShader(e);
                        return t.shaderSource(n, i), t.compileShader(n), n
                    }
                    const Ha = 37297;
                    let Ga = 0;

                    function Wa(t, e, i) {
                        const n = t.getShaderParameter(e, t.COMPILE_STATUS),
                            r = t.getShaderInfoLog(e).trim();
                        if (n && "" === r) return "";
                        const s = /ERROR: 0:(\d+)/.exec(r);
                        if (s) {
                            const n = parseInt(s[1]);
                            return i.toUpperCase() + "\n\n" + r + "\n\n" + function(t, e) {
                                const i = t.split("\n"),
                                    n = [],
                                    r = Math.max(e - 6, 0),
                                    s = Math.min(e + 6, i.length);
                                for (let t = r; t < s; t++) {
                                    const r = t + 1;
                                    n.push(`${r===e?">":" "} ${r}: ${i[t]}`)
                                }
                                return n.join("\n")
                            }(t.getShaderSource(e), n)
                        }
                        return r
                    }

                    function ja(t, e) {
                        const i = function(t) {
                            const e = ri.getPrimaries(ri.workingColorSpace),
                                i = ri.getPrimaries(t);
                            let n;
                            switch (e === i ? n = "" : e === _e && i === ve ? n = "LinearDisplayP3ToLinearSRGB" : e === ve && i === _e && (n = "LinearSRGBToLinearDisplayP3"), t) {
                                case de:
                                case me:
                                    return [n, "LinearTransferOETF"];
                                case ue:
                                case pe:
                                    return [n, "sRGBTransferOETF"];
                                default:
                                    return console.warn("THREE.WebGLProgram: Unsupported color space:", t), [n, "LinearTransferOETF"]
                            }
                        }(e);
                        return `vec4 ${t}( vec4 value ) { return ${i[0]}( ${i[1]}( value ) ); }`
                    }

                    function Xa(t, e) {
                        let i;
                        switch (e) {
                            case I:
                                i = "Linear";
                                break;
                            case L:
                                i = "Reinhard";
                                break;
                            case U:
                                i = "Cineon";
                                break;
                            case N:
                                i = "ACESFilmic";
                                break;
                            case O:
                                i = "AgX";
                                break;
                            case B:
                                i = "Neutral";
                                break;
                            case D:
                                i = "Custom";
                                break;
                            default:
                                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), i = "Linear"
                        }
                        return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                    }
                    const qa = new xi;

                    function Ya(t) {
                        return "" !== t
                    }

                    function Ja(t, e) {
                        const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
                        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                    }

                    function Za(t, e) {
                        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                    }
                    const Ka = /^[ \t]*#include +<([\w\d./]+)>/gm;

                    function Qa(t) {
                        return t.replace(Ka, to)
                    }
                    const $a = new Map;

                    function to(t, e) {
                        let i = ts[e];
                        if (void 0 === i) {
                            const t = $a.get(e);
                            if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
                            i = ts[t], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
                        }
                        return Qa(i)
                    }
                    const eo = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                    function io(t) {
                        return t.replace(eo, no)
                    }

                    function no(t, e, i, n) {
                        let r = "";
                        for (let t = parseInt(e); t < parseInt(i); t++) r += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                        return r
                    }

                    function ro(t) {
                        let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;
                        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                    }

                    function so(t, e, i, a) {
                        const o = t.getContext(),
                            l = i.defines;
                        let h = i.vertexShader,
                            c = i.fragmentShader;
                        const u = function(t) {
                                let e = "SHADOWMAP_TYPE_BASIC";
                                return t.shadowMapType === n ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === r ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === s && (e = "SHADOWMAP_TYPE_VSM"), e
                            }(i),
                            d = function(t) {
                                let e = "ENVMAP_TYPE_CUBE";
                                if (t.envMap) switch (t.envMapMode) {
                                    case V:
                                    case H:
                                        e = "ENVMAP_TYPE_CUBE";
                                        break;
                                    case j:
                                        e = "ENVMAP_TYPE_CUBE_UV"
                                }
                                return e
                            }(i),
                            p = function(t) {
                                let e = "ENVMAP_MODE_REFLECTION";
                                return t.envMap && t.envMapMode === H && (e = "ENVMAP_MODE_REFRACTION"), e
                            }(i),
                            m = function(t) {
                                let e = "ENVMAP_BLENDING_NONE";
                                if (t.envMap) switch (t.combine) {
                                    case E:
                                        e = "ENVMAP_BLENDING_MULTIPLY";
                                        break;
                                    case C:
                                        e = "ENVMAP_BLENDING_MIX";
                                        break;
                                    case R:
                                        e = "ENVMAP_BLENDING_ADD"
                                }
                                return e
                            }(i),
                            f = function(t) {
                                const e = t.envMapCubeUVHeight;
                                if (null === e) return null;
                                const i = Math.log2(e) - 2,
                                    n = 1 / e;
                                return {
                                    texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
                                    texelHeight: n,
                                    maxMip: i
                                }
                            }(i),
                            g = function(t) {
                                return [t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Ya).join("\n")
                            }(i),
                            v = function(t) {
                                const e = [];
                                for (const i in t) {
                                    const n = t[i];
                                    !1 !== n && e.push("#define " + i + " " + n)
                                }
                                return e.join("\n")
                            }(l),
                            _ = o.createProgram();
                        let y, x, M = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
                        i.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, v].filter(Ya).join("\n"), y.length > 0 && (y += "\n"), x = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, v].filter(Ya).join("\n"), x.length > 0 && (x += "\n")) : (y = [ro(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, v, i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", i.batching ? "#define USE_BATCHING" : "", i.batchingColor ? "#define USE_BATCHING_COLOR" : "", i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + p : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.mapUv ? "#define MAP_UV " + i.mapUv : "", i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "", i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "", i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "", i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "", i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "", i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "", i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "", i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "", i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "", i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "", i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "", i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "", i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "", i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "", i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "", i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "", i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "", i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "", i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "", i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "", i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "", i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + u : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ya).join("\n"), x = [ro(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, v, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + d : "", i.envMap ? "#define " + p : "", i.envMap ? "#define " + m : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.dispersion ? "#define USE_DISPERSION" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + u : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== P ? "#define TONE_MAPPING" : "", i.toneMapping !== P ? ts.tonemapping_pars_fragment : "", i.toneMapping !== P ? Xa("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", ts.colorspace_pars_fragment, ja("linearToOutputTexel", i.outputColorSpace), (ri.getLuminanceCoefficients(qa), ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${qa.x.toFixed(4)}, ${qa.y.toFixed(4)}, ${qa.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Ya).join("\n")), h = Qa(h), h = Ja(h, i), h = Za(h, i), c = Qa(c), c = Ja(c, i), c = Za(c, i), h = io(h), c = io(c), !0 !== i.isRawShaderMaterial && (M = "#version 300 es\n", y = [g, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, x = ["#define varying in", i.glslVersion === Re ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === Re ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
                        const b = M + y + h,
                            S = M + x + c,
                            w = Va(o, o.VERTEX_SHADER, b),
                            A = Va(o, o.FRAGMENT_SHADER, S);

                        function T(e) {
                            if (t.debug.checkShaderErrors) {
                                const i = o.getProgramInfoLog(_).trim(),
                                    n = o.getShaderInfoLog(w).trim(),
                                    r = o.getShaderInfoLog(A).trim();
                                let s = !0,
                                    a = !0;
                                if (!1 === o.getProgramParameter(_, o.LINK_STATUS))
                                    if (s = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(o, _, w, A);
                                    else {
                                        const t = Wa(o, w, "vertex"),
                                            n = Wa(o, A, "fragment");
                                        console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(_, o.VALIDATE_STATUS) + "\n\nMaterial Name: " + e.name + "\nMaterial Type: " + e.type + "\n\nProgram Info Log: " + i + "\n" + t + "\n" + n)
                                    }
                                else "" !== i ? console.warn("THREE.WebGLProgram: Program Info Log:", i) : "" !== n && "" !== r || (a = !1);
                                a && (e.diagnostics = {
                                    runnable: s,
                                    programLog: i,
                                    vertexShader: {
                                        log: n,
                                        prefix: y
                                    },
                                    fragmentShader: {
                                        log: r,
                                        prefix: x
                                    }
                                })
                            }
                            o.deleteShader(w), o.deleteShader(A), I = new ka(o, _), L = function(t, e) {
                                const i = {},
                                    n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                                for (let r = 0; r < n; r++) {
                                    const n = t.getActiveAttrib(e, r),
                                        s = n.name;
                                    let a = 1;
                                    n.type === t.FLOAT_MAT2 && (a = 2), n.type === t.FLOAT_MAT3 && (a = 3), n.type === t.FLOAT_MAT4 && (a = 4), i[s] = {
                                        type: n.type,
                                        location: t.getAttribLocation(e, s),
                                        locationSize: a
                                    }
                                }
                                return i
                            }(o, _)
                        }
                        let I, L;
                        o.attachShader(_, w), o.attachShader(_, A), void 0 !== i.index0AttributeName ? o.bindAttribLocation(_, 0, i.index0AttributeName) : !0 === i.morphTargets && o.bindAttribLocation(_, 0, "position"), o.linkProgram(_), this.getUniforms = function() {
                            return void 0 === I && T(this), I
                        }, this.getAttributes = function() {
                            return void 0 === L && T(this), L
                        };
                        let U = !1 === i.rendererExtensionParallelShaderCompile;
                        return this.isReady = function() {
                            return !1 === U && (U = o.getProgramParameter(_, Ha)), U
                        }, this.destroy = function() {
                            a.releaseStatesOfProgram(this), o.deleteProgram(_), this.program = void 0
                        }, this.type = i.shaderType, this.name = i.shaderName, this.id = Ga++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = w, this.fragmentShader = A, this
                    }
                    let ao = 0;
                    class oo {
                        constructor() {
                            this.shaderCache = new Map, this.materialCache = new Map
                        }
                        update(t) {
                            const e = t.vertexShader,
                                i = t.fragmentShader,
                                n = this._getShaderStage(e),
                                r = this._getShaderStage(i),
                                s = this._getShaderCacheForMaterial(t);
                            return !1 === s.has(n) && (s.add(n), n.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
                        }
                        remove(t) {
                            const e = this.materialCache.get(t);
                            for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
                            return this.materialCache.delete(t), this
                        }
                        getVertexShaderID(t) {
                            return this._getShaderStage(t.vertexShader).id
                        }
                        getFragmentShaderID(t) {
                            return this._getShaderStage(t.fragmentShader).id
                        }
                        dispose() {
                            this.shaderCache.clear(), this.materialCache.clear()
                        }
                        _getShaderCacheForMaterial(t) {
                            const e = this.materialCache;
                            let i = e.get(t);
                            return void 0 === i && (i = new Set, e.set(t, i)), i
                        }
                        _getShaderStage(t) {
                            const e = this.shaderCache;
                            let i = e.get(t);
                            return void 0 === i && (i = new lo(t), e.set(t, i)), i
                        }
                    }
                    class lo {
                        constructor(t) {
                            this.id = ao++, this.code = t, this.usedTimes = 0
                        }
                    }

                    function ho(t, e, i, n, r, s, a) {
                        const o = new ln,
                            l = new oo,
                            h = new Set,
                            c = [],
                            u = r.logarithmicDepthBuffer,
                            d = r.vertexTextures;
                        let p = r.precision;
                        const m = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite"
                        };

                        function f(t) {
                            return h.add(t), 0 === t ? "uv" : `uv${t}`
                        }
                        return {
                            getParameters: function(s, o, c, g, v) {
                                const _ = g.fog,
                                    y = v.geometry,
                                    x = s.isMeshStandardMaterial ? g.environment : null,
                                    M = (s.isMeshStandardMaterial ? i : e).get(s.envMap || x),
                                    b = M && M.mapping === j ? M.image.height : null,
                                    S = m[s.type];
                                null !== s.precision && (p = r.getMaxPrecision(s.precision), p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead."));
                                const w = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                                    A = void 0 !== w ? w.length : 0;
                                let T, E, C, R, I = 0;
                                if (void 0 !== y.morphAttributes.position && (I = 1), void 0 !== y.morphAttributes.normal && (I = 2), void 0 !== y.morphAttributes.color && (I = 3), S) {
                                    const t = is[S];
                                    T = t.vertexShader, E = t.fragmentShader
                                } else T = s.vertexShader, E = s.fragmentShader, l.update(s), C = l.getVertexShaderID(s), R = l.getFragmentShaderID(s);
                                const L = t.getRenderTarget(),
                                    U = !0 === v.isInstancedMesh,
                                    N = !0 === v.isBatchedMesh,
                                    D = !!s.map,
                                    O = !!s.matcap,
                                    B = !!M,
                                    z = !!s.aoMap,
                                    F = !!s.lightMap,
                                    k = !!s.bumpMap,
                                    V = !!s.normalMap,
                                    H = !!s.displacementMap,
                                    G = !!s.emissiveMap,
                                    W = !!s.metalnessMap,
                                    X = !!s.roughnessMap,
                                    q = s.anisotropy > 0,
                                    Y = s.clearcoat > 0,
                                    J = s.dispersion > 0,
                                    Z = s.iridescence > 0,
                                    K = s.sheen > 0,
                                    Q = s.transmission > 0,
                                    $ = q && !!s.anisotropyMap,
                                    tt = Y && !!s.clearcoatMap,
                                    et = Y && !!s.clearcoatNormalMap,
                                    it = Y && !!s.clearcoatRoughnessMap,
                                    nt = Z && !!s.iridescenceMap,
                                    rt = Z && !!s.iridescenceThicknessMap,
                                    st = K && !!s.sheenColorMap,
                                    at = K && !!s.sheenRoughnessMap,
                                    ot = !!s.specularMap,
                                    lt = !!s.specularColorMap,
                                    ht = !!s.specularIntensityMap,
                                    ct = Q && !!s.transmissionMap,
                                    ut = Q && !!s.thicknessMap,
                                    dt = !!s.gradientMap,
                                    pt = !!s.alphaMap,
                                    mt = s.alphaTest > 0,
                                    ft = !!s.alphaHash,
                                    gt = !!s.extensions;
                                let vt = P;
                                s.toneMapped && (null !== L && !0 !== L.isXRRenderTarget || (vt = t.toneMapping));
                                const _t = {
                                    shaderID: S,
                                    shaderType: s.type,
                                    shaderName: s.name,
                                    vertexShader: T,
                                    fragmentShader: E,
                                    defines: s.defines,
                                    customVertexShaderID: C,
                                    customFragmentShaderID: R,
                                    isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                                    glslVersion: s.glslVersion,
                                    precision: p,
                                    batching: N,
                                    batchingColor: N && null !== v._colorsTexture,
                                    instancing: U,
                                    instancingColor: U && null !== v.instanceColor,
                                    instancingMorph: U && null !== v.morphTexture,
                                    supportsVertexTextures: d,
                                    outputColorSpace: null === L ? t.outputColorSpace : !0 === L.isXRRenderTarget ? L.texture.colorSpace : de,
                                    alphaToCoverage: !!s.alphaToCoverage,
                                    map: D,
                                    matcap: O,
                                    envMap: B,
                                    envMapMode: B && M.mapping,
                                    envMapCubeUVHeight: b,
                                    aoMap: z,
                                    lightMap: F,
                                    bumpMap: k,
                                    normalMap: V,
                                    displacementMap: d && H,
                                    emissiveMap: G,
                                    normalMapObjectSpace: V && 1 === s.normalMapType,
                                    normalMapTangentSpace: V && 0 === s.normalMapType,
                                    metalnessMap: W,
                                    roughnessMap: X,
                                    anisotropy: q,
                                    anisotropyMap: $,
                                    clearcoat: Y,
                                    clearcoatMap: tt,
                                    clearcoatNormalMap: et,
                                    clearcoatRoughnessMap: it,
                                    dispersion: J,
                                    iridescence: Z,
                                    iridescenceMap: nt,
                                    iridescenceThicknessMap: rt,
                                    sheen: K,
                                    sheenColorMap: st,
                                    sheenRoughnessMap: at,
                                    specularMap: ot,
                                    specularColorMap: lt,
                                    specularIntensityMap: ht,
                                    transmission: Q,
                                    transmissionMap: ct,
                                    thicknessMap: ut,
                                    gradientMap: dt,
                                    opaque: !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage,
                                    alphaMap: pt,
                                    alphaTest: mt,
                                    alphaHash: ft,
                                    combine: s.combine,
                                    mapUv: D && f(s.map.channel),
                                    aoMapUv: z && f(s.aoMap.channel),
                                    lightMapUv: F && f(s.lightMap.channel),
                                    bumpMapUv: k && f(s.bumpMap.channel),
                                    normalMapUv: V && f(s.normalMap.channel),
                                    displacementMapUv: H && f(s.displacementMap.channel),
                                    emissiveMapUv: G && f(s.emissiveMap.channel),
                                    metalnessMapUv: W && f(s.metalnessMap.channel),
                                    roughnessMapUv: X && f(s.roughnessMap.channel),
                                    anisotropyMapUv: $ && f(s.anisotropyMap.channel),
                                    clearcoatMapUv: tt && f(s.clearcoatMap.channel),
                                    clearcoatNormalMapUv: et && f(s.clearcoatNormalMap.channel),
                                    clearcoatRoughnessMapUv: it && f(s.clearcoatRoughnessMap.channel),
                                    iridescenceMapUv: nt && f(s.iridescenceMap.channel),
                                    iridescenceThicknessMapUv: rt && f(s.iridescenceThicknessMap.channel),
                                    sheenColorMapUv: st && f(s.sheenColorMap.channel),
                                    sheenRoughnessMapUv: at && f(s.sheenRoughnessMap.channel),
                                    specularMapUv: ot && f(s.specularMap.channel),
                                    specularColorMapUv: lt && f(s.specularColorMap.channel),
                                    specularIntensityMapUv: ht && f(s.specularIntensityMap.channel),
                                    transmissionMapUv: ct && f(s.transmissionMap.channel),
                                    thicknessMapUv: ut && f(s.thicknessMap.channel),
                                    alphaMapUv: pt && f(s.alphaMap.channel),
                                    vertexTangents: !!y.attributes.tangent && (V || q),
                                    vertexColors: s.vertexColors,
                                    vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                                    pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (D || pt),
                                    fog: !!_,
                                    useFog: !0 === s.fog,
                                    fogExp2: !!_ && _.isFogExp2,
                                    flatShading: !0 === s.flatShading,
                                    sizeAttenuation: !0 === s.sizeAttenuation,
                                    logarithmicDepthBuffer: u,
                                    skinning: !0 === v.isSkinnedMesh,
                                    morphTargets: void 0 !== y.morphAttributes.position,
                                    morphNormals: void 0 !== y.morphAttributes.normal,
                                    morphColors: void 0 !== y.morphAttributes.color,
                                    morphTargetsCount: A,
                                    morphTextureStride: I,
                                    numDirLights: o.directional.length,
                                    numPointLights: o.point.length,
                                    numSpotLights: o.spot.length,
                                    numSpotLightMaps: o.spotLightMap.length,
                                    numRectAreaLights: o.rectArea.length,
                                    numHemiLights: o.hemi.length,
                                    numDirLightShadows: o.directionalShadowMap.length,
                                    numPointLightShadows: o.pointShadowMap.length,
                                    numSpotLightShadows: o.spotShadowMap.length,
                                    numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                                    numLightProbes: o.numLightProbes,
                                    numClippingPlanes: a.numPlanes,
                                    numClipIntersection: a.numIntersection,
                                    dithering: s.dithering,
                                    shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                                    shadowMapType: t.shadowMap.type,
                                    toneMapping: vt,
                                    decodeVideoTexture: D && !0 === s.map.isVideoTexture && ri.getTransfer(s.map.colorSpace) === ge,
                                    premultipliedAlpha: s.premultipliedAlpha,
                                    doubleSided: 2 === s.side,
                                    flipSided: 1 === s.side,
                                    useDepthPacking: s.depthPacking >= 0,
                                    depthPacking: s.depthPacking || 0,
                                    index0AttributeName: s.index0AttributeName,
                                    extensionClipCullDistance: gt && !0 === s.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"),
                                    extensionMultiDraw: (gt && !0 === s.extensions.multiDraw || N) && n.has("WEBGL_multi_draw"),
                                    rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                                    customProgramCacheKey: s.customProgramCacheKey()
                                };
                                return _t.vertexUv1s = h.has(1), _t.vertexUv2s = h.has(2), _t.vertexUv3s = h.has(3), h.clear(), _t
                            },
                            getProgramCacheKey: function(e) {
                                const i = [];
                                if (e.shaderID ? i.push(e.shaderID) : (i.push(e.customVertexShaderID), i.push(e.customFragmentShaderID)), void 0 !== e.defines)
                                    for (const t in e.defines) i.push(t), i.push(e.defines[t]);
                                return !1 === e.isRawShaderMaterial && (function(t, e) {
                                    t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.numLightProbes), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                                }(i, e), function(t, e) {
                                    o.disableAll(), e.supportsVertexTextures && o.enable(0), e.instancing && o.enable(1), e.instancingColor && o.enable(2), e.instancingMorph && o.enable(3), e.matcap && o.enable(4), e.envMap && o.enable(5), e.normalMapObjectSpace && o.enable(6), e.normalMapTangentSpace && o.enable(7), e.clearcoat && o.enable(8), e.iridescence && o.enable(9), e.alphaTest && o.enable(10), e.vertexColors && o.enable(11), e.vertexAlphas && o.enable(12), e.vertexUv1s && o.enable(13), e.vertexUv2s && o.enable(14), e.vertexUv3s && o.enable(15), e.vertexTangents && o.enable(16), e.anisotropy && o.enable(17), e.alphaHash && o.enable(18), e.batching && o.enable(19), e.dispersion && o.enable(20), e.batchingColor && o.enable(21), t.push(o.mask), o.disableAll(), e.fog && o.enable(0), e.useFog && o.enable(1), e.flatShading && o.enable(2), e.logarithmicDepthBuffer && o.enable(3), e.skinning && o.enable(4), e.morphTargets && o.enable(5), e.morphNormals && o.enable(6), e.morphColors && o.enable(7), e.premultipliedAlpha && o.enable(8), e.shadowMapEnabled && o.enable(9), e.doubleSided && o.enable(10), e.flipSided && o.enable(11), e.useDepthPacking && o.enable(12), e.dithering && o.enable(13), e.transmission && o.enable(14), e.sheen && o.enable(15), e.opaque && o.enable(16), e.pointsUvs && o.enable(17), e.decodeVideoTexture && o.enable(18), e.alphaToCoverage && o.enable(19), t.push(o.mask)
                                }(i, e), i.push(t.outputColorSpace)), i.push(e.customProgramCacheKey), i.join()
                            },
                            getUniforms: function(t) {
                                const e = m[t.type];
                                let i;
                                if (e) {
                                    const t = is[e];
                                    i = Ur.clone(t.uniforms)
                                } else i = t.uniforms;
                                return i
                            },
                            acquireProgram: function(e, i) {
                                let n;
                                for (let t = 0, e = c.length; t < e; t++) {
                                    const e = c[t];
                                    if (e.cacheKey === i) {
                                        n = e, ++n.usedTimes;
                                        break
                                    }
                                }
                                return void 0 === n && (n = new so(t, i, e, s), c.push(n)), n
                            },
                            releaseProgram: function(t) {
                                if (0 == --t.usedTimes) {
                                    const e = c.indexOf(t);
                                    c[e] = c[c.length - 1], c.pop(), t.destroy()
                                }
                            },
                            releaseShaderCache: function(t) {
                                l.remove(t)
                            },
                            programs: c,
                            dispose: function() {
                                l.dispose()
                            }
                        }
                    }

                    function co() {
                        let t = new WeakMap;
                        return {
                            has: function(e) {
                                return t.has(e)
                            },
                            get: function(e) {
                                let i = t.get(e);
                                return void 0 === i && (i = {}, t.set(e, i)), i
                            },
                            remove: function(e) {
                                t.delete(e)
                            },
                            update: function(e, i, n) {
                                t.get(e)[i] = n
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }

                    function uo(t, e) {
                        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                    }

                    function po(t, e) {
                        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                    }

                    function mo() {
                        const t = [];
                        let e = 0;
                        const i = [],
                            n = [],
                            r = [];

                        function s(i, n, r, s, a, o) {
                            let l = t[e];
                            return void 0 === l ? (l = {
                                id: i.id,
                                object: i,
                                geometry: n,
                                material: r,
                                groupOrder: s,
                                renderOrder: i.renderOrder,
                                z: a,
                                group: o
                            }, t[e] = l) : (l.id = i.id, l.object = i, l.geometry = n, l.material = r, l.groupOrder = s, l.renderOrder = i.renderOrder, l.z = a, l.group = o), e++, l
                        }
                        return {
                            opaque: i,
                            transmissive: n,
                            transparent: r,
                            init: function() {
                                e = 0, i.length = 0, n.length = 0, r.length = 0
                            },
                            push: function(t, e, a, o, l, h) {
                                const c = s(t, e, a, o, l, h);
                                a.transmission > 0 ? n.push(c) : !0 === a.transparent ? r.push(c) : i.push(c)
                            },
                            unshift: function(t, e, a, o, l, h) {
                                const c = s(t, e, a, o, l, h);
                                a.transmission > 0 ? n.unshift(c) : !0 === a.transparent ? r.unshift(c) : i.unshift(c)
                            },
                            finish: function() {
                                for (let i = e, n = t.length; i < n; i++) {
                                    const e = t[i];
                                    if (null === e.id) break;
                                    e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                                }
                            },
                            sort: function(t, e) {
                                i.length > 1 && i.sort(t || uo), n.length > 1 && n.sort(e || po), r.length > 1 && r.sort(e || po)
                            }
                        }
                    }

                    function fo() {
                        let t = new WeakMap;
                        return {
                            get: function(e, i) {
                                const n = t.get(e);
                                let r;
                                return void 0 === n ? (r = new mo, t.set(e, [r])) : i >= n.length ? (r = new mo, n.push(r)) : r = n[i], r
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }

                    function go() {
                        const t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let i;
                                switch (e.type) {
                                    case "DirectionalLight":
                                        i = {
                                            direction: new xi,
                                            color: new kn
                                        };
                                        break;
                                    case "SpotLight":
                                        i = {
                                            position: new xi,
                                            direction: new xi,
                                            color: new kn,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0
                                        };
                                        break;
                                    case "PointLight":
                                        i = {
                                            position: new xi,
                                            color: new kn,
                                            distance: 0,
                                            decay: 0
                                        };
                                        break;
                                    case "HemisphereLight":
                                        i = {
                                            direction: new xi,
                                            skyColor: new kn,
                                            groundColor: new kn
                                        };
                                        break;
                                    case "RectAreaLight":
                                        i = {
                                            color: new kn,
                                            position: new xi,
                                            halfWidth: new xi,
                                            halfHeight: new xi
                                        }
                                }
                                return t[e.id] = i, i
                            }
                        }
                    }
                    let vo = 0;

                    function _o(t, e) {
                        return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
                    }

                    function yo(t) {
                        const e = new go,
                            i = function() {
                                const t = {};
                                return {
                                    get: function(e) {
                                        if (void 0 !== t[e.id]) return t[e.id];
                                        let i;
                                        switch (e.type) {
                                            case "DirectionalLight":
                                            case "SpotLight":
                                                i = {
                                                    shadowIntensity: 1,
                                                    shadowBias: 0,
                                                    shadowNormalBias: 0,
                                                    shadowRadius: 1,
                                                    shadowMapSize: new We
                                                };
                                                break;
                                            case "PointLight":
                                                i = {
                                                    shadowIntensity: 1,
                                                    shadowBias: 0,
                                                    shadowNormalBias: 0,
                                                    shadowRadius: 1,
                                                    shadowMapSize: new We,
                                                    shadowCameraNear: 1,
                                                    shadowCameraFar: 1e3
                                                }
                                        }
                                        return t[e.id] = i, i
                                    }
                                }
                            }(),
                            n = {
                                version: 0,
                                hash: {
                                    directionalLength: -1,
                                    pointLength: -1,
                                    spotLength: -1,
                                    rectAreaLength: -1,
                                    hemiLength: -1,
                                    numDirectionalShadows: -1,
                                    numPointShadows: -1,
                                    numSpotShadows: -1,
                                    numSpotMaps: -1,
                                    numLightProbes: -1
                                },
                                ambient: [0, 0, 0],
                                probe: [],
                                directional: [],
                                directionalShadow: [],
                                directionalShadowMap: [],
                                directionalShadowMatrix: [],
                                spot: [],
                                spotLightMap: [],
                                spotShadow: [],
                                spotShadowMap: [],
                                spotLightMatrix: [],
                                rectArea: [],
                                rectAreaLTC1: null,
                                rectAreaLTC2: null,
                                point: [],
                                pointShadow: [],
                                pointShadowMap: [],
                                pointShadowMatrix: [],
                                hemi: [],
                                numSpotLightShadowsWithMaps: 0,
                                numLightProbes: 0
                            };
                        for (let t = 0; t < 9; t++) n.probe.push(new xi);
                        const r = new xi,
                            s = new Zi,
                            a = new Zi;
                        return {
                            setup: function(r) {
                                let s = 0,
                                    a = 0,
                                    o = 0;
                                for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
                                let l = 0,
                                    h = 0,
                                    c = 0,
                                    u = 0,
                                    d = 0,
                                    p = 0,
                                    m = 0,
                                    f = 0,
                                    g = 0,
                                    v = 0,
                                    _ = 0;
                                r.sort(_o);
                                for (let t = 0, y = r.length; t < y; t++) {
                                    const y = r[t],
                                        x = y.color,
                                        M = y.intensity,
                                        b = y.distance,
                                        S = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                                    if (y.isAmbientLight) s += x.r * M, a += x.g * M, o += x.b * M;
                                    else if (y.isLightProbe) {
                                        for (let t = 0; t < 9; t++) n.probe[t].addScaledVector(y.sh.coefficients[t], M);
                                        _++
                                    } else if (y.isDirectionalLight) {
                                        const t = e.get(y);
                                        if (t.color.copy(y.color).multiplyScalar(y.intensity), y.castShadow) {
                                            const t = y.shadow,
                                                e = i.get(y);
                                            e.shadowIntensity = t.intensity, e.shadowBias = t.bias, e.shadowNormalBias = t.normalBias, e.shadowRadius = t.radius, e.shadowMapSize = t.mapSize, n.directionalShadow[l] = e, n.directionalShadowMap[l] = S, n.directionalShadowMatrix[l] = y.shadow.matrix, p++
                                        }
                                        n.directional[l] = t, l++
                                    } else if (y.isSpotLight) {
                                        const t = e.get(y);
                                        t.position.setFromMatrixPosition(y.matrixWorld), t.color.copy(x).multiplyScalar(M), t.distance = b, t.coneCos = Math.cos(y.angle), t.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), t.decay = y.decay, n.spot[c] = t;
                                        const r = y.shadow;
                                        if (y.map && (n.spotLightMap[g] = y.map, g++, r.updateMatrices(y), y.castShadow && v++), n.spotLightMatrix[c] = r.matrix, y.castShadow) {
                                            const t = i.get(y);
                                            t.shadowIntensity = r.intensity, t.shadowBias = r.bias, t.shadowNormalBias = r.normalBias, t.shadowRadius = r.radius, t.shadowMapSize = r.mapSize, n.spotShadow[c] = t, n.spotShadowMap[c] = S, f++
                                        }
                                        c++
                                    } else if (y.isRectAreaLight) {
                                        const t = e.get(y);
                                        t.color.copy(x).multiplyScalar(M), t.halfWidth.set(.5 * y.width, 0, 0), t.halfHeight.set(0, .5 * y.height, 0), n.rectArea[u] = t, u++
                                    } else if (y.isPointLight) {
                                        const t = e.get(y);
                                        if (t.color.copy(y.color).multiplyScalar(y.intensity), t.distance = y.distance, t.decay = y.decay, y.castShadow) {
                                            const t = y.shadow,
                                                e = i.get(y);
                                            e.shadowIntensity = t.intensity, e.shadowBias = t.bias, e.shadowNormalBias = t.normalBias, e.shadowRadius = t.radius, e.shadowMapSize = t.mapSize, e.shadowCameraNear = t.camera.near, e.shadowCameraFar = t.camera.far, n.pointShadow[h] = e, n.pointShadowMap[h] = S, n.pointShadowMatrix[h] = y.shadow.matrix, m++
                                        }
                                        n.point[h] = t, h++
                                    } else if (y.isHemisphereLight) {
                                        const t = e.get(y);
                                        t.skyColor.copy(y.color).multiplyScalar(M), t.groundColor.copy(y.groundColor).multiplyScalar(M), n.hemi[d] = t, d++
                                    }
                                }
                                u > 0 && (!0 === t.has("OES_texture_float_linear") ? (n.rectAreaLTC1 = es.LTC_FLOAT_1, n.rectAreaLTC2 = es.LTC_FLOAT_2) : (n.rectAreaLTC1 = es.LTC_HALF_1, n.rectAreaLTC2 = es.LTC_HALF_2)), n.ambient[0] = s, n.ambient[1] = a, n.ambient[2] = o;
                                const y = n.hash;
                                y.directionalLength === l && y.pointLength === h && y.spotLength === c && y.rectAreaLength === u && y.hemiLength === d && y.numDirectionalShadows === p && y.numPointShadows === m && y.numSpotShadows === f && y.numSpotMaps === g && y.numLightProbes === _ || (n.directional.length = l, n.spot.length = c, n.rectArea.length = u, n.point.length = h, n.hemi.length = d, n.directionalShadow.length = p, n.directionalShadowMap.length = p, n.pointShadow.length = m, n.pointShadowMap.length = m, n.spotShadow.length = f, n.spotShadowMap.length = f, n.directionalShadowMatrix.length = p, n.pointShadowMatrix.length = m, n.spotLightMatrix.length = f + g - v, n.spotLightMap.length = g, n.numSpotLightShadowsWithMaps = v, n.numLightProbes = _, y.directionalLength = l, y.pointLength = h, y.spotLength = c, y.rectAreaLength = u, y.hemiLength = d, y.numDirectionalShadows = p, y.numPointShadows = m, y.numSpotShadows = f, y.numSpotMaps = g, y.numLightProbes = _, n.version = vo++)
                            },
                            setupView: function(t, e) {
                                let i = 0,
                                    o = 0,
                                    l = 0,
                                    h = 0,
                                    c = 0;
                                const u = e.matrixWorldInverse;
                                for (let e = 0, d = t.length; e < d; e++) {
                                    const d = t[e];
                                    if (d.isDirectionalLight) {
                                        const t = n.directional[i];
                                        t.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(r), t.direction.transformDirection(u), i++
                                    } else if (d.isSpotLight) {
                                        const t = n.spot[l];
                                        t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(r), t.direction.transformDirection(u), l++
                                    } else if (d.isRectAreaLight) {
                                        const t = n.rectArea[h];
                                        t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a.identity(), s.copy(d.matrixWorld), s.premultiply(u), a.extractRotation(s), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), h++
                                    } else if (d.isPointLight) {
                                        const t = n.point[o];
                                        t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), o++
                                    } else if (d.isHemisphereLight) {
                                        const t = n.hemi[c];
                                        t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), c++
                                    }
                                }
                            },
                            state: n
                        }
                    }

                    function xo(t) {
                        const e = new yo(t),
                            i = [],
                            n = [],
                            r = {
                                lightsArray: i,
                                shadowsArray: n,
                                camera: null,
                                lights: e,
                                transmissionRenderTarget: {}
                            };
                        return {
                            init: function(t) {
                                r.camera = t, i.length = 0, n.length = 0
                            },
                            state: r,
                            setupLights: function() {
                                e.setup(i)
                            },
                            setupLightsView: function(t) {
                                e.setupView(i, t)
                            },
                            pushLight: function(t) {
                                i.push(t)
                            },
                            pushShadow: function(t) {
                                n.push(t)
                            }
                        }
                    }

                    function Mo(t) {
                        let e = new WeakMap;
                        return {
                            get: function(i, n = 0) {
                                const r = e.get(i);
                                let s;
                                return void 0 === r ? (s = new xo(t), e.set(i, [s])) : n >= r.length ? (s = new xo(t), r.push(s)) : s = r[n], s
                            },
                            dispose: function() {
                                e = new WeakMap
                            }
                        }
                    }
                    class bo extends Gn {
                        constructor(t) {
                            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                        }
                    }
                    class So extends Gn {
                        constructor(t) {
                            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                        }
                    }

                    function wo(t, e, i) {
                        let r = new Zr;
                        const h = new We,
                            c = new We,
                            u = new mi,
                            d = new bo({
                                depthPacking: 3201
                            }),
                            p = new So,
                            m = {},
                            f = i.maxTextureSize,
                            g = {
                                [a]: 1,
                                [o]: 0,
                                [l]: 2
                            },
                            v = new Nr({
                                defines: {
                                    VSM_SAMPLES: 8
                                },
                                uniforms: {
                                    shadow_pass: {
                                        value: null
                                    },
                                    resolution: {
                                        value: new We
                                    },
                                    radius: {
                                        value: 4
                                    }
                                },
                                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                            }),
                            _ = v.clone();
                        _.defines.HORIZONTAL_PASS = 1;
                        const y = new hr;
                        y.setAttribute("position", new Qn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                        const x = new Er(y, v),
                            M = this;
                        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = n;
                        let b = this.type;

                        function S(i, n) {
                            const r = e.update(x);
                            v.defines.VSM_SAMPLES !== i.blurSamples && (v.defines.VSM_SAMPLES = i.blurSamples, _.defines.VSM_SAMPLES = i.blurSamples, v.needsUpdate = !0, _.needsUpdate = !0), null === i.mapPass && (i.mapPass = new gi(h.x, h.y)), v.uniforms.shadow_pass.value = i.map.texture, v.uniforms.resolution.value = i.mapSize, v.uniforms.radius.value = i.radius, t.setRenderTarget(i.mapPass), t.clear(), t.renderBufferDirect(n, null, r, v, x, null), _.uniforms.shadow_pass.value = i.mapPass.texture, _.uniforms.resolution.value = i.mapSize, _.uniforms.radius.value = i.radius, t.setRenderTarget(i.map), t.clear(), t.renderBufferDirect(n, null, r, _, x, null)
                        }

                        function w(e, i, n, r) {
                            let a = null;
                            const o = !0 === n.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                            if (void 0 !== o) a = o;
                            else if (a = !0 === n.isPointLight ? p : d, t.localClippingEnabled && !0 === i.clipShadows && Array.isArray(i.clippingPlanes) && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0 || i.map && i.alphaTest > 0) {
                                const t = a.uuid,
                                    e = i.uuid;
                                let n = m[t];
                                void 0 === n && (n = {}, m[t] = n);
                                let r = n[e];
                                void 0 === r && (r = a.clone(), n[e] = r, i.addEventListener("dispose", T)), a = r
                            }
                            return a.visible = i.visible, a.wireframe = i.wireframe, a.side = r === s ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : g[i.side], a.alphaMap = i.alphaMap, a.alphaTest = i.alphaTest, a.map = i.map, a.clipShadows = i.clipShadows, a.clippingPlanes = i.clippingPlanes, a.clipIntersection = i.clipIntersection, a.displacementMap = i.displacementMap, a.displacementScale = i.displacementScale, a.displacementBias = i.displacementBias, a.wireframeLinewidth = i.wireframeLinewidth, a.linewidth = i.linewidth, !0 === n.isPointLight && !0 === a.isMeshDistanceMaterial && (t.properties.get(a).light = n), a
                        }

                        function A(i, n, a, o, l) {
                            if (!1 === i.visible) return;
                            if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && l === s) && (!i.frustumCulled || r.intersectsObject(i))) {
                                i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld);
                                const r = e.update(i),
                                    s = i.material;
                                if (Array.isArray(s)) {
                                    const e = r.groups;
                                    for (let h = 0, c = e.length; h < c; h++) {
                                        const c = e[h],
                                            u = s[c.materialIndex];
                                        if (u && u.visible) {
                                            const e = w(i, u, o, l);
                                            i.onBeforeShadow(t, i, n, a, r, e, c), t.renderBufferDirect(a, null, r, e, i, c), i.onAfterShadow(t, i, n, a, r, e, c)
                                        }
                                    }
                                } else if (s.visible) {
                                    const e = w(i, s, o, l);
                                    i.onBeforeShadow(t, i, n, a, r, e, null), t.renderBufferDirect(a, null, r, e, i, null), i.onAfterShadow(t, i, n, a, r, e, null)
                                }
                            }
                            const h = i.children;
                            for (let t = 0, e = h.length; t < e; t++) A(h[t], n, a, o, l)
                        }

                        function T(t) {
                            t.target.removeEventListener("dispose", T);
                            for (const e in m) {
                                const i = m[e],
                                    n = t.target.uuid;
                                n in i && (i[n].dispose(), delete i[n])
                            }
                        }
                        this.render = function(e, i, n) {
                            if (!1 === M.enabled) return;
                            if (!1 === M.autoUpdate && !1 === M.needsUpdate) return;
                            if (0 === e.length) return;
                            const a = t.getRenderTarget(),
                                o = t.getActiveCubeFace(),
                                l = t.getActiveMipmapLevel(),
                                d = t.state;
                            d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                            const p = b !== s && this.type === s,
                                m = b === s && this.type !== s;
                            for (let a = 0, o = e.length; a < o; a++) {
                                const o = e[a],
                                    l = o.shadow;
                                if (void 0 === l) {
                                    console.warn("THREE.WebGLShadowMap:", o, "has no shadow.");
                                    continue
                                }
                                if (!1 === l.autoUpdate && !1 === l.needsUpdate) continue;
                                h.copy(l.mapSize);
                                const g = l.getFrameExtents();
                                if (h.multiply(g), c.copy(l.mapSize), (h.x > f || h.y > f) && (h.x > f && (c.x = Math.floor(f / g.x), h.x = c.x * g.x, l.mapSize.x = c.x), h.y > f && (c.y = Math.floor(f / g.y), h.y = c.y * g.y, l.mapSize.y = c.y)), null === l.map || !0 === p || !0 === m) {
                                    const t = this.type !== s ? {
                                        minFilter: J,
                                        magFilter: J
                                    } : {};
                                    null !== l.map && l.map.dispose(), l.map = new gi(h.x, h.y, t), l.map.texture.name = o.name + ".shadowMap", l.camera.updateProjectionMatrix()
                                }
                                t.setRenderTarget(l.map), t.clear();
                                const v = l.getViewportCount();
                                for (let t = 0; t < v; t++) {
                                    const e = l.getViewport(t);
                                    u.set(c.x * e.x, c.y * e.y, c.x * e.z, c.y * e.w), d.viewport(u), l.updateMatrices(o, t), r = l.getFrustum(), A(i, n, l.camera, o, this.type)
                                }!0 !== l.isPointLightShadow && this.type === s && S(l, n), l.needsUpdate = !1
                            }
                            b = this.type, M.needsUpdate = !1, t.setRenderTarget(a, o, l)
                        }
                    }

                    function Ao(t) {
                        const e = new function() {
                                let e = !1;
                                const i = new mi;
                                let n = null;
                                const r = new mi(0, 0, 0, 0);
                                return {
                                    setMask: function(i) {
                                        n === i || e || (t.colorMask(i, i, i, i), n = i)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e, n, s, a, o) {
                                        !0 === o && (e *= a, n *= a, s *= a), i.set(e, n, s, a), !1 === r.equals(i) && (t.clearColor(e, n, s, a), r.copy(i))
                                    },
                                    reset: function() {
                                        e = !1, n = null, r.set(-1, 0, 0, 0)
                                    }
                                }
                            },
                            i = new function() {
                                let e = !1,
                                    i = null,
                                    n = null,
                                    r = null;
                                return {
                                    setTest: function(e) {
                                        e ? nt(t.DEPTH_TEST) : rt(t.DEPTH_TEST)
                                    },
                                    setMask: function(n) {
                                        i === n || e || (t.depthMask(n), i = n)
                                    },
                                    setFunc: function(e) {
                                        if (n !== e) {
                                            switch (e) {
                                                case 0:
                                                    t.depthFunc(t.NEVER);
                                                    break;
                                                case 1:
                                                    t.depthFunc(t.ALWAYS);
                                                    break;
                                                case 2:
                                                    t.depthFunc(t.LESS);
                                                    break;
                                                case 3:
                                                default:
                                                    t.depthFunc(t.LEQUAL);
                                                    break;
                                                case 4:
                                                    t.depthFunc(t.EQUAL);
                                                    break;
                                                case 5:
                                                    t.depthFunc(t.GEQUAL);
                                                    break;
                                                case 6:
                                                    t.depthFunc(t.GREATER);
                                                    break;
                                                case 7:
                                                    t.depthFunc(t.NOTEQUAL)
                                            }
                                            n = e
                                        }
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        r !== e && (t.clearDepth(e), r = e)
                                    },
                                    reset: function() {
                                        e = !1, i = null, n = null, r = null
                                    }
                                }
                            },
                            n = new function() {
                                let e = !1,
                                    i = null,
                                    n = null,
                                    r = null,
                                    s = null,
                                    a = null,
                                    o = null,
                                    l = null,
                                    h = null;
                                return {
                                    setTest: function(i) {
                                        e || (i ? nt(t.STENCIL_TEST) : rt(t.STENCIL_TEST))
                                    },
                                    setMask: function(n) {
                                        i === n || e || (t.stencilMask(n), i = n)
                                    },
                                    setFunc: function(e, i, a) {
                                        n === e && r === i && s === a || (t.stencilFunc(e, i, a), n = e, r = i, s = a)
                                    },
                                    setOp: function(e, i, n) {
                                        a === e && o === i && l === n || (t.stencilOp(e, i, n), a = e, o = i, l = n)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        h !== e && (t.clearStencil(e), h = e)
                                    },
                                    reset: function() {
                                        e = !1, i = null, n = null, r = null, s = null, a = null, o = null, l = null, h = null
                                    }
                                }
                            },
                            r = new WeakMap,
                            s = new WeakMap;
                        let a = {},
                            o = {},
                            l = new WeakMap,
                            E = [],
                            C = null,
                            R = !1,
                            P = null,
                            I = null,
                            L = null,
                            U = null,
                            N = null,
                            D = null,
                            O = null,
                            B = new kn(0, 0, 0),
                            z = 0,
                            F = !1,
                            k = null,
                            V = null,
                            H = null,
                            G = null,
                            W = null;
                        const j = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                        let X = !1,
                            q = 0;
                        const Y = t.getParameter(t.VERSION); - 1 !== Y.indexOf("WebGL") ? (q = parseFloat(/^WebGL (\d)/.exec(Y)[1]), X = q >= 1) : -1 !== Y.indexOf("OpenGL ES") && (q = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]), X = q >= 2);
                        let J = null,
                            Z = {};
                        const K = t.getParameter(t.SCISSOR_BOX),
                            Q = t.getParameter(t.VIEWPORT),
                            $ = (new mi).fromArray(K),
                            tt = (new mi).fromArray(Q);

                        function et(e, i, n, r) {
                            const s = new Uint8Array(4),
                                a = t.createTexture();
                            t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                            for (let a = 0; a < n; a++) e === t.TEXTURE_3D || e === t.TEXTURE_2D_ARRAY ? t.texImage3D(i, 0, t.RGBA, 1, 1, r, 0, t.RGBA, t.UNSIGNED_BYTE, s) : t.texImage2D(i + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, s);
                            return a
                        }
                        const it = {};

                        function nt(e) {
                            !0 !== a[e] && (t.enable(e), a[e] = !0)
                        }

                        function rt(e) {
                            !1 !== a[e] && (t.disable(e), a[e] = !1)
                        }
                        it[t.TEXTURE_2D] = et(t.TEXTURE_2D, t.TEXTURE_2D, 1), it[t.TEXTURE_CUBE_MAP] = et(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), it[t.TEXTURE_2D_ARRAY] = et(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), it[t.TEXTURE_3D] = et(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1), e.setClear(0, 0, 0, 1), i.setClear(1), n.setClear(0), nt(t.DEPTH_TEST), i.setFunc(3), lt(!1), ht(1), nt(t.CULL_FACE), ot(0);
                        const st = {
                            [h]: t.FUNC_ADD,
                            [c]: t.FUNC_SUBTRACT,
                            [u]: t.FUNC_REVERSE_SUBTRACT
                        };
                        st[103] = t.MIN, st[104] = t.MAX;
                        const at = {
                            [d]: t.ZERO,
                            [p]: t.ONE,
                            [m]: t.SRC_COLOR,
                            [g]: t.SRC_ALPHA,
                            [b]: t.SRC_ALPHA_SATURATE,
                            [x]: t.DST_COLOR,
                            [_]: t.DST_ALPHA,
                            [f]: t.ONE_MINUS_SRC_COLOR,
                            [v]: t.ONE_MINUS_SRC_ALPHA,
                            [M]: t.ONE_MINUS_DST_COLOR,
                            [y]: t.ONE_MINUS_DST_ALPHA,
                            [S]: t.CONSTANT_COLOR,
                            [w]: t.ONE_MINUS_CONSTANT_COLOR,
                            [A]: t.CONSTANT_ALPHA,
                            [T]: t.ONE_MINUS_CONSTANT_ALPHA
                        };

                        function ot(e, i, n, r, s, a, o, l, c, u) {
                            if (0 !== e) {
                                if (!1 === R && (nt(t.BLEND), R = !0), 5 === e) s = s || i, a = a || n, o = o || r, i === I && s === N || (t.blendEquationSeparate(st[i], st[s]), I = i, N = s), n === L && r === U && a === D && o === O || (t.blendFuncSeparate(at[n], at[r], at[a], at[o]), L = n, U = r, D = a, O = o), !1 !== l.equals(B) && c === z || (t.blendColor(l.r, l.g, l.b, c), B.copy(l), z = c), P = e, F = !1;
                                else if (e !== P || u !== F) {
                                    if (I === h && N === h || (t.blendEquation(t.FUNC_ADD), I = h, N = h), u) switch (e) {
                                        case 1:
                                            t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case 2:
                                            t.blendFunc(t.ONE, t.ONE);
                                            break;
                                        case 3:
                                            t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                            break;
                                        case 4:
                                            t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    } else switch (e) {
                                        case 1:
                                            t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case 2:
                                            t.blendFunc(t.SRC_ALPHA, t.ONE);
                                            break;
                                        case 3:
                                            t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                            break;
                                        case 4:
                                            t.blendFunc(t.ZERO, t.SRC_COLOR);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    }
                                    L = null, U = null, D = null, O = null, B.set(0, 0, 0), z = 0, P = e, F = u
                                }
                            } else !0 === R && (rt(t.BLEND), R = !1)
                        }

                        function lt(e) {
                            k !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), k = e)
                        }

                        function ht(e) {
                            0 !== e ? (nt(t.CULL_FACE), e !== V && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : rt(t.CULL_FACE), V = e
                        }

                        function ct(e, i, n) {
                            e ? (nt(t.POLYGON_OFFSET_FILL), G === i && W === n || (t.polygonOffset(i, n), G = i, W = n)) : rt(t.POLYGON_OFFSET_FILL)
                        }
                        return {
                            buffers: {
                                color: e,
                                depth: i,
                                stencil: n
                            },
                            enable: nt,
                            disable: rt,
                            bindFramebuffer: function(e, i) {
                                return o[e] !== i && (t.bindFramebuffer(e, i), o[e] = i, e === t.DRAW_FRAMEBUFFER && (o[t.FRAMEBUFFER] = i), e === t.FRAMEBUFFER && (o[t.DRAW_FRAMEBUFFER] = i), !0)
                            },
                            drawBuffers: function(e, i) {
                                let n = E,
                                    r = !1;
                                if (e) {
                                    n = l.get(i), void 0 === n && (n = [], l.set(i, n));
                                    const s = e.textures;
                                    if (n.length !== s.length || n[0] !== t.COLOR_ATTACHMENT0) {
                                        for (let e = 0, i = s.length; e < i; e++) n[e] = t.COLOR_ATTACHMENT0 + e;
                                        n.length = s.length, r = !0
                                    }
                                } else n[0] !== t.BACK && (n[0] = t.BACK, r = !0);
                                r && t.drawBuffers(n)
                            },
                            useProgram: function(e) {
                                return C !== e && (t.useProgram(e), C = e, !0)
                            },
                            setBlending: ot,
                            setMaterial: function(r, s) {
                                2 === r.side ? rt(t.CULL_FACE) : nt(t.CULL_FACE);
                                let a = 1 === r.side;
                                s && (a = !a), lt(a), 1 === r.blending && !1 === r.transparent ? ot(0) : ot(r.blending, r.blendEquation, r.blendSrc, r.blendDst, r.blendEquationAlpha, r.blendSrcAlpha, r.blendDstAlpha, r.blendColor, r.blendAlpha, r.premultipliedAlpha), i.setFunc(r.depthFunc), i.setTest(r.depthTest), i.setMask(r.depthWrite), e.setMask(r.colorWrite);
                                const o = r.stencilWrite;
                                n.setTest(o), o && (n.setMask(r.stencilWriteMask), n.setFunc(r.stencilFunc, r.stencilRef, r.stencilFuncMask), n.setOp(r.stencilFail, r.stencilZFail, r.stencilZPass)), ct(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits), !0 === r.alphaToCoverage ? nt(t.SAMPLE_ALPHA_TO_COVERAGE) : rt(t.SAMPLE_ALPHA_TO_COVERAGE)
                            },
                            setFlipSided: lt,
                            setCullFace: ht,
                            setLineWidth: function(e) {
                                e !== H && (X && t.lineWidth(e), H = e)
                            },
                            setPolygonOffset: ct,
                            setScissorTest: function(e) {
                                e ? nt(t.SCISSOR_TEST) : rt(t.SCISSOR_TEST)
                            },
                            activeTexture: function(e) {
                                void 0 === e && (e = t.TEXTURE0 + j - 1), J !== e && (t.activeTexture(e), J = e)
                            },
                            bindTexture: function(e, i, n) {
                                void 0 === n && (n = null === J ? t.TEXTURE0 + j - 1 : J);
                                let r = Z[n];
                                void 0 === r && (r = {
                                    type: void 0,
                                    texture: void 0
                                }, Z[n] = r), r.type === e && r.texture === i || (J !== n && (t.activeTexture(n), J = n), t.bindTexture(e, i || it[e]), r.type = e, r.texture = i)
                            },
                            unbindTexture: function() {
                                const e = Z[J];
                                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    t.compressedTexImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            compressedTexImage3D: function() {
                                try {
                                    t.compressedTexImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    t.texImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage3D: function() {
                                try {
                                    t.texImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            updateUBOMapping: function(e, i) {
                                let n = s.get(i);
                                void 0 === n && (n = new WeakMap, s.set(i, n));
                                let r = n.get(e);
                                void 0 === r && (r = t.getUniformBlockIndex(i, e.name), n.set(e, r))
                            },
                            uniformBlockBinding: function(e, i) {
                                const n = s.get(i).get(e);
                                r.get(i) !== n && (t.uniformBlockBinding(i, n, e.__bindingPointIndex), r.set(i, n))
                            },
                            texStorage2D: function() {
                                try {
                                    t.texStorage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texStorage3D: function() {
                                try {
                                    t.texStorage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texSubImage2D: function() {
                                try {
                                    t.texSubImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texSubImage3D: function() {
                                try {
                                    t.texSubImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            compressedTexSubImage2D: function() {
                                try {
                                    t.compressedTexSubImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            compressedTexSubImage3D: function() {
                                try {
                                    t.compressedTexSubImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            scissor: function(e) {
                                !1 === $.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), $.copy(e))
                            },
                            viewport: function(e) {
                                !1 === tt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), tt.copy(e))
                            },
                            reset: function() {
                                t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, J = null, Z = {}, o = {}, l = new WeakMap, E = [], C = null, R = !1, P = null, I = null, L = null, U = null, N = null, D = null, O = null, B = new kn(0, 0, 0), z = 0, F = !1, k = null, V = null, H = null, G = null, W = null, $.set(0, 0, t.canvas.width, t.canvas.height), tt.set(0, 0, t.canvas.width, t.canvas.height), e.reset(), i.reset(), n.reset()
                            }
                        }
                    }

                    function To(t, e, i, n) {
                        const r = function(t) {
                            switch (t) {
                                case et:
                                case it:
                                    return {
                                        byteLength: 1, components: 1
                                    };
                                case rt:
                                case nt:
                                case lt:
                                    return {
                                        byteLength: 2, components: 1
                                    };
                                case ht:
                                case ct:
                                    return {
                                        byteLength: 2, components: 4
                                    };
                                case at:
                                case st:
                                case ot:
                                    return {
                                        byteLength: 4, components: 1
                                    };
                                case dt:
                                    return {
                                        byteLength: 4, components: 3
                                    }
                            }
                            throw new Error(`Unknown texture type ${t}.`)
                        }(n);
                        switch (i) {
                            case pt:
                            case gt:
                                return t * e;
                            case vt:
                                return t * e * 2;
                            case xt:
                            case Mt:
                                return t * e / r.components * r.byteLength;
                            case bt:
                            case St:
                                return t * e * 2 / r.components * r.byteLength;
                            case mt:
                                return t * e * 3 / r.components * r.byteLength;
                            case ft:
                            case wt:
                                return t * e * 4 / r.components * r.byteLength;
                            case At:
                            case Tt:
                                return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
                            case Et:
                            case Ct:
                                return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                            case Pt:
                            case Lt:
                                return Math.max(t, 16) * Math.max(e, 8) / 4;
                            case Rt:
                            case It:
                                return Math.max(t, 8) * Math.max(e, 8) / 2;
                            case Ut:
                            case Nt:
                                return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
                            case Dt:
                            case Ot:
                                return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                            case Bt:
                                return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16;
                            case zt:
                                return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16;
                            case Ft:
                                return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16;
                            case kt:
                                return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16;
                            case Vt:
                                return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16;
                            case Ht:
                                return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16;
                            case Gt:
                                return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16;
                            case Wt:
                                return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16;
                            case jt:
                                return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16;
                            case Xt:
                                return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16;
                            case qt:
                                return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16;
                            case Yt:
                                return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16;
                            case Jt:
                                return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16;
                            case Zt:
                            case Kt:
                            case Qt:
                                return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
                            case $t:
                            case te:
                                return Math.ceil(t / 4) * Math.ceil(e / 4) * 8;
                            case ee:
                            case ie:
                                return Math.ceil(t / 4) * Math.ceil(e / 4) * 16
                        }
                        throw new Error(`Unable to determine texture byte length for ${i} format.`)
                    }
                    const Eo = {
                        contain: function(t, e) {
                            const i = t.image && t.image.width ? t.image.width / t.image.height : 1;
                            return i > e ? (t.repeat.x = 1, t.repeat.y = i / e, t.offset.x = 0, t.offset.y = (1 - t.repeat.y) / 2) : (t.repeat.x = e / i, t.repeat.y = 1, t.offset.x = (1 - t.repeat.x) / 2, t.offset.y = 0), t
                        },
                        cover: function(t, e) {
                            const i = t.image && t.image.width ? t.image.width / t.image.height : 1;
                            return i > e ? (t.repeat.x = e / i, t.repeat.y = 1, t.offset.x = (1 - t.repeat.x) / 2, t.offset.y = 0) : (t.repeat.x = 1, t.repeat.y = i / e, t.offset.x = 0, t.offset.y = (1 - t.repeat.y) / 2), t
                        },
                        fill: function(t) {
                            return t.repeat.x = 1, t.repeat.y = 1, t.offset.x = 0, t.offset.y = 0, t
                        },
                        getByteLength: To
                    };

                    function Co(t, e, i, n, r, s, a) {
                        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
                            l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                            h = new We,
                            c = new WeakMap;
                        let u;
                        const d = new WeakMap;
                        let p = !1;
                        try {
                            p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                        } catch (t) {}

                        function m(t, e) {
                            return p ? new OffscreenCanvas(t, e) : Ze("canvas")
                        }

                        function f(t, e, i) {
                            let n = 1;
                            const r = k(t);
                            if ((r.width > i || r.height > i) && (n = i / Math.max(r.width, r.height)), n < 1) {
                                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof VideoFrame && t instanceof VideoFrame) {
                                    const i = Math.floor(n * r.width),
                                        s = Math.floor(n * r.height);
                                    void 0 === u && (u = m(i, s));
                                    const a = e ? m(i, s) : u;
                                    return a.width = i, a.height = s, a.getContext("2d").drawImage(t, 0, 0, i, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + i + "x" + s + ")."), a
                                }
                                return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."), t
                            }
                            return t
                        }

                        function g(t) {
                            return t.generateMipmaps && t.minFilter !== J && t.minFilter !== Q
                        }

                        function v(e) {
                            t.generateMipmap(e)
                        }

                        function _(i, n, r, s, a = !1) {
                            if (null !== i) {
                                if (void 0 !== t[i]) return t[i];
                                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
                            }
                            let o = n;
                            if (n === t.RED && (r === t.FLOAT && (o = t.R32F), r === t.HALF_FLOAT && (o = t.R16F), r === t.UNSIGNED_BYTE && (o = t.R8)), n === t.RED_INTEGER && (r === t.UNSIGNED_BYTE && (o = t.R8UI), r === t.UNSIGNED_SHORT && (o = t.R16UI), r === t.UNSIGNED_INT && (o = t.R32UI), r === t.BYTE && (o = t.R8I), r === t.SHORT && (o = t.R16I), r === t.INT && (o = t.R32I)), n === t.RG && (r === t.FLOAT && (o = t.RG32F), r === t.HALF_FLOAT && (o = t.RG16F), r === t.UNSIGNED_BYTE && (o = t.RG8)), n === t.RG_INTEGER && (r === t.UNSIGNED_BYTE && (o = t.RG8UI), r === t.UNSIGNED_SHORT && (o = t.RG16UI), r === t.UNSIGNED_INT && (o = t.RG32UI), r === t.BYTE && (o = t.RG8I), r === t.SHORT && (o = t.RG16I), r === t.INT && (o = t.RG32I)), n === t.RGB && r === t.UNSIGNED_INT_5_9_9_9_REV && (o = t.RGB9_E5), n === t.RGBA) {
                                const e = a ? fe : ri.getTransfer(s);
                                r === t.FLOAT && (o = t.RGBA32F), r === t.HALF_FLOAT && (o = t.RGBA16F), r === t.UNSIGNED_BYTE && (o = e === ge ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (o = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (o = t.RGB5_A1)
                            }
                            return o !== t.R16F && o !== t.R32F && o !== t.RG16F && o !== t.RG32F && o !== t.RGBA16F && o !== t.RGBA32F || e.get("EXT_color_buffer_float"), o
                        }

                        function y(e, i) {
                            let n;
                            return e ? null === i || i === at || i === ut ? n = t.DEPTH24_STENCIL8 : i === ot ? n = t.DEPTH32F_STENCIL8 : i === rt && (n = t.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === i || i === at || i === ut ? n = t.DEPTH_COMPONENT24 : i === ot ? n = t.DEPTH_COMPONENT32F : i === rt && (n = t.DEPTH_COMPONENT16), n
                        }

                        function x(t, e) {
                            return !0 === g(t) || t.isFramebufferTexture && t.minFilter !== J && t.minFilter !== Q ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
                        }

                        function M(t) {
                            const e = t.target;
                            e.removeEventListener("dispose", M),
                                function(t) {
                                    const e = n.get(t);
                                    if (void 0 === e.__webglInit) return;
                                    const i = t.source,
                                        r = d.get(i);
                                    if (r) {
                                        const n = r[e.__cacheKey];
                                        n.usedTimes--, 0 === n.usedTimes && S(t), 0 === Object.keys(r).length && d.delete(i)
                                    }
                                    n.remove(t)
                                }(e), e.isVideoTexture && c.delete(e)
                        }

                        function b(e) {
                            const i = e.target;
                            i.removeEventListener("dispose", b),
                                function(e) {
                                    const i = n.get(e);
                                    if (e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                        for (let e = 0; e < 6; e++) {
                                            if (Array.isArray(i.__webglFramebuffer[e]))
                                                for (let n = 0; n < i.__webglFramebuffer[e].length; n++) t.deleteFramebuffer(i.__webglFramebuffer[e][n]);
                                            else t.deleteFramebuffer(i.__webglFramebuffer[e]);
                                            i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[e])
                                        } else {
                                            if (Array.isArray(i.__webglFramebuffer))
                                                for (let e = 0; e < i.__webglFramebuffer.length; e++) t.deleteFramebuffer(i.__webglFramebuffer[e]);
                                            else t.deleteFramebuffer(i.__webglFramebuffer);
                                            if (i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer)
                                                for (let e = 0; e < i.__webglColorRenderbuffer.length; e++) i.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(i.__webglColorRenderbuffer[e]);
                                            i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer)
                                        }
                                    const r = e.textures;
                                    for (let e = 0, i = r.length; e < i; e++) {
                                        const i = n.get(r[e]);
                                        i.__webglTexture && (t.deleteTexture(i.__webglTexture), a.memory.textures--), n.remove(r[e])
                                    }
                                    n.remove(e)
                                }(i)
                        }

                        function S(e) {
                            const i = n.get(e);
                            t.deleteTexture(i.__webglTexture);
                            const r = e.source;
                            delete d.get(r)[i.__cacheKey], a.memory.textures--
                        }
                        let w = 0;

                        function A(e, r) {
                            const s = n.get(e);
                            if (e.isVideoTexture && function(t) {
                                    const e = a.render.frame;
                                    c.get(t) !== e && (c.set(t, e), t.update())
                                }(e), !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version) {
                                const t = e.image;
                                if (null === t) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                                else {
                                    if (!1 !== t.complete) return void I(s, e, r);
                                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                                }
                            }
                            i.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r)
                        }
                        const T = {
                                [X]: t.REPEAT,
                                [q]: t.CLAMP_TO_EDGE,
                                [Y]: t.MIRRORED_REPEAT
                            },
                            E = {
                                [J]: t.NEAREST,
                                [Z]: t.NEAREST_MIPMAP_NEAREST,
                                [K]: t.NEAREST_MIPMAP_LINEAR,
                                [Q]: t.LINEAR,
                                [$]: t.LINEAR_MIPMAP_NEAREST,
                                [tt]: t.LINEAR_MIPMAP_LINEAR
                            },
                            C = {
                                [xe]: t.NEVER,
                                [Ee]: t.ALWAYS,
                                [Me]: t.LESS,
                                [Se]: t.LEQUAL,
                                [be]: t.EQUAL,
                                [Te]: t.GEQUAL,
                                [we]: t.GREATER,
                                [Ae]: t.NOTEQUAL
                            };

                        function R(i, s) {
                            if (s.type !== ot || !1 !== e.has("OES_texture_float_linear") || s.magFilter !== Q && s.magFilter !== $ && s.magFilter !== K && s.magFilter !== tt && s.minFilter !== Q && s.minFilter !== $ && s.minFilter !== K && s.minFilter !== tt || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), t.texParameteri(i, t.TEXTURE_WRAP_S, T[s.wrapS]), t.texParameteri(i, t.TEXTURE_WRAP_T, T[s.wrapT]), i !== t.TEXTURE_3D && i !== t.TEXTURE_2D_ARRAY || t.texParameteri(i, t.TEXTURE_WRAP_R, T[s.wrapR]), t.texParameteri(i, t.TEXTURE_MAG_FILTER, E[s.magFilter]), t.texParameteri(i, t.TEXTURE_MIN_FILTER, E[s.minFilter]), s.compareFunction && (t.texParameteri(i, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(i, t.TEXTURE_COMPARE_FUNC, C[s.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                                if (s.magFilter === J) return;
                                if (s.minFilter !== K && s.minFilter !== tt) return;
                                if (s.type === ot && !1 === e.has("OES_texture_float_linear")) return;
                                if (s.anisotropy > 1 || n.get(s).__currentAnisotropy) {
                                    const a = e.get("EXT_texture_filter_anisotropic");
                                    t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy
                                }
                            }
                        }

                        function P(e, i) {
                            let n = !1;
                            void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", M));
                            const r = i.source;
                            let s = d.get(r);
                            void 0 === s && (s = {}, d.set(r, s));
                            const o = function(t) {
                                const e = [];
                                return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
                            }(i);
                            if (o !== e.__cacheKey) {
                                void 0 === s[o] && (s[o] = {
                                    texture: t.createTexture(),
                                    usedTimes: 0
                                }, a.memory.textures++, n = !0), s[o].usedTimes++;
                                const r = s[e.__cacheKey];
                                void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && S(i)), e.__cacheKey = o, e.__webglTexture = s[o].texture
                            }
                            return n
                        }

                        function I(e, a, o) {
                            let l = t.TEXTURE_2D;
                            (a.isDataArrayTexture || a.isCompressedArrayTexture) && (l = t.TEXTURE_2D_ARRAY), a.isData3DTexture && (l = t.TEXTURE_3D);
                            const h = P(e, a),
                                c = a.source;
                            i.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
                            const u = n.get(c);
                            if (c.version !== u.__version || !0 === h) {
                                i.activeTexture(t.TEXTURE0 + o);
                                const e = ri.getPrimaries(ri.workingColorSpace),
                                    n = a.colorSpace === ce ? null : ri.getPrimaries(a.colorSpace),
                                    d = a.colorSpace === ce || e === n ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                                let p = f(a.image, !1, r.maxTextureSize);
                                p = F(a, p);
                                const m = s.convert(a.format, a.colorSpace),
                                    M = s.convert(a.type);
                                let b, S = _(a.internalFormat, m, M, a.colorSpace, a.isVideoTexture);
                                R(l, a);
                                const w = a.mipmaps,
                                    A = !0 !== a.isVideoTexture,
                                    T = void 0 === u.__version || !0 === h,
                                    E = c.dataReady,
                                    C = x(a, p);
                                if (a.isDepthTexture) S = y(a.format === yt, a.type), T && (A ? i.texStorage2D(t.TEXTURE_2D, 1, S, p.width, p.height) : i.texImage2D(t.TEXTURE_2D, 0, S, p.width, p.height, 0, m, M, null));
                                else if (a.isDataTexture)
                                    if (w.length > 0) {
                                        A && T && i.texStorage2D(t.TEXTURE_2D, C, S, w[0].width, w[0].height);
                                        for (let e = 0, n = w.length; e < n; e++) b = w[e], A ? E && i.texSubImage2D(t.TEXTURE_2D, e, 0, 0, b.width, b.height, m, M, b.data) : i.texImage2D(t.TEXTURE_2D, e, S, b.width, b.height, 0, m, M, b.data);
                                        a.generateMipmaps = !1
                                    } else A ? (T && i.texStorage2D(t.TEXTURE_2D, C, S, p.width, p.height), E && i.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, p.width, p.height, m, M, p.data)) : i.texImage2D(t.TEXTURE_2D, 0, S, p.width, p.height, 0, m, M, p.data);
                                else if (a.isCompressedTexture)
                                    if (a.isCompressedArrayTexture) {
                                        A && T && i.texStorage3D(t.TEXTURE_2D_ARRAY, C, S, w[0].width, w[0].height, p.depth);
                                        for (let e = 0, n = w.length; e < n; e++)
                                            if (b = w[e], a.format !== ft)
                                                if (null !== m)
                                                    if (A) {
                                                        if (E)
                                                            if (a.layerUpdates.size > 0) {
                                                                const n = To(b.width, b.height, a.format, a.type);
                                                                for (const r of a.layerUpdates) {
                                                                    const s = b.data.subarray(r * n / b.data.BYTES_PER_ELEMENT, (r + 1) * n / b.data.BYTES_PER_ELEMENT);
                                                                    i.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, r, b.width, b.height, 1, m, s, 0, 0)
                                                                }
                                                                a.clearLayerUpdates()
                                                            } else i.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, b.width, b.height, p.depth, m, b.data, 0, 0)
                                                    } else i.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, S, b.width, b.height, p.depth, 0, b.data, 0, 0);
                                        else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                        else A ? E && i.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, b.width, b.height, p.depth, m, M, b.data) : i.texImage3D(t.TEXTURE_2D_ARRAY, e, S, b.width, b.height, p.depth, 0, m, M, b.data)
                                    } else {
                                        A && T && i.texStorage2D(t.TEXTURE_2D, C, S, w[0].width, w[0].height);
                                        for (let e = 0, n = w.length; e < n; e++) b = w[e], a.format !== ft ? null !== m ? A ? E && i.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, b.width, b.height, m, b.data) : i.compressedTexImage2D(t.TEXTURE_2D, e, S, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : A ? E && i.texSubImage2D(t.TEXTURE_2D, e, 0, 0, b.width, b.height, m, M, b.data) : i.texImage2D(t.TEXTURE_2D, e, S, b.width, b.height, 0, m, M, b.data)
                                    }
                                else if (a.isDataArrayTexture)
                                    if (A) {
                                        if (T && i.texStorage3D(t.TEXTURE_2D_ARRAY, C, S, p.width, p.height, p.depth), E)
                                            if (a.layerUpdates.size > 0) {
                                                const e = To(p.width, p.height, a.format, a.type);
                                                for (const n of a.layerUpdates) {
                                                    const r = p.data.subarray(n * e / p.data.BYTES_PER_ELEMENT, (n + 1) * e / p.data.BYTES_PER_ELEMENT);
                                                    i.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, n, p.width, p.height, 1, m, M, r)
                                                }
                                                a.clearLayerUpdates()
                                            } else i.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, m, M, p.data)
                                    } else i.texImage3D(t.TEXTURE_2D_ARRAY, 0, S, p.width, p.height, p.depth, 0, m, M, p.data);
                                else if (a.isData3DTexture) A ? (T && i.texStorage3D(t.TEXTURE_3D, C, S, p.width, p.height, p.depth), E && i.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, m, M, p.data)) : i.texImage3D(t.TEXTURE_3D, 0, S, p.width, p.height, p.depth, 0, m, M, p.data);
                                else if (a.isFramebufferTexture) {
                                    if (T)
                                        if (A) i.texStorage2D(t.TEXTURE_2D, C, S, p.width, p.height);
                                        else {
                                            let e = p.width,
                                                n = p.height;
                                            for (let r = 0; r < C; r++) i.texImage2D(t.TEXTURE_2D, r, S, e, n, 0, m, M, null), e >>= 1, n >>= 1
                                        }
                                } else if (w.length > 0) {
                                    if (A && T) {
                                        const e = k(w[0]);
                                        i.texStorage2D(t.TEXTURE_2D, C, S, e.width, e.height)
                                    }
                                    for (let e = 0, n = w.length; e < n; e++) b = w[e], A ? E && i.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m, M, b) : i.texImage2D(t.TEXTURE_2D, e, S, m, M, b);
                                    a.generateMipmaps = !1
                                } else if (A) {
                                    if (T) {
                                        const e = k(p);
                                        i.texStorage2D(t.TEXTURE_2D, C, S, e.width, e.height)
                                    }
                                    E && i.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, m, M, p)
                                } else i.texImage2D(t.TEXTURE_2D, 0, S, m, M, p);
                                g(a) && v(l), u.__version = c.version, a.onUpdate && a.onUpdate(a)
                            }
                            e.__version = a.version
                        }

                        function L(e, r, a, l, h, c) {
                            const u = s.convert(a.format, a.colorSpace),
                                d = s.convert(a.type),
                                p = _(a.internalFormat, u, d, a.colorSpace);
                            if (!n.get(r).__hasExternalTextures) {
                                const e = Math.max(1, r.width >> c),
                                    n = Math.max(1, r.height >> c);
                                h === t.TEXTURE_3D || h === t.TEXTURE_2D_ARRAY ? i.texImage3D(h, c, p, e, n, r.depth, 0, u, d, null) : i.texImage2D(h, c, p, e, n, 0, u, d, null)
                            }
                            i.bindFramebuffer(t.FRAMEBUFFER, e), z(r) ? o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, l, h, n.get(a).__webglTexture, 0, B(r)) : (h === t.TEXTURE_2D || h >= t.TEXTURE_CUBE_MAP_POSITIVE_X && h <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, l, h, n.get(a).__webglTexture, c), i.bindFramebuffer(t.FRAMEBUFFER, null)
                        }

                        function U(e, i, n) {
                            if (t.bindRenderbuffer(t.RENDERBUFFER, e), i.depthBuffer) {
                                const r = i.depthTexture,
                                    s = r && r.isDepthTexture ? r.type : null,
                                    a = y(i.stencilBuffer, s),
                                    l = i.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                                    h = B(i);
                                z(i) ? o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, h, a, i.width, i.height) : n ? t.renderbufferStorageMultisample(t.RENDERBUFFER, h, a, i.width, i.height) : t.renderbufferStorage(t.RENDERBUFFER, a, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, l, t.RENDERBUFFER, e)
                            } else {
                                const e = i.textures;
                                for (let r = 0; r < e.length; r++) {
                                    const a = e[r],
                                        l = s.convert(a.format, a.colorSpace),
                                        h = s.convert(a.type),
                                        c = _(a.internalFormat, l, h, a.colorSpace),
                                        u = B(i);
                                    n && !1 === z(i) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, u, c, i.width, i.height) : z(i) ? o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, u, c, i.width, i.height) : t.renderbufferStorage(t.RENDERBUFFER, c, i.width, i.height)
                                }
                            }
                            t.bindRenderbuffer(t.RENDERBUFFER, null)
                        }

                        function N(e) {
                            const r = n.get(e),
                                s = !0 === e.isWebGLCubeRenderTarget;
                            if (r.__boundDepthTexture !== e.depthTexture) {
                                const t = e.depthTexture;
                                if (r.__depthDisposeCallback && r.__depthDisposeCallback(), t) {
                                    const e = () => {
                                        delete r.__boundDepthTexture, delete r.__depthDisposeCallback, t.removeEventListener("dispose", e)
                                    };
                                    t.addEventListener("dispose", e), r.__depthDisposeCallback = e
                                }
                                r.__boundDepthTexture = t
                            }
                            if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                                if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                                ! function(e, r) {
                                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                    if (i.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                    n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), A(r.depthTexture, 0);
                                    const s = n.get(r.depthTexture).__webglTexture,
                                        a = B(r);
                                    if (r.depthTexture.format === _t) z(r) ? o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                                    else {
                                        if (r.depthTexture.format !== yt) throw new Error("Unknown depthTexture format");
                                        z(r) ? o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
                                    }
                                }(r.__webglFramebuffer, e)
                            } else if (s) {
                                r.__webglDepthbuffer = [];
                                for (let n = 0; n < 6; n++)
                                    if (i.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[n]), void 0 === r.__webglDepthbuffer[n]) r.__webglDepthbuffer[n] = t.createRenderbuffer(), U(r.__webglDepthbuffer[n], e, !1);
                                    else {
                                        const i = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                                            s = r.__webglDepthbuffer[n];
                                        t.bindRenderbuffer(t.RENDERBUFFER, s), t.framebufferRenderbuffer(t.FRAMEBUFFER, i, t.RENDERBUFFER, s)
                                    }
                            } else if (i.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), void 0 === r.__webglDepthbuffer) r.__webglDepthbuffer = t.createRenderbuffer(), U(r.__webglDepthbuffer, e, !1);
                            else {
                                const i = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                                    n = r.__webglDepthbuffer;
                                t.bindRenderbuffer(t.RENDERBUFFER, n), t.framebufferRenderbuffer(t.FRAMEBUFFER, i, t.RENDERBUFFER, n)
                            }
                            i.bindFramebuffer(t.FRAMEBUFFER, null)
                        }
                        const D = [],
                            O = [];

                        function B(t) {
                            return Math.min(r.maxSamples, t.samples)
                        }

                        function z(t) {
                            const i = n.get(t);
                            return t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture
                        }

                        function F(t, e) {
                            const i = t.colorSpace,
                                n = t.format,
                                r = t.type;
                            return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || i !== de && i !== ce && (ri.getTransfer(i) === ge ? n === ft && r === et || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)), e
                        }

                        function k(t) {
                            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement ? (h.width = t.naturalWidth || t.width, h.height = t.naturalHeight || t.height) : "undefined" != typeof VideoFrame && t instanceof VideoFrame ? (h.width = t.displayWidth, h.height = t.displayHeight) : (h.width = t.width, h.height = t.height), h
                        }
                        this.allocateTextureUnit = function() {
                            const t = w;
                            return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures), w += 1, t
                        }, this.resetTextureUnits = function() {
                            w = 0
                        }, this.setTexture2D = A, this.setTexture2DArray = function(e, r) {
                            const s = n.get(e);
                            e.version > 0 && s.__version !== e.version ? I(s, e, r) : i.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r)
                        }, this.setTexture3D = function(e, r) {
                            const s = n.get(e);
                            e.version > 0 && s.__version !== e.version ? I(s, e, r) : i.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r)
                        }, this.setTextureCube = function(e, a) {
                            const o = n.get(e);
                            e.version > 0 && o.__version !== e.version ? function(e, a, o) {
                                if (6 !== a.image.length) return;
                                const l = P(e, a),
                                    h = a.source;
                                i.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + o);
                                const c = n.get(h);
                                if (h.version !== c.__version || !0 === l) {
                                    i.activeTexture(t.TEXTURE0 + o);
                                    const e = ri.getPrimaries(ri.workingColorSpace),
                                        n = a.colorSpace === ce ? null : ri.getPrimaries(a.colorSpace),
                                        u = a.colorSpace === ce || e === n ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                                    const d = a.isCompressedTexture || a.image[0].isCompressedTexture,
                                        p = a.image[0] && a.image[0].isDataTexture,
                                        m = [];
                                    for (let t = 0; t < 6; t++) m[t] = d || p ? p ? a.image[t].image : a.image[t] : f(a.image[t], !0, r.maxCubemapSize), m[t] = F(a, m[t]);
                                    const y = m[0],
                                        M = s.convert(a.format, a.colorSpace),
                                        b = s.convert(a.type),
                                        S = _(a.internalFormat, M, b, a.colorSpace),
                                        w = !0 !== a.isVideoTexture,
                                        A = void 0 === c.__version || !0 === l,
                                        T = h.dataReady;
                                    let E, C = x(a, y);
                                    if (R(t.TEXTURE_CUBE_MAP, a), d) {
                                        w && A && i.texStorage2D(t.TEXTURE_CUBE_MAP, C, S, y.width, y.height);
                                        for (let e = 0; e < 6; e++) {
                                            E = m[e].mipmaps;
                                            for (let n = 0; n < E.length; n++) {
                                                const r = E[n];
                                                a.format !== ft ? null !== M ? w ? T && i.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, 0, 0, r.width, r.height, M, r.data) : i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, S, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : w ? T && i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, 0, 0, r.width, r.height, M, b, r.data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n, S, r.width, r.height, 0, M, b, r.data)
                                            }
                                        }
                                    } else {
                                        if (E = a.mipmaps, w && A) {
                                            E.length > 0 && C++;
                                            const e = k(m[0]);
                                            i.texStorage2D(t.TEXTURE_CUBE_MAP, C, S, e.width, e.height)
                                        }
                                        for (let e = 0; e < 6; e++)
                                            if (p) {
                                                w ? T && i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, m[e].width, m[e].height, M, b, m[e].data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, S, m[e].width, m[e].height, 0, M, b, m[e].data);
                                                for (let n = 0; n < E.length; n++) {
                                                    const r = E[n].image[e].image;
                                                    w ? T && i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, 0, 0, r.width, r.height, M, b, r.data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, S, r.width, r.height, 0, M, b, r.data)
                                                }
                                            } else {
                                                w ? T && i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, M, b, m[e]) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, S, M, b, m[e]);
                                                for (let n = 0; n < E.length; n++) {
                                                    const r = E[n];
                                                    w ? T && i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, 0, 0, M, b, r.image[e]) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, n + 1, S, M, b, r.image[e])
                                                }
                                            }
                                    }
                                    g(a) && v(t.TEXTURE_CUBE_MAP), c.__version = h.version, a.onUpdate && a.onUpdate(a)
                                }
                                e.__version = a.version
                            }(o, e, a) : i.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture, t.TEXTURE0 + a)
                        }, this.rebindTextures = function(e, i, r) {
                            const s = n.get(e);
                            void 0 !== i && L(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== r && N(e)
                        }, this.setupRenderTarget = function(e) {
                            const r = e.texture,
                                o = n.get(e),
                                l = n.get(r);
                            e.addEventListener("dispose", b);
                            const h = e.textures,
                                c = !0 === e.isWebGLCubeRenderTarget,
                                u = h.length > 1;
                            if (u || (void 0 === l.__webglTexture && (l.__webglTexture = t.createTexture()), l.__version = r.version, a.memory.textures++), c) {
                                o.__webglFramebuffer = [];
                                for (let e = 0; e < 6; e++)
                                    if (r.mipmaps && r.mipmaps.length > 0) {
                                        o.__webglFramebuffer[e] = [];
                                        for (let i = 0; i < r.mipmaps.length; i++) o.__webglFramebuffer[e][i] = t.createFramebuffer()
                                    } else o.__webglFramebuffer[e] = t.createFramebuffer()
                            } else {
                                if (r.mipmaps && r.mipmaps.length > 0) {
                                    o.__webglFramebuffer = [];
                                    for (let e = 0; e < r.mipmaps.length; e++) o.__webglFramebuffer[e] = t.createFramebuffer()
                                } else o.__webglFramebuffer = t.createFramebuffer();
                                if (u)
                                    for (let e = 0, i = h.length; e < i; e++) {
                                        const i = n.get(h[e]);
                                        void 0 === i.__webglTexture && (i.__webglTexture = t.createTexture(), a.memory.textures++)
                                    }
                                if (e.samples > 0 && !1 === z(e)) {
                                    o.__webglMultisampledFramebuffer = t.createFramebuffer(), o.__webglColorRenderbuffer = [], i.bindFramebuffer(t.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                                    for (let i = 0; i < h.length; i++) {
                                        const n = h[i];
                                        o.__webglColorRenderbuffer[i] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, o.__webglColorRenderbuffer[i]);
                                        const r = s.convert(n.format, n.colorSpace),
                                            a = s.convert(n.type),
                                            l = _(n.internalFormat, r, a, n.colorSpace, !0 === e.isXRRenderTarget),
                                            c = B(e);
                                        t.renderbufferStorageMultisample(t.RENDERBUFFER, c, l, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + i, t.RENDERBUFFER, o.__webglColorRenderbuffer[i])
                                    }
                                    t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (o.__webglDepthRenderbuffer = t.createRenderbuffer(), U(o.__webglDepthRenderbuffer, e, !0)), i.bindFramebuffer(t.FRAMEBUFFER, null)
                                }
                            }
                            if (c) {
                                i.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture), R(t.TEXTURE_CUBE_MAP, r);
                                for (let i = 0; i < 6; i++)
                                    if (r.mipmaps && r.mipmaps.length > 0)
                                        for (let n = 0; n < r.mipmaps.length; n++) L(o.__webglFramebuffer[i][n], e, r, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + i, n);
                                    else L(o.__webglFramebuffer[i], e, r, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
                                g(r) && v(t.TEXTURE_CUBE_MAP), i.unbindTexture()
                            } else if (u) {
                                for (let r = 0, s = h.length; r < s; r++) {
                                    const s = h[r],
                                        a = n.get(s);
                                    i.bindTexture(t.TEXTURE_2D, a.__webglTexture), R(t.TEXTURE_2D, s), L(o.__webglFramebuffer, e, s, t.COLOR_ATTACHMENT0 + r, t.TEXTURE_2D, 0), g(s) && v(t.TEXTURE_2D)
                                }
                                i.unbindTexture()
                            } else {
                                let n = t.TEXTURE_2D;
                                if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (n = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY), i.bindTexture(n, l.__webglTexture), R(n, r), r.mipmaps && r.mipmaps.length > 0)
                                    for (let i = 0; i < r.mipmaps.length; i++) L(o.__webglFramebuffer[i], e, r, t.COLOR_ATTACHMENT0, n, i);
                                else L(o.__webglFramebuffer, e, r, t.COLOR_ATTACHMENT0, n, 0);
                                g(r) && v(n), i.unbindTexture()
                            }
                            e.depthBuffer && N(e)
                        }, this.updateRenderTargetMipmap = function(e) {
                            const r = e.textures;
                            for (let s = 0, a = r.length; s < a; s++) {
                                const a = r[s];
                                if (g(a)) {
                                    const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                                        s = n.get(a).__webglTexture;
                                    i.bindTexture(r, s), v(r), i.unbindTexture()
                                }
                            }
                        }, this.updateMultisampleRenderTarget = function(e) {
                            if (e.samples > 0)
                                if (!1 === z(e)) {
                                    const r = e.textures,
                                        s = e.width,
                                        a = e.height;
                                    let o = t.COLOR_BUFFER_BIT;
                                    const h = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                                        c = n.get(e),
                                        u = r.length > 1;
                                    if (u)
                                        for (let e = 0; e < r.length; e++) i.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), i.bindFramebuffer(t.FRAMEBUFFER, c.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                                    i.bindFramebuffer(t.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), i.bindFramebuffer(t.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
                                    for (let i = 0; i < r.length; i++) {
                                        if (e.resolveDepthBuffer && (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && e.resolveStencilBuffer && (o |= t.STENCIL_BUFFER_BIT)), u) {
                                            t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, c.__webglColorRenderbuffer[i]);
                                            const e = n.get(r[i]).__webglTexture;
                                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                                        }
                                        t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST), !0 === l && (D.length = 0, O.length = 0, D.push(t.COLOR_ATTACHMENT0 + i), e.depthBuffer && !1 === e.resolveDepthBuffer && (D.push(h), O.push(h), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, O)), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, D))
                                    }
                                    if (i.bindFramebuffer(t.READ_FRAMEBUFFER, null), i.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), u)
                                        for (let e = 0; e < r.length; e++) {
                                            i.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, c.__webglColorRenderbuffer[e]);
                                            const s = n.get(r[e]).__webglTexture;
                                            i.bindFramebuffer(t.FRAMEBUFFER, c.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, s, 0)
                                        }
                                    i.bindFramebuffer(t.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                                } else if (e.depthBuffer && !1 === e.resolveDepthBuffer && l) {
                                const i = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [i])
                            }
                        }, this.setupDepthRenderbuffer = N, this.setupFrameBufferTexture = L, this.useMultisampledRTT = z
                    }

                    function Ro(t, e) {
                        return {
                            convert: function(i, n = "") {
                                let r;
                                const s = ri.getTransfer(n);
                                if (i === et) return t.UNSIGNED_BYTE;
                                if (i === ht) return t.UNSIGNED_SHORT_4_4_4_4;
                                if (i === ct) return t.UNSIGNED_SHORT_5_5_5_1;
                                if (i === dt) return t.UNSIGNED_INT_5_9_9_9_REV;
                                if (i === it) return t.BYTE;
                                if (i === nt) return t.SHORT;
                                if (i === rt) return t.UNSIGNED_SHORT;
                                if (i === st) return t.INT;
                                if (i === at) return t.UNSIGNED_INT;
                                if (i === ot) return t.FLOAT;
                                if (i === lt) return t.HALF_FLOAT;
                                if (i === pt) return t.ALPHA;
                                if (i === mt) return t.RGB;
                                if (i === ft) return t.RGBA;
                                if (i === gt) return t.LUMINANCE;
                                if (i === vt) return t.LUMINANCE_ALPHA;
                                if (i === _t) return t.DEPTH_COMPONENT;
                                if (i === yt) return t.DEPTH_STENCIL;
                                if (i === xt) return t.RED;
                                if (i === Mt) return t.RED_INTEGER;
                                if (i === bt) return t.RG;
                                if (i === St) return t.RG_INTEGER;
                                if (i === wt) return t.RGBA_INTEGER;
                                if (i === At || i === Tt || i === Et || i === Ct)
                                    if (s === ge) {
                                        if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
                                        if (i === At) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                        if (i === Tt) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                        if (i === Et) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                        if (i === Ct) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                    } else {
                                        if (r = e.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                                        if (i === At) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                        if (i === Tt) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                        if (i === Et) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                        if (i === Ct) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                                    } if (i === Rt || i === Pt || i === It || i === Lt) {
                                    if (r = e.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                                    if (i === Rt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                    if (i === Pt) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                    if (i === It) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                    if (i === Lt) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                                }
                                if (i === Ut || i === Nt || i === Dt) {
                                    if (r = e.get("WEBGL_compressed_texture_etc"), null === r) return null;
                                    if (i === Ut || i === Nt) return s === ge ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                                    if (i === Dt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                                }
                                if (i === Ot || i === Bt || i === zt || i === Ft || i === kt || i === Vt || i === Ht || i === Gt || i === Wt || i === jt || i === Xt || i === qt || i === Yt || i === Jt) {
                                    if (r = e.get("WEBGL_compressed_texture_astc"), null === r) return null;
                                    if (i === Ot) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                    if (i === Bt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                    if (i === zt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                    if (i === Ft) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                    if (i === kt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                    if (i === Vt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                    if (i === Ht) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                    if (i === Gt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                    if (i === Wt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                    if (i === jt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                    if (i === Xt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                    if (i === qt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                    if (i === Yt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                    if (i === Jt) return s === ge ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                                }
                                if (i === Zt || i === Kt || i === Qt) {
                                    if (r = e.get("EXT_texture_compression_bptc"), null === r) return null;
                                    if (i === Zt) return s === ge ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                    if (i === Kt) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                    if (i === Qt) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                                }
                                if (i === $t || i === te || i === ee || i === ie) {
                                    if (r = e.get("EXT_texture_compression_rgtc"), null === r) return null;
                                    if (i === Zt) return r.COMPRESSED_RED_RGTC1_EXT;
                                    if (i === te) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                    if (i === ee) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                    if (i === ie) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                                }
                                return i === ut ? t.UNSIGNED_INT_24_8 : void 0 !== t[i] ? t[i] : null
                            }
                        }
                    }
                    class Po extends Fr {
                        constructor(t = []) {
                            super(), this.isArrayCamera = !0, this.cameras = t
                        }
                    }
                    class Io extends wn {
                        constructor() {
                            super(), this.isGroup = !0, this.type = "Group"
                        }
                    }
                    const Lo = {
                        type: "move"
                    };
                    class Uo {
                        constructor() {
                            this._targetRay = null, this._grip = null, this._hand = null
                        }
                        getHandSpace() {
                            return null === this._hand && (this._hand = new Io, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                                pinching: !1
                            }), this._hand
                        }
                        getTargetRaySpace() {
                            return null === this._targetRay && (this._targetRay = new Io, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new xi, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new xi), this._targetRay
                        }
                        getGripSpace() {
                            return null === this._grip && (this._grip = new Io, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new xi, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new xi), this._grip
                        }
                        dispatchEvent(t) {
                            return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                        }
                        connect(t) {
                            if (t && t.hand) {
                                const e = this._hand;
                                if (e)
                                    for (const i of t.hand.values()) this._getHandJoint(e, i)
                            }
                            return this.dispatchEvent({
                                type: "connected",
                                data: t
                            }), this
                        }
                        disconnect(t) {
                            return this.dispatchEvent({
                                type: "disconnected",
                                data: t
                            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                        }
                        update(t, e, i) {
                            let n = null,
                                r = null,
                                s = null;
                            const a = this._targetRay,
                                o = this._grip,
                                l = this._hand;
                            if (t && "visible-blurred" !== e.session.visibilityState) {
                                if (l && t.hand) {
                                    s = !0;
                                    for (const n of t.hand.values()) {
                                        const t = e.getJointPose(n, i),
                                            r = this._getHandJoint(l, n);
                                        null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = t.radius), r.visible = null !== t
                                    }
                                    const n = l.joints["index-finger-tip"],
                                        r = l.joints["thumb-tip"],
                                        a = n.position.distanceTo(r.position),
                                        o = .02,
                                        h = .005;
                                    l.inputState.pinching && a > o + h ? (l.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: t.handedness,
                                        target: this
                                    })) : !l.inputState.pinching && a <= o - h && (l.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: t.handedness,
                                        target: this
                                    }))
                                } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                                null !== a && (n = e.getPose(t.targetRaySpace, i), null === n && null !== r && (n = r), null !== n && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Lo)))
                            }
                            return null !== a && (a.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                        }
                        _getHandJoint(t, e) {
                            if (void 0 === t.joints[e.jointName]) {
                                const i = new Io;
                                i.matrixAutoUpdate = !1, i.visible = !1, t.joints[e.jointName] = i, t.add(i)
                            }
                            return t.joints[e.jointName]
                        }
                    }
                    class No {
                        constructor() {
                            this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
                        }
                        init(t, e, i) {
                            if (null === this.texture) {
                                const n = new pi;
                                t.properties.get(n).__webglTexture = e.texture, e.depthNear == i.depthNear && e.depthFar == i.depthFar || (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = n
                            }
                        }
                        getMesh(t) {
                            if (null !== this.texture && null === this.mesh) {
                                const e = t.cameras[0].viewport,
                                    i = new Nr({
                                        vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                        fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                        uniforms: {
                                            depthColor: {
                                                value: this.texture
                                            },
                                            depthWidth: {
                                                value: e.z
                                            },
                                            depthHeight: {
                                                value: e.w
                                            }
                                        }
                                    });
                                this.mesh = new Er(new $r(20, 20), i)
                            }
                            return this.mesh
                        }
                        reset() {
                            this.texture = null, this.mesh = null
                        }
                        getDepthTexture() {
                            return this.texture
                        }
                    }
                    class Do extends Le {
                        constructor(t, e) {
                            super();
                            const i = this;
                            let n = null,
                                r = 1,
                                s = null,
                                a = "local-floor",
                                o = 1,
                                l = null,
                                h = null,
                                c = null,
                                u = null,
                                d = null,
                                p = null;
                            const m = new No,
                                f = e.getContextAttributes();
                            let g = null,
                                v = null;
                            const _ = [],
                                y = [],
                                x = new We;
                            let M = null;
                            const b = new Fr;
                            b.layers.enable(1), b.viewport = new mi;
                            const S = new Fr;
                            S.layers.enable(2), S.viewport = new mi;
                            const w = [b, S],
                                A = new Po;
                            A.layers.enable(1), A.layers.enable(2);
                            let T = null,
                                E = null;

                            function C(t) {
                                const e = y.indexOf(t.inputSource);
                                if (-1 === e) return;
                                const i = _[e];
                                void 0 !== i && (i.update(t.inputSource, t.frame, l || s), i.dispatchEvent({
                                    type: t.type,
                                    data: t.inputSource
                                }))
                            }

                            function R() {
                                n.removeEventListener("select", C), n.removeEventListener("selectstart", C), n.removeEventListener("selectend", C), n.removeEventListener("squeeze", C), n.removeEventListener("squeezestart", C), n.removeEventListener("squeezeend", C), n.removeEventListener("end", R), n.removeEventListener("inputsourceschange", P);
                                for (let t = 0; t < _.length; t++) {
                                    const e = y[t];
                                    null !== e && (y[t] = null, _[t].disconnect(e))
                                }
                                T = null, E = null, m.reset(), t.setRenderTarget(g), d = null, u = null, c = null, n = null, v = null, D.stop(), i.isPresenting = !1, t.setPixelRatio(M), t.setSize(x.width, x.height, !1), i.dispatchEvent({
                                    type: "sessionend"
                                })
                            }

                            function P(t) {
                                for (let e = 0; e < t.removed.length; e++) {
                                    const i = t.removed[e],
                                        n = y.indexOf(i);
                                    n >= 0 && (y[n] = null, _[n].disconnect(i))
                                }
                                for (let e = 0; e < t.added.length; e++) {
                                    const i = t.added[e];
                                    let n = y.indexOf(i);
                                    if (-1 === n) {
                                        for (let t = 0; t < _.length; t++) {
                                            if (t >= y.length) {
                                                y.push(i), n = t;
                                                break
                                            }
                                            if (null === y[t]) {
                                                y[t] = i, n = t;
                                                break
                                            }
                                        }
                                        if (-1 === n) break
                                    }
                                    const r = _[n];
                                    r && r.connect(i)
                                }
                            }
                            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                                let e = _[t];
                                return void 0 === e && (e = new Uo, _[t] = e), e.getTargetRaySpace()
                            }, this.getControllerGrip = function(t) {
                                let e = _[t];
                                return void 0 === e && (e = new Uo, _[t] = e), e.getGripSpace()
                            }, this.getHand = function(t) {
                                let e = _[t];
                                return void 0 === e && (e = new Uo, _[t] = e), e.getHandSpace()
                            }, this.setFramebufferScaleFactor = function(t) {
                                r = t, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                            }, this.setReferenceSpaceType = function(t) {
                                a = t, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                            }, this.getReferenceSpace = function() {
                                return l || s
                            }, this.setReferenceSpace = function(t) {
                                l = t
                            }, this.getBaseLayer = function() {
                                return null !== u ? u : d
                            }, this.getBinding = function() {
                                return c
                            }, this.getFrame = function() {
                                return p
                            }, this.getSession = function() {
                                return n
                            }, this.setSession = async function(h) {
                                if (n = h, null !== n) {
                                    if (g = t.getRenderTarget(), n.addEventListener("select", C), n.addEventListener("selectstart", C), n.addEventListener("selectend", C), n.addEventListener("squeeze", C), n.addEventListener("squeezestart", C), n.addEventListener("squeezeend", C), n.addEventListener("end", R), n.addEventListener("inputsourceschange", P), !0 !== f.xrCompatible && await e.makeXRCompatible(), M = t.getPixelRatio(), t.getSize(x), void 0 === n.renderState.layers) {
                                        const i = {
                                            antialias: f.antialias,
                                            alpha: !0,
                                            depth: f.depth,
                                            stencil: f.stencil,
                                            framebufferScaleFactor: r
                                        };
                                        d = new XRWebGLLayer(n, e, i), n.updateRenderState({
                                            baseLayer: d
                                        }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), v = new gi(d.framebufferWidth, d.framebufferHeight, {
                                            format: ft,
                                            type: et,
                                            colorSpace: t.outputColorSpace,
                                            stencilBuffer: f.stencil
                                        })
                                    } else {
                                        let i = null,
                                            s = null,
                                            a = null;
                                        f.depth && (a = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, i = f.stencil ? yt : _t, s = f.stencil ? ut : at);
                                        const o = {
                                            colorFormat: e.RGBA8,
                                            depthFormat: a,
                                            scaleFactor: r
                                        };
                                        c = new XRWebGLBinding(n, e), u = c.createProjectionLayer(o), n.updateRenderState({
                                            layers: [u]
                                        }), t.setPixelRatio(1), t.setSize(u.textureWidth, u.textureHeight, !1), v = new gi(u.textureWidth, u.textureHeight, {
                                            format: ft,
                                            type: et,
                                            depthTexture: new Ds(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, i),
                                            stencilBuffer: f.stencil,
                                            colorSpace: t.outputColorSpace,
                                            samples: f.antialias ? 4 : 0,
                                            resolveDepthBuffer: !1 === u.ignoreDepthValues
                                        })
                                    }
                                    v.isXRRenderTarget = !0, this.setFoveation(o), l = null, s = await n.requestReferenceSpace(a), D.setContext(n), D.start(), i.isPresenting = !0, i.dispatchEvent({
                                        type: "sessionstart"
                                    })
                                }
                            }, this.getEnvironmentBlendMode = function() {
                                if (null !== n) return n.environmentBlendMode
                            }, this.getDepthTexture = function() {
                                return m.getDepthTexture()
                            };
                            const I = new xi,
                                L = new xi;

                            function U(t, e) {
                                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                            }
                            this.updateCamera = function(t) {
                                if (null === n) return;
                                let e = t.near,
                                    i = t.far;
                                null !== m.texture && (m.depthNear > 0 && (e = m.depthNear), m.depthFar > 0 && (i = m.depthFar)), A.near = S.near = b.near = e, A.far = S.far = b.far = i, T === A.near && E === A.far || (n.updateRenderState({
                                    depthNear: A.near,
                                    depthFar: A.far
                                }), T = A.near, E = A.far);
                                const r = t.parent,
                                    s = A.cameras;
                                U(A, r);
                                for (let t = 0; t < s.length; t++) U(s[t], r);
                                2 === s.length ? function(t, e, i) {
                                        I.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(i.matrixWorld);
                                        const n = I.distanceTo(L),
                                            r = e.projectionMatrix.elements,
                                            s = i.projectionMatrix.elements,
                                            a = r[14] / (r[10] - 1),
                                            o = r[14] / (r[10] + 1),
                                            l = (r[9] + 1) / r[5],
                                            h = (r[9] - 1) / r[5],
                                            c = (r[8] - 1) / r[0],
                                            u = (s[8] + 1) / s[0],
                                            d = a * c,
                                            p = a * u,
                                            m = n / (-c + u),
                                            f = m * -c;
                                        if (e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert(), -1 === r[10]) t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse);
                                        else {
                                            const e = a + m,
                                                i = o + m,
                                                r = d - f,
                                                s = p + (n - f),
                                                c = l * o / i * e,
                                                u = h * o / i * e;
                                            t.projectionMatrix.makePerspective(r, s, c, u, e, i), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                                        }
                                    }(A, b, S) : A.projectionMatrix.copy(b.projectionMatrix),
                                    function(t, e, i) {
                                        null === i ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(i.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld)), t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0), t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * Oe * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                                    }(t, A, r)
                            }, this.getCamera = function() {
                                return A
                            }, this.getFoveation = function() {
                                if (null !== u || null !== d) return o
                            }, this.setFoveation = function(t) {
                                o = t, null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                            }, this.hasDepthSensing = function() {
                                return null !== m.texture
                            }, this.getDepthSensingMesh = function() {
                                return m.getMesh(A)
                            };
                            let N = null;
                            const D = new Kr;
                            D.setAnimationLoop((function(e, r) {
                                if (h = r.getViewerPose(l || s), p = r, null !== h) {
                                    const e = h.views;
                                    null !== d && (t.setRenderTargetFramebuffer(v, d.framebuffer), t.setRenderTarget(v));
                                    let i = !1;
                                    e.length !== A.cameras.length && (A.cameras.length = 0, i = !0);
                                    for (let n = 0; n < e.length; n++) {
                                        const r = e[n];
                                        let s = null;
                                        if (null !== d) s = d.getViewport(r);
                                        else {
                                            const e = c.getViewSubImage(u, r);
                                            s = e.viewport, 0 === n && (t.setRenderTargetTextures(v, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(v))
                                        }
                                        let a = w[n];
                                        void 0 === a && (a = new Fr, a.layers.enable(n), a.viewport = new mi, w[n] = a), a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(r.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(s.x, s.y, s.width, s.height), 0 === n && (A.matrix.copy(a.matrix), A.matrix.decompose(A.position, A.quaternion, A.scale)), !0 === i && A.cameras.push(a)
                                    }
                                    const r = n.enabledFeatures;
                                    if (r && r.includes("depth-sensing")) {
                                        const i = c.getDepthInformation(e[0]);
                                        i && i.isValid && i.texture && m.init(t, i, n.renderState)
                                    }
                                }
                                for (let t = 0; t < _.length; t++) {
                                    const e = y[t],
                                        i = _[t];
                                    null !== e && void 0 !== i && i.update(e, r, l || s)
                                }
                                N && N(e, r), r.detectedPlanes && i.dispatchEvent({
                                    type: "planesdetected",
                                    data: r
                                }), p = null
                            })), this.setAnimationLoop = function(t) {
                                N = t
                            }, this.dispose = function() {}
                        }
                    }
                    const Oo = new on,
                        Bo = new Zi;

                    function zo(t, e) {
                        function i(t, e) {
                            !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
                        }

                        function n(t, n) {
                            t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map, i(n.map, t.mapTransform)), n.alphaMap && (t.alphaMap.value = n.alphaMap, i(n.alphaMap, t.alphaMapTransform)), n.bumpMap && (t.bumpMap.value = n.bumpMap, i(n.bumpMap, t.bumpMapTransform), t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, i(n.normalMap, t.normalMapTransform), t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, i(n.displacementMap, t.displacementMapTransform), t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap, i(n.emissiveMap, t.emissiveMapTransform)), n.specularMap && (t.specularMap.value = n.specularMap, i(n.specularMap, t.specularMapTransform)), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
                            const r = e.get(n),
                                s = r.envMap,
                                a = r.envMapRotation;
                            s && (t.envMap.value = s, Oo.copy(a), Oo.x *= -1, Oo.y *= -1, Oo.z *= -1, s.isCubeTexture && !1 === s.isRenderTargetTexture && (Oo.y *= -1, Oo.z *= -1), t.envMapRotation.value.setFromMatrix4(Bo.makeRotationFromEuler(Oo)), t.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity, i(n.lightMap, t.lightMapTransform)), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity, i(n.aoMap, t.aoMapTransform))
                        }
                        return {
                            refreshFogUniforms: function(e, i) {
                                i.color.getRGB(e.fogColor.value, Lr(t)), i.isFog ? (e.fogNear.value = i.near, e.fogFar.value = i.far) : i.isFogExp2 && (e.fogDensity.value = i.density)
                            },
                            refreshMaterialUniforms: function(t, r, s, a, o) {
                                r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(t, r) : r.isMeshToonMaterial ? (n(t, r), function(t, e) {
                                    e.gradientMap && (t.gradientMap.value = e.gradientMap)
                                }(t, r)) : r.isMeshPhongMaterial ? (n(t, r), function(t, e) {
                                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                                }(t, r)) : r.isMeshStandardMaterial ? (n(t, r), function(t, e) {
                                    t.metalness.value = e.metalness, e.metalnessMap && (t.metalnessMap.value = e.metalnessMap, i(e.metalnessMap, t.metalnessMapTransform)), t.roughness.value = e.roughness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap, i(e.roughnessMap, t.roughnessMapTransform)), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                                }(t, r), r.isMeshPhysicalMaterial && function(t, e, n) {
                                    t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, i(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, i(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, i(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, i(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, i(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), 1 === e.side && t.clearcoatNormalScale.value.negate())), e.dispersion > 0 && (t.dispersion.value = e.dispersion), e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, i(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, i(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, i(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, i(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)), e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, i(e.anisotropyMap, t.anisotropyMapTransform))), t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, i(e.specularColorMap, t.specularColorMapTransform)), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, i(e.specularIntensityMap, t.specularIntensityMapTransform))
                                }(t, r, o)) : r.isMeshMatcapMaterial ? (n(t, r), function(t, e) {
                                    e.matcap && (t.matcap.value = e.matcap)
                                }(t, r)) : r.isMeshDepthMaterial ? n(t, r) : r.isMeshDistanceMaterial ? (n(t, r), function(t, i) {
                                    const n = e.get(i).light;
                                    t.referencePosition.value.setFromMatrixPosition(n.matrixWorld), t.nearDistance.value = n.shadow.camera.near, t.farDistance.value = n.shadow.camera.far
                                }(t, r)) : r.isMeshNormalMaterial ? n(t, r) : r.isLineBasicMaterial ? (function(t, e) {
                                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, i(e.map, t.mapTransform))
                                }(t, r), r.isLineDashedMaterial && function(t, e) {
                                    t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                                }(t, r)) : r.isPointsMaterial ? function(t, e, n, r) {
                                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map, i(e.map, t.uvTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, i(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                                }(t, r, s, a) : r.isSpriteMaterial ? function(t, e) {
                                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, i(e.map, t.mapTransform)), e.alphaMap && (t.alphaMap.value = e.alphaMap, i(e.alphaMap, t.alphaMapTransform)), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                                }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                            }
                        }
                    }

                    function Fo(t, e, i, n) {
                        let r = {},
                            s = {},
                            a = [];
                        const o = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);

                        function l(t, e, i, n) {
                            const r = t.value,
                                s = e + "_" + i;
                            if (void 0 === n[s]) return n[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0;
                            {
                                const t = n[s];
                                if ("number" == typeof r || "boolean" == typeof r) {
                                    if (t !== r) return n[s] = r, !0
                                } else if (!1 === t.equals(r)) return t.copy(r), !0
                            }
                            return !1
                        }

                        function h(t) {
                            const e = {
                                boundary: 0,
                                storage: 0
                            };
                            return "number" == typeof t || "boolean" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e
                        }

                        function c(e) {
                            const i = e.target;
                            i.removeEventListener("dispose", c);
                            const n = a.indexOf(i.__bindingPointIndex);
                            a.splice(n, 1), t.deleteBuffer(r[i.id]), delete r[i.id], delete s[i.id]
                        }
                        return {
                            bind: function(t, e) {
                                const i = e.program;
                                n.uniformBlockBinding(t, i)
                            },
                            update: function(i, u) {
                                let d = r[i.id];
                                void 0 === d && (function(t) {
                                    const e = t.uniforms;
                                    let i = 0;
                                    for (let t = 0, n = e.length; t < n; t++) {
                                        const n = Array.isArray(e[t]) ? e[t] : [e[t]];
                                        for (let t = 0, e = n.length; t < e; t++) {
                                            const e = n[t],
                                                r = Array.isArray(e.value) ? e.value : [e.value];
                                            for (let t = 0, n = r.length; t < n; t++) {
                                                const n = h(r[t]),
                                                    s = i % 16,
                                                    a = s % n.boundary,
                                                    o = s + a;
                                                i += a, 0 !== o && 16 - o < n.storage && (i += 16 - o), e.__data = new Float32Array(n.storage / Float32Array.BYTES_PER_ELEMENT), e.__offset = i, i += n.storage
                                            }
                                        }
                                    }
                                    const n = i % 16;//16
                                    n > 0 && (i += 16 - n), t.__size = i, t.__cache = {}
                                }(i), d = function(e) {
                                    const i = function() {
                                        for (let t = 0; t < o; t++)
                                            if (-1 === a.indexOf(t)) return a.push(t), t;
                                        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                                    }();
                                    e.__bindingPointIndex = i;
                                    const n = t.createBuffer(),
                                        r = e.__size,
                                        s = e.usage;
                                    return t.bindBuffer(t.UNIFORM_BUFFER, n), t.bufferData(t.UNIFORM_BUFFER, r, s), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, i, n), n
                                }(i), r[i.id] = d, i.addEventListener("dispose", c));
                                const p = u.program;
                                n.updateUBOMapping(i, p);
                                const m = e.render.frame;
                                s[i.id] !== m && (function(e) {
                                    const i = r[e.id],
                                        n = e.uniforms,
                                        s = e.__cache;
                                    t.bindBuffer(t.UNIFORM_BUFFER, i);
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = Array.isArray(n[e]) ? n[e] : [n[e]];
                                        for (let n = 0, r = i.length; n < r; n++) {
                                            const r = i[n];
                                            if (!0 === l(r, e, n, s)) {
                                                const e = r.__offset,
                                                    i = Array.isArray(r.value) ? r.value : [r.value];
                                                let n = 0;
                                                for (let s = 0; s < i.length; s++) {
                                                    const a = i[s],
                                                        o = h(a);
                                                    "number" == typeof a || "boolean" == typeof a ? (r.__data[0] = a, t.bufferSubData(t.UNIFORM_BUFFER, e + n, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0], r.__data[1] = a.elements[1], r.__data[2] = a.elements[2], r.__data[3] = 0, r.__data[4] = a.elements[3], r.__data[5] = a.elements[4], r.__data[6] = a.elements[5], r.__data[7] = 0, r.__data[8] = a.elements[6], r.__data[9] = a.elements[7], r.__data[10] = a.elements[8], r.__data[11] = 0) : (a.toArray(r.__data, n), n += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                                }
                                                t.bufferSubData(t.UNIFORM_BUFFER, e, r.__data)
                                            }
                                        }
                                    }
                                    t.bindBuffer(t.UNIFORM_BUFFER, null)
                                }(i), s[i.id] = m)
                            },
                            dispose: function() {
                                for (const e in r) t.deleteBuffer(r[e]);
                                a = [], r = {}, s = {}
                            }
                        }
                    }
                    class ko {
                        constructor(t, e = 25e-5) {
                            this.isFogExp2 = !0, this.name = "", this.color = new kn(t), this.density = e
                        }
                        clone() {
                            return new ko(this.color, this.density)
                        }
                        toJSON() {
                            return {
                                type: "FogExp2",
                                name: this.name,
                                color: this.color.getHex(),
                                density: this.density
                            }
                        }
                    }
                    class Vo {
                        constructor(t, e = 1, i = 1e3) {
                            this.isFog = !0, this.name = "", this.color = new kn(t), this.near = e, this.far = i
                        }
                        clone() {
                            return new Vo(this.color, this.near, this.far)
                        }
                        toJSON() {
                            return {
                                type: "Fog",
                                name: this.name,
                                color: this.color.getHex(),
                                near: this.near,
                                far: this.far
                            }
                        }
                    }
                    class Ho extends wn {
                        constructor() {
                            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new on, this.environmentIntensity = 1, this.environmentRotation = new on, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                                detail: this
                            }))
                        }
                        copy(t, e) {
                            return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e
                        }
                    }
                    class Go {
                        constructor(t, e) {
                            this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Ce, this._updateRange = {
                                offset: 0,
                                count: -1
                            }, this.updateRanges = [], this.version = 0, this.uuid = Be()
                        }
                        onUploadCallback() {}
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        get updateRange() {
                            return $e("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
                        }
                        setUsage(t) {
                            return this.usage = t, this
                        }
                        addUpdateRange(t, e) {
                            this.updateRanges.push({
                                start: t,
                                count: e
                            })
                        }
                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }
                        copy(t) {
                            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                        }
                        copyAt(t, e, i) {
                            t *= this.stride, i *= e.stride;
                            for (let n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                            return this
                        }
                        set(t, e = 0) {
                            return this.array.set(t, e), this
                        }
                        clone(t) {
                            void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Be()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                                i = new this.constructor(e, this.stride);
                            return i.setUsage(this.usage), i
                        }
                        onUpload(t) {
                            return this.onUploadCallback = t, this
                        }
                        toJSON(t) {
                            return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Be()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                                uuid: this.uuid,
                                buffer: this.array.buffer._uuid,
                                type: this.array.constructor.name,
                                stride: this.stride
                            }
                        }
                    }
                    const Wo = new xi;
                    class jo {
                        constructor(t, e, i, n = !1) {
                            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = n
                        }
                        get count() {
                            return this.data.count
                        }
                        get array() {
                            return this.data.array
                        }
                        set needsUpdate(t) {
                            this.data.needsUpdate = t
                        }
                        applyMatrix4(t) {
                            for (let e = 0, i = this.data.count; e < i; e++) Wo.fromBufferAttribute(this, e), Wo.applyMatrix4(t), this.setXYZ(e, Wo.x, Wo.y, Wo.z);
                            return this
                        }
                        applyNormalMatrix(t) {
                            for (let e = 0, i = this.count; e < i; e++) Wo.fromBufferAttribute(this, e), Wo.applyNormalMatrix(t), this.setXYZ(e, Wo.x, Wo.y, Wo.z);
                            return this
                        }
                        transformDirection(t) {
                            for (let e = 0, i = this.count; e < i; e++) Wo.fromBufferAttribute(this, e), Wo.transformDirection(t), this.setXYZ(e, Wo.x, Wo.y, Wo.z);
                            return this
                        }
                        getComponent(t, e) {
                            let i = this.array[t * this.data.stride + this.offset + e];
                            return this.normalized && (i = Ve(i, this.array)), i
                        }
                        setComponent(t, e, i) {
                            return this.normalized && (i = He(i, this.array)), this.data.array[t * this.data.stride + this.offset + e] = i, this
                        }
                        setX(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
                        }
                        setY(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
                        }
                        setZ(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
                        }
                        setW(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
                        }
                        getX(t) {
                            let e = this.data.array[t * this.data.stride + this.offset];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        getY(t) {
                            let e = this.data.array[t * this.data.stride + this.offset + 1];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        getZ(t) {
                            let e = this.data.array[t * this.data.stride + this.offset + 2];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        getW(t) {
                            let e = this.data.array[t * this.data.stride + this.offset + 3];
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setXY(t, e, i) {
                            return t = t * this.data.stride + this.offset, this.normalized && (e = He(e, this.array), i = He(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
                        }
                        setXYZ(t, e, i, n) {
                            return t = t * this.data.stride + this.offset, this.normalized && (e = He(e, this.array), i = He(i, this.array), n = He(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
                        }
                        setXYZW(t, e, i, n, r) {
                            return t = t * this.data.stride + this.offset, this.normalized && (e = He(e, this.array), i = He(i, this.array), n = He(n, this.array), r = He(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
                        }
                        clone(t) {
                            if (void 0 === t) {
                                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                                const t = [];
                                for (let e = 0; e < this.count; e++) {
                                    const i = e * this.data.stride + this.offset;
                                    for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
                                }
                                return new Qn(new this.array.constructor(t), this.itemSize, this.normalized)
                            }
                            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new jo(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                        }
                        toJSON(t) {
                            if (void 0 === t) {
                                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                                const t = [];
                                for (let e = 0; e < this.count; e++) {
                                    const i = e * this.data.stride + this.offset;
                                    for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
                                }
                                return {
                                    itemSize: this.itemSize,
                                    type: this.array.constructor.name,
                                    array: t,
                                    normalized: this.normalized
                                }
                            }
                            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                        }
                    }
                    class Xo extends Gn {
                        constructor(t) {
                            super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new kn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
                        }
                    }
                    let qo;
                    const Yo = new xi,
                        Jo = new xi,
                        Zo = new xi,
                        Ko = new We,
                        Qo = new We,
                        $o = new Zi,
                        tl = new xi,
                        el = new xi,
                        il = new xi,
                        nl = new We,
                        rl = new We,
                        sl = new We;
                    class al extends wn {
                        constructor(t = new Xo) {
                            if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === qo) {
                                qo = new hr;
                                const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                    e = new Go(t, 5);
                                qo.setIndex([0, 1, 2, 0, 2, 3]), qo.setAttribute("position", new jo(e, 3, 0, !1)), qo.setAttribute("uv", new jo(e, 2, 3, !1))
                            }
                            this.geometry = qo, this.material = t, this.center = new We(.5, .5)
                        }
                        raycast(t, e) {
                            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Jo.setFromMatrixScale(this.matrixWorld), $o.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Zo.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Jo.multiplyScalar(-Zo.z);
                            const i = this.material.rotation;
                            let n, r;
                            0 !== i && (r = Math.cos(i), n = Math.sin(i));
                            const s = this.center;
                            ol(tl.set(-.5, -.5, 0), Zo, s, Jo, n, r), ol(el.set(.5, -.5, 0), Zo, s, Jo, n, r), ol(il.set(.5, .5, 0), Zo, s, Jo, n, r), nl.set(0, 0), rl.set(1, 0), sl.set(1, 1);
                            let a = t.ray.intersectTriangle(tl, el, il, !1, Yo);
                            if (null === a && (ol(el.set(-.5, .5, 0), Zo, s, Jo, n, r), rl.set(0, 1), a = t.ray.intersectTriangle(tl, il, el, !1, Yo), null === a)) return;
                            const o = t.ray.origin.distanceTo(Yo);
                            o < t.near || o > t.far || e.push({
                                distance: o,
                                point: Yo.clone(),
                                uv: Dn.getInterpolation(Yo, tl, el, il, nl, rl, sl, new We),
                                face: null,
                                object: this
                            })
                        }
                        copy(t, e) {
                            return super.copy(t, e), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                        }
                    }

                    function ol(t, e, i, n, r, s) {
                        Ko.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (Qo.x = s * Ko.x - r * Ko.y, Qo.y = r * Ko.x + s * Ko.y) : Qo.copy(Ko), t.copy(e), t.x += Qo.x, t.y += Qo.y, t.applyMatrix4($o)
                    }
                    const ll = new xi,
                        hl = new xi;
                    class cl extends wn {
                        constructor() {
                            super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                                levels: {
                                    enumerable: !0,
                                    value: []
                                },
                                isLOD: {
                                    value: !0
                                }
                            }), this.autoUpdate = !0
                        }
                        copy(t) {
                            super.copy(t, !1);
                            const e = t.levels;
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                this.addLevel(i.object.clone(), i.distance, i.hysteresis)
                            }
                            return this.autoUpdate = t.autoUpdate, this
                        }
                        addLevel(t, e = 0, i = 0) {
                            e = Math.abs(e);
                            const n = this.levels;
                            let r;
                            for (r = 0; r < n.length && !(e < n[r].distance); r++);
                            return n.splice(r, 0, {
                                distance: e,
                                hysteresis: i,
                                object: t
                            }), this.add(t), this
                        }
                        getCurrentLevel() {
                            return this._currentLevel
                        }
                        getObjectForDistance(t) {
                            const e = this.levels;
                            if (e.length > 0) {
                                let i, n;
                                for (i = 1, n = e.length; i < n; i++) {
                                    let n = e[i].distance;
                                    if (e[i].object.visible && (n -= n * e[i].hysteresis), t < n) break
                                }
                                return e[i - 1].object
                            }
                            return null
                        }
                        raycast(t, e) {
                            if (this.levels.length > 0) {
                                ll.setFromMatrixPosition(this.matrixWorld);
                                const i = t.ray.origin.distanceTo(ll);
                                this.getObjectForDistance(i).raycast(t, e)
                            }
                        }
                        update(t) {
                            const e = this.levels;
                            if (e.length > 1) {
                                ll.setFromMatrixPosition(t.matrixWorld), hl.setFromMatrixPosition(this.matrixWorld);
                                const i = ll.distanceTo(hl) / t.zoom;
                                let n, r;
                                for (e[0].object.visible = !0, n = 1, r = e.length; n < r; n++) {
                                    let t = e[n].distance;
                                    if (e[n].object.visible && (t -= t * e[n].hysteresis), !(i >= t)) break;
                                    e[n - 1].object.visible = !1, e[n].object.visible = !0
                                }
                                for (this._currentLevel = n - 1; n < r; n++) e[n].object.visible = !1
                            }
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                            const i = this.levels;
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = i[t];
                                e.object.levels.push({
                                    object: n.object.uuid,
                                    distance: n.distance,
                                    hysteresis: n.hysteresis
                                })
                            }
                            return e
                        }
                    }
                    const ul = new xi,
                        dl = new mi,
                        pl = new mi,
                        ml = new xi,
                        fl = new Zi,
                        gl = new xi,
                        vl = new Vi,
                        _l = new Zi,
                        yl = new Ji;
                    class xl extends Er {
                        constructor(t, e) {
                            super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = z, this.bindMatrix = new Zi, this.bindMatrixInverse = new Zi, this.boundingBox = null, this.boundingSphere = null
                        }
                        computeBoundingBox() {
                            const t = this.geometry;
                            null === this.boundingBox && (this.boundingBox = new Si), this.boundingBox.makeEmpty();
                            const e = t.getAttribute("position");
                            for (let t = 0; t < e.count; t++) this.getVertexPosition(t, gl), this.boundingBox.expandByPoint(gl)
                        }
                        computeBoundingSphere() {
                            const t = this.geometry;
                            null === this.boundingSphere && (this.boundingSphere = new Vi), this.boundingSphere.makeEmpty();
                            const e = t.getAttribute("position");
                            for (let t = 0; t < e.count; t++) this.getVertexPosition(t, gl), this.boundingSphere.expandByPoint(gl)
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                        }
                        raycast(t, e) {
                            const i = this.material,
                                n = this.matrixWorld;
                            void 0 !== i && (null === this.boundingSphere && this.computeBoundingSphere(), vl.copy(this.boundingSphere), vl.applyMatrix4(n), !1 !== t.ray.intersectsSphere(vl) && (_l.copy(n).invert(), yl.copy(t.ray).applyMatrix4(_l), null !== this.boundingBox && !1 === yl.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, yl)))
                        }
                        getVertexPosition(t, e) {
                            return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
                        }
                        bind(t, e) {
                            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                        }
                        pose() {
                            this.skeleton.pose()
                        }
                        normalizeSkinWeights() {
                            const t = new mi,
                                e = this.geometry.attributes.skinWeight;
                            for (let i = 0, n = e.count; i < n; i++) {
                                t.fromBufferAttribute(e, i);
                                const n = 1 / t.manhattanLength();
                                n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                            }
                        }
                        updateMatrixWorld(t) {
                            super.updateMatrixWorld(t), this.bindMode === z ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === F ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                        }
                        applyBoneTransform(t, e) {
                            const i = this.skeleton,
                                n = this.geometry;
                            dl.fromBufferAttribute(n.attributes.skinIndex, t), pl.fromBufferAttribute(n.attributes.skinWeight, t), ul.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                            for (let t = 0; t < 4; t++) {
                                const n = pl.getComponent(t);
                                if (0 !== n) {
                                    const r = dl.getComponent(t);
                                    fl.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), e.addScaledVector(ml.copy(ul).applyMatrix4(fl), n)
                                }
                            }
                            return e.applyMatrix4(this.bindMatrixInverse)
                        }
                    }
                    class Ml extends wn {
                        constructor() {
                            super(), this.isBone = !0, this.type = "Bone"
                        }
                    }
                    class bl extends pi {
                        constructor(t = null, e = 1, i = 1, n, r, s, a, o, l = 1003, h = 1003, c, u) {
                            super(null, s, a, o, l, h, n, r, c, u), this.isDataTexture = !0, this.image = {
                                data: t,
                                width: e,
                                height: i
                            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                        }
                    }
                    const Sl = new Zi,
                        wl = new Zi;
                    class Al {
                        constructor(t = [], e = []) {
                            this.uuid = Be(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init()
                        }
                        init() {
                            const t = this.bones,
                                e = this.boneInverses;
                            if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                            else if (t.length !== e.length) {
                                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                                for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Zi)
                            }
                        }
                        calculateInverses() {
                            this.boneInverses.length = 0;
                            for (let t = 0, e = this.bones.length; t < e; t++) {
                                const e = new Zi;
                                this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                            }
                        }
                        pose() {
                            for (let t = 0, e = this.bones.length; t < e; t++) {
                                const e = this.bones[t];
                                e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                            }
                            for (let t = 0, e = this.bones.length; t < e; t++) {
                                const e = this.bones[t];
                                e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                            }
                        }
                        update() {
                            const t = this.bones,
                                e = this.boneInverses,
                                i = this.boneMatrices,
                                n = this.boneTexture;
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = t[n] ? t[n].matrixWorld : wl;
                                Sl.multiplyMatrices(r, e[n]), Sl.toArray(i, 16 * n)
                            }
                            null !== n && (n.needsUpdate = !0)
                        }
                        clone() {
                            return new Al(this.bones, this.boneInverses)
                        }
                        computeBoneTexture() {
                            let t = Math.sqrt(4 * this.bones.length);
                            t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                            const e = new Float32Array(t * t * 4);
                            e.set(this.boneMatrices);
                            const i = new bl(e, t, t, ft, ot);
                            return i.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = i, this
                        }
                        getBoneByName(t) {
                            for (let e = 0, i = this.bones.length; e < i; e++) {
                                const i = this.bones[e];
                                if (i.name === t) return i
                            }
                        }
                        dispose() {
                            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                        }
                        fromJSON(t, e) {
                            this.uuid = t.uuid;
                            for (let i = 0, n = t.bones.length; i < n; i++) {
                                const n = t.bones[i];
                                let r = e[n];
                                void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n), r = new Ml), this.bones.push(r), this.boneInverses.push((new Zi).fromArray(t.boneInverses[i]))
                            }
                            return this.init(), this
                        }
                        toJSON() {
                            const t = {
                                metadata: {
                                    version: 4.6,
                                    type: "Skeleton",
                                    generator: "Skeleton.toJSON"
                                },
                                bones: [],
                                boneInverses: []
                            };
                            t.uuid = this.uuid;
                            const e = this.bones,
                                i = this.boneInverses;
                            for (let n = 0, r = e.length; n < r; n++) {
                                const r = e[n];
                                t.bones.push(r.uuid);
                                const s = i[n];
                                t.boneInverses.push(s.toArray())
                            }
                            return t
                        }
                    }
                    class Tl extends Qn {
                        constructor(t, e, i, n = 1) {
                            super(t, e, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n
                        }
                        copy(t) {
                            return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                        }
                    }
                    const El = new Zi,
                        Cl = new Zi,
                        Rl = [],
                        Pl = new Si,
                        Il = new Zi,
                        Ll = new Er,
                        Ul = new Vi;
                    class Nl extends Er {
                        constructor(t, e, i) {
                            super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Tl(new Float32Array(16 * i), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
                            for (let t = 0; t < i; t++) this.setMatrixAt(t, Il)
                        }
                        computeBoundingBox() {
                            const t = this.geometry,
                                e = this.count;
                            null === this.boundingBox && (this.boundingBox = new Si), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
                            for (let i = 0; i < e; i++) this.getMatrixAt(i, El), Pl.copy(t.boundingBox).applyMatrix4(El), this.boundingBox.union(Pl)
                        }
                        computeBoundingSphere() {
                            const t = this.geometry,
                                e = this.count;
                            null === this.boundingSphere && (this.boundingSphere = new Vi), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                            for (let i = 0; i < e; i++) this.getMatrixAt(i, El), Ul.copy(t.boundingSphere).applyMatrix4(El), this.boundingSphere.union(Ul)
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.morphTexture && (this.morphTexture = t.morphTexture.clone()), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                        }
                        getColorAt(t, e) {
                            e.fromArray(this.instanceColor.array, 3 * t)
                        }
                        getMatrixAt(t, e) {
                            e.fromArray(this.instanceMatrix.array, 16 * t)
                        }
                        getMorphAt(t, e) {
                            const i = e.morphTargetInfluences,
                                n = this.morphTexture.source.data.data,
                                r = t * (i.length + 1) + 1;
                            for (let t = 0; t < i.length; t++) i[t] = n[r + t]
                        }
                        raycast(t, e) {
                            const i = this.matrixWorld,
                                n = this.count;
                            if (Ll.geometry = this.geometry, Ll.material = this.material, void 0 !== Ll.material && (null === this.boundingSphere && this.computeBoundingSphere(), Ul.copy(this.boundingSphere), Ul.applyMatrix4(i), !1 !== t.ray.intersectsSphere(Ul)))
                                for (let r = 0; r < n; r++) {
                                    this.getMatrixAt(r, El), Cl.multiplyMatrices(i, El), Ll.matrixWorld = Cl, Ll.raycast(t, Rl);
                                    for (let t = 0, i = Rl.length; t < i; t++) {
                                        const i = Rl[t];
                                        i.instanceId = r, i.object = this, e.push(i)
                                    }
                                    Rl.length = 0
                                }
                        }
                        setColorAt(t, e) {
                            null === this.instanceColor && (this.instanceColor = new Tl(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), e.toArray(this.instanceColor.array, 3 * t)
                        }
                        setMatrixAt(t, e) {
                            e.toArray(this.instanceMatrix.array, 16 * t)
                        }
                        setMorphAt(t, e) {
                            const i = e.morphTargetInfluences,
                                n = i.length + 1;
                            null === this.morphTexture && (this.morphTexture = new bl(new Float32Array(n * this.count), n, this.count, xt, ot));
                            const r = this.morphTexture.source.data.data;
                            let s = 0;
                            for (let t = 0; t < i.length; t++) s += i[t];
                            const a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
                                o = n * t;
                            r[o] = a, r.set(i, o + 1)
                        }
                        updateMorphTargets() {}
                        dispose() {
                            return this.dispatchEvent({
                                type: "dispose"
                            }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this
                        }
                    }

                    function Dl(t, e) {
                        return t.z - e.z
                    }

                    function Ol(t, e) {
                        return e.z - t.z
                    }
                    class Bl {
                        constructor() {
                            this.index = 0, this.pool = [], this.list = []
                        }
                        push(t, e, i) {
                            const n = this.pool,
                                r = this.list;
                            this.index >= n.length && n.push({
                                start: -1,
                                count: -1,
                                z: -1,
                                index: -1
                            });
                            const s = n[this.index];
                            r.push(s), this.index++, s.start = t.start, s.count = t.count, s.z = e, s.index = i
                        }
                        reset() {
                            this.list.length = 0, this.index = 0
                        }
                    }
                    const zl = new Zi,
                        Fl = new Zi,
                        kl = new Zi,
                        Vl = new kn(1, 1, 1),
                        Hl = new Zi,
                        Gl = new Zr,
                        Wl = new Si,
                        jl = new Vi,
                        Xl = new xi,
                        ql = new xi,
                        Yl = new xi,
                        Jl = new Bl,
                        Zl = new Er,
                        Kl = [];

                    function Ql(t, e, i = 0) {
                        const n = e.itemSize;
                        if (t.isInterleavedBufferAttribute || t.array.constructor !== e.array.constructor) {
                            const r = t.count;
                            for (let s = 0; s < r; s++)
                                for (let r = 0; r < n; r++) e.setComponent(s + i, r, t.getComponent(s, r))
                        } else e.array.set(t.array, i * n);
                        e.needsUpdate = !0
                    }
                    class $l extends Er {
                        get maxInstanceCount() {
                            return this._maxInstanceCount
                        }
                        constructor(t, e, i = 2 * e, n) {
                            super(new hr, n), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawInfo = [], this._drawRanges = [], this._reservedRanges = [], this._bounds = [], this._maxInstanceCount = t, this._maxVertexCount = e, this._maxIndexCount = i, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(t), this._multiDrawStarts = new Int32Array(t), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture()
                        }
                        _initMatricesTexture() {
                            let t = Math.sqrt(4 * this._maxInstanceCount);
                            t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                            const e = new Float32Array(t * t * 4),
                                i = new bl(e, t, t, ft, ot);
                            this._matricesTexture = i
                        }
                        _initIndirectTexture() {
                            let t = Math.sqrt(this._maxInstanceCount);
                            t = Math.ceil(t);
                            const e = new Uint32Array(t * t),
                                i = new bl(e, t, t, Mt, at);
                            this._indirectTexture = i
                        }
                        _initColorsTexture() {
                            let t = Math.sqrt(this._maxInstanceCount);
                            t = Math.ceil(t);
                            const e = new Float32Array(t * t * 4).fill(1),
                                i = new bl(e, t, t, ft, ot);
                            i.colorSpace = ri.workingColorSpace, this._colorsTexture = i
                        }
                        _initializeGeometry(t) {
                            const e = this.geometry,
                                i = this._maxVertexCount,
                                n = this._maxIndexCount;
                            if (!1 === this._geometryInitialized) {
                                for (const n in t.attributes) {
                                    const r = t.getAttribute(n),
                                        {
                                            array: s,
                                            itemSize: a,
                                            normalized: o
                                        } = r,
                                        l = new s.constructor(i * a),
                                        h = new Qn(l, a, o);
                                    e.setAttribute(n, h)
                                }
                                if (null !== t.getIndex()) {
                                    const t = i > 65535 ? new Uint32Array(n) : new Uint16Array(n);
                                    e.setIndex(new Qn(t, 1))
                                }
                                this._geometryInitialized = !0
                            }
                        }
                        _validateGeometry(t) {
                            const e = this.geometry;
                            if (Boolean(t.getIndex()) !== Boolean(e.getIndex())) throw new Error('BatchedMesh: All geometries must consistently have "index".');
                            for (const i in e.attributes) {
                                if (!t.hasAttribute(i)) throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
                                const n = t.getAttribute(i),
                                    r = e.getAttribute(i);
                                if (n.itemSize !== r.itemSize || n.normalized !== r.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                            }
                        }
                        setCustomSort(t) {
                            return this.customSort = t, this
                        }
                        computeBoundingBox() {
                            null === this.boundingBox && (this.boundingBox = new Si);
                            const t = this.boundingBox,
                                e = this._drawInfo;
                            t.makeEmpty();
                            for (let i = 0, n = e.length; i < n; i++) {
                                if (!1 === e[i].active) continue;
                                const n = e[i].geometryIndex;
                                this.getMatrixAt(i, zl), this.getBoundingBoxAt(n, Wl).applyMatrix4(zl), t.union(Wl)
                            }
                        }
                        computeBoundingSphere() {
                            null === this.boundingSphere && (this.boundingSphere = new Vi);
                            const t = this.boundingSphere,
                                e = this._drawInfo;
                            t.makeEmpty();
                            for (let i = 0, n = e.length; i < n; i++) {
                                if (!1 === e[i].active) continue;
                                const n = e[i].geometryIndex;
                                this.getMatrixAt(i, zl), this.getBoundingSphereAt(n, jl).applyMatrix4(zl), t.union(jl)
                            }
                        }
                        addInstance(t) {
                            if (this._drawInfo.length >= this._maxInstanceCount) throw new Error("BatchedMesh: Maximum item count reached.");
                            this._drawInfo.push({
                                visible: !0,
                                active: !0,
                                geometryIndex: t
                            });
                            const e = this._drawInfo.length - 1,
                                i = this._matricesTexture,
                                n = i.image.data;
                            kl.toArray(n, 16 * e), i.needsUpdate = !0;
                            const r = this._colorsTexture;
                            return r && (Vl.toArray(r.image.data, 4 * e), r.needsUpdate = !0), e
                        }
                        addGeometry(t, e = -1, i = -1) {
                            if (this._initializeGeometry(t), this._validateGeometry(t), this._drawInfo.length >= this._maxInstanceCount) throw new Error("BatchedMesh: Maximum item count reached.");
                            const n = {
                                vertexStart: -1,
                                vertexCount: -1,
                                indexStart: -1,
                                indexCount: -1
                            };
                            let r = null;
                            const s = this._reservedRanges,
                                a = this._drawRanges,
                                o = this._bounds;
                            0 !== this._geometryCount && (r = s[s.length - 1]), n.vertexCount = -1 === e ? t.getAttribute("position").count : e, n.vertexStart = null === r ? 0 : r.vertexStart + r.vertexCount;
                            const l = t.getIndex(),
                                h = null !== l;
                            if (h && (n.indexCount = -1 === i ? l.count : i, n.indexStart = null === r ? 0 : r.indexStart + r.indexCount), -1 !== n.indexStart && n.indexStart + n.indexCount > this._maxIndexCount || n.vertexStart + n.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                            const c = this._geometryCount;
                            return this._geometryCount++, s.push(n), a.push({
                                start: h ? n.indexStart : n.vertexStart,
                                count: -1
                            }), o.push({
                                boxInitialized: !1,
                                box: new Si,
                                sphereInitialized: !1,
                                sphere: new Vi
                            }), this.setGeometryAt(c, t), c
                        }
                        setGeometryAt(t, e) {
                            if (t >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                            this._validateGeometry(e);
                            const i = this.geometry,
                                n = null !== i.getIndex(),
                                r = i.getIndex(),
                                s = e.getIndex(),
                                a = this._reservedRanges[t];
                            if (n && s.count > a.indexCount || e.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                            const o = a.vertexStart,
                                l = a.vertexCount;
                            for (const t in i.attributes) {
                                const n = e.getAttribute(t),
                                    r = i.getAttribute(t);
                                Ql(n, r, o);
                                const s = n.itemSize;
                                for (let t = n.count, e = l; t < e; t++) {
                                    const e = o + t;
                                    for (let t = 0; t < s; t++) r.setComponent(e, t, 0)
                                }
                                r.needsUpdate = !0, r.addUpdateRange(o * s, l * s)
                            }
                            if (n) {
                                const t = a.indexStart;
                                for (let e = 0; e < s.count; e++) r.setX(t + e, o + s.getX(e));
                                for (let e = s.count, i = a.indexCount; e < i; e++) r.setX(t + e, o);
                                r.needsUpdate = !0, r.addUpdateRange(t, a.indexCount)
                            }
                            const h = this._bounds[t];
                            null !== e.boundingBox ? (h.box.copy(e.boundingBox), h.boxInitialized = !0) : h.boxInitialized = !1, null !== e.boundingSphere ? (h.sphere.copy(e.boundingSphere), h.sphereInitialized = !0) : h.sphereInitialized = !1;
                            const c = this._drawRanges[t],
                                u = e.getAttribute("position");
                            return c.count = n ? s.count : u.count, this._visibilityChanged = !0, t
                        }
                        getBoundingBoxAt(t, e) {
                            if (t >= this._geometryCount) return null;
                            const i = this._bounds[t],
                                n = i.box,
                                r = this.geometry;
                            if (!1 === i.boxInitialized) {
                                n.makeEmpty();
                                const e = r.index,
                                    s = r.attributes.position,
                                    a = this._drawRanges[t];
                                for (let t = a.start, i = a.start + a.count; t < i; t++) {
                                    let i = t;
                                    e && (i = e.getX(i)), n.expandByPoint(Xl.fromBufferAttribute(s, i))
                                }
                                i.boxInitialized = !0
                            }
                            return e.copy(n), e
                        }
                        getBoundingSphereAt(t, e) {
                            if (t >= this._geometryCount) return null;
                            const i = this._bounds[t],
                                n = i.sphere,
                                r = this.geometry;
                            if (!1 === i.sphereInitialized) {
                                n.makeEmpty(), this.getBoundingBoxAt(t, Wl), Wl.getCenter(n.center);
                                const e = r.index,
                                    s = r.attributes.position,
                                    a = this._drawRanges[t];
                                let o = 0;
                                for (let t = a.start, i = a.start + a.count; t < i; t++) {
                                    let i = t;
                                    e && (i = e.getX(i)), Xl.fromBufferAttribute(s, i), o = Math.max(o, n.center.distanceToSquared(Xl))
                                }
                                n.radius = Math.sqrt(o), i.sphereInitialized = !0
                            }
                            return e.copy(n), e
                        }
                        setMatrixAt(t, e) {
                            const i = this._drawInfo,
                                n = this._matricesTexture,
                                r = this._matricesTexture.image.data;
                            return t >= i.length || !1 === i[t].active || (e.toArray(r, 16 * t), n.needsUpdate = !0), this
                        }
                        getMatrixAt(t, e) {
                            const i = this._drawInfo,
                                n = this._matricesTexture.image.data;
                            return t >= i.length || !1 === i[t].active ? null : e.fromArray(n, 16 * t)
                        }
                        setColorAt(t, e) {
                            null === this._colorsTexture && this._initColorsTexture();
                            const i = this._colorsTexture,
                                n = this._colorsTexture.image.data,
                                r = this._drawInfo;
                            return t >= r.length || !1 === r[t].active || (e.toArray(n, 4 * t), i.needsUpdate = !0), this
                        }
                        getColorAt(t, e) {
                            const i = this._colorsTexture.image.data,
                                n = this._drawInfo;
                            return t >= n.length || !1 === n[t].active ? null : e.fromArray(i, 4 * t)
                        }
                        setVisibleAt(t, e) {
                            const i = this._drawInfo;
                            return t >= i.length || !1 === i[t].active || i[t].visible === e || (i[t].visible = e, this._visibilityChanged = !0), this
                        }
                        getVisibleAt(t) {
                            const e = this._drawInfo;
                            return !(t >= e.length || !1 === e[t].active) && e[t].visible
                        }
                        raycast(t, e) {
                            const i = this._drawInfo,
                                n = this._drawRanges,
                                r = this.matrixWorld,
                                s = this.geometry;
                            Zl.material = this.material, Zl.geometry.index = s.index, Zl.geometry.attributes = s.attributes, null === Zl.geometry.boundingBox && (Zl.geometry.boundingBox = new Si), null === Zl.geometry.boundingSphere && (Zl.geometry.boundingSphere = new Vi);
                            for (let s = 0, a = i.length; s < a; s++) {
                                if (!i[s].visible || !i[s].active) continue;
                                const a = i[s].geometryIndex,
                                    o = n[a];
                                Zl.geometry.setDrawRange(o.start, o.count), this.getMatrixAt(s, Zl.matrixWorld).premultiply(r), this.getBoundingBoxAt(a, Zl.geometry.boundingBox), this.getBoundingSphereAt(a, Zl.geometry.boundingSphere), Zl.raycast(t, Kl);
                                for (let t = 0, i = Kl.length; t < i; t++) {
                                    const i = Kl[t];
                                    i.object = this, i.batchId = s, e.push(i)
                                }
                                Kl.length = 0
                            }
                            Zl.material = null, Zl.geometry.index = null, Zl.geometry.attributes = {}, Zl.geometry.setDrawRange(0, 1 / 0)
                        }
                        copy(t) {
                            return super.copy(t), this.geometry = t.geometry.clone(), this.perObjectFrustumCulled = t.perObjectFrustumCulled, this.sortObjects = t.sortObjects, this.boundingBox = null !== t.boundingBox ? t.boundingBox.clone() : null, this.boundingSphere = null !== t.boundingSphere ? t.boundingSphere.clone() : null, this._drawRanges = t._drawRanges.map((t => ({
                                ...t
                            }))), this._reservedRanges = t._reservedRanges.map((t => ({
                                ...t
                            }))), this._drawInfo = t._drawInfo.map((t => ({
                                ...t
                            }))), this._bounds = t._bounds.map((t => ({
                                boxInitialized: t.boxInitialized,
                                box: t.box.clone(),
                                sphereInitialized: t.sphereInitialized,
                                sphere: t.sphere.clone()
                            }))), this._maxInstanceCount = t._maxInstanceCount, this._maxVertexCount = t._maxVertexCount, this._maxIndexCount = t._maxIndexCount, this._geometryInitialized = t._geometryInitialized, this._geometryCount = t._geometryCount, this._multiDrawCounts = t._multiDrawCounts.slice(), this._multiDrawStarts = t._multiDrawStarts.slice(), this._matricesTexture = t._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), null !== this._colorsTexture && (this._colorsTexture = t._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this
                        }
                        dispose() {
                            return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, null !== this._colorsTexture && (this._colorsTexture.dispose(), this._colorsTexture = null), this
                        }
                        onBeforeRender(t, e, i, n, r) {
                            if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
                            const s = n.getIndex(),
                                a = null === s ? 1 : s.array.BYTES_PER_ELEMENT,
                                o = this._drawInfo,
                                l = this._multiDrawStarts,
                                h = this._multiDrawCounts,
                                c = this._drawRanges,
                                u = this.perObjectFrustumCulled,
                                d = this._indirectTexture,
                                p = d.image.data;
                            u && (Hl.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), Gl.setFromProjectionMatrix(Hl, t.coordinateSystem));
                            let m = 0;
                            if (this.sortObjects) {
                                Fl.copy(this.matrixWorld).invert(), Xl.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Fl), ql.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(Fl);
                                for (let t = 0, e = o.length; t < e; t++)
                                    if (o[t].visible && o[t].active) {
                                        const e = o[t].geometryIndex;
                                        this.getMatrixAt(t, zl), this.getBoundingSphereAt(e, jl).applyMatrix4(zl);
                                        let i = !1;
                                        if (u && (i = !Gl.intersectsSphere(jl)), !i) {
                                            const i = Yl.subVectors(jl.center, Xl).dot(ql);
                                            Jl.push(c[e], i, t)
                                        }
                                    } const t = Jl.list,
                                    e = this.customSort;
                                null === e ? t.sort(r.transparent ? Ol : Dl) : e.call(this, t, i);
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e];
                                    l[m] = i.start * a, h[m] = i.count, p[m] = i.index, m++
                                }
                                Jl.reset()
                            } else
                                for (let t = 0, e = o.length; t < e; t++)
                                    if (o[t].visible && o[t].active) {
                                        const e = o[t].geometryIndex;
                                        let i = !1;
                                        if (u && (this.getMatrixAt(t, zl), this.getBoundingSphereAt(e, jl).applyMatrix4(zl), i = !Gl.intersectsSphere(jl)), !i) {
                                            const i = c[e];
                                            l[m] = i.start * a, h[m] = i.count, p[m] = t, m++
                                        }
                                    } d.needsUpdate = !0, this._multiDrawCount = m, this._visibilityChanged = !1
                        }
                        onBeforeShadow(t, e, i, n, r, s) {
                            this.onBeforeRender(t, null, n, r, s)
                        }
                    }
                    class th extends Gn {
                        constructor(t) {
                            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new kn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
                        }
                    }
                    const eh = new xi,
                        ih = new xi,
                        nh = new Zi,
                        rh = new Ji,
                        sh = new Vi,
                        ah = new xi,
                        oh = new xi;
                    class lh extends wn {
                        constructor(t = new hr, e = new th) {
                            super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                        }
                        computeLineDistances() {
                            const t = this.geometry;
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    i = [0];
                                for (let t = 1, n = e.count; t < n; t++) eh.fromBufferAttribute(e, t - 1), ih.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += eh.distanceTo(ih);
                                t.setAttribute("lineDistance", new er(i, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                        raycast(t, e) {
                            const i = this.geometry,
                                n = this.matrixWorld,
                                r = t.params.Line.threshold,
                                s = i.drawRange;
                            if (null === i.boundingSphere && i.computeBoundingSphere(), sh.copy(i.boundingSphere), sh.applyMatrix4(n), sh.radius += r, !1 === t.ray.intersectsSphere(sh)) return;
                            nh.copy(n).invert(), rh.copy(t.ray).applyMatrix4(nh);
                            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                o = a * a,
                                l = this.isLineSegments ? 2 : 1,
                                h = i.index,
                                c = i.attributes.position;
                            if (null !== h) {
                                const i = Math.max(0, s.start),
                                    n = Math.min(h.count, s.start + s.count);
                                for (let r = i, s = n - 1; r < s; r += l) {
                                    const i = h.getX(r),
                                        n = h.getX(r + 1),
                                        s = hh(this, t, rh, o, i, n);
                                    s && e.push(s)
                                }
                                if (this.isLineLoop) {
                                    const r = h.getX(n - 1),
                                        s = h.getX(i),
                                        a = hh(this, t, rh, o, r, s);
                                    a && e.push(a)
                                }
                            } else {
                                const i = Math.max(0, s.start),
                                    n = Math.min(c.count, s.start + s.count);
                                for (let r = i, s = n - 1; r < s; r += l) {
                                    const i = hh(this, t, rh, o, r, r + 1);
                                    i && e.push(i)
                                }
                                if (this.isLineLoop) {
                                    const r = hh(this, t, rh, o, n - 1, i);
                                    r && e.push(r)
                                }
                            }
                        }
                        updateMorphTargets() {
                            const t = this.geometry.morphAttributes,
                                e = Object.keys(t);
                            if (e.length > 0) {
                                const i = t[e[0]];
                                if (void 0 !== i) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t].name || String(t);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                    }
                                }
                            }
                        }
                    }

                    function hh(t, e, i, n, r, s) {
                        const a = t.geometry.attributes.position;
                        if (eh.fromBufferAttribute(a, r), ih.fromBufferAttribute(a, s), i.distanceSqToSegment(eh, ih, ah, oh) > n) return;
                        ah.applyMatrix4(t.matrixWorld);
                        const o = e.ray.origin.distanceTo(ah);
                        return o < e.near || o > e.far ? void 0 : {
                            distance: o,
                            point: oh.clone().applyMatrix4(t.matrixWorld),
                            index: r,
                            face: null,
                            faceIndex: null,
                            object: t
                        }
                    }
                    const ch = new xi,
                        uh = new xi;
                    class dh extends lh {
                        constructor(t, e) {
                            super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
                        }
                        computeLineDistances() {
                            const t = this.geometry;
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    i = [];
                                for (let t = 0, n = e.count; t < n; t += 2) ch.fromBufferAttribute(e, t), uh.fromBufferAttribute(e, t + 1), i[t] = 0 === t ? 0 : i[t - 1], i[t + 1] = i[t] + ch.distanceTo(uh);
                                t.setAttribute("lineDistance", new er(i, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                    }
                    class ph extends lh {
                        constructor(t, e) {
                            super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
                        }
                    }
                    class mh extends Gn {
                        constructor(t) {
                            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new kn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
                        }
                    }
                    const fh = new Zi,
                        gh = new Ji,
                        vh = new Vi,
                        _h = new xi;
                    class yh extends wn {
                        constructor(t = new hr, e = new mh) {
                            super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                        }
                        raycast(t, e) {
                            const i = this.geometry,
                                n = this.matrixWorld,
                                r = t.params.Points.threshold,
                                s = i.drawRange;
                            if (null === i.boundingSphere && i.computeBoundingSphere(), vh.copy(i.boundingSphere), vh.applyMatrix4(n), vh.radius += r, !1 === t.ray.intersectsSphere(vh)) return;
                            fh.copy(n).invert(), gh.copy(t.ray).applyMatrix4(fh);
                            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                o = a * a,
                                l = i.index,
                                h = i.attributes.position;
                            if (null !== l)
                                for (let i = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); i < r; i++) {
                                    const r = l.getX(i);
                                    _h.fromBufferAttribute(h, r), xh(_h, r, o, n, t, e, this)
                                } else
                                    for (let i = Math.max(0, s.start), r = Math.min(h.count, s.start + s.count); i < r; i++) _h.fromBufferAttribute(h, i), xh(_h, i, o, n, t, e, this)
                        }
                        updateMorphTargets() {
                            const t = this.geometry.morphAttributes,
                                e = Object.keys(t);
                            if (e.length > 0) {
                                const i = t[e[0]];
                                if (void 0 !== i) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t].name || String(t);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                    }
                                }
                            }
                        }
                    }

                    function xh(t, e, i, n, r, s, a) {
                        const o = gh.distanceSqToPoint(t);
                        if (o < i) {
                            const i = new xi;
                            gh.closestPointToPoint(t, i), i.applyMatrix4(n);
                            const l = r.ray.origin.distanceTo(i);
                            if (l < r.near || l > r.far) return;
                            s.push({
                                distance: l,
                                distanceToRay: Math.sqrt(o),
                                point: i,
                                index: e,
                                face: null,
                                object: a
                            })
                        }
                    }
                    class Mh extends pi {
                        constructor(t, e, i, n, r, s, a, o, l, h, c, u) {
                            super(null, s, a, o, l, h, n, r, c, u), this.isCompressedTexture = !0, this.image = {
                                width: e,
                                height: i
                            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                        }
                    }
                    class bh {
                        constructor() {
                            this.type = "Curve", this.arcLengthDivisions = 200
                        }
                        getPoint() {
                            return console.warn("THREE.Curve: .getPoint() not implemented."), null
                        }
                        getPointAt(t, e) {
                            const i = this.getUtoTmapping(t);
                            return this.getPoint(i, e)
                        }
                        getPoints(t = 5) {
                            const e = [];
                            for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                            return e
                        }
                        getSpacedPoints(t = 5) {
                            const e = [];
                            for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                            return e
                        }
                        getLength() {
                            const t = this.getLengths();
                            return t[t.length - 1]
                        }
                        getLengths(t = this.arcLengthDivisions) {
                            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                            this.needsUpdate = !1;
                            const e = [];
                            let i, n = this.getPoint(0),
                                r = 0;
                            e.push(0);
                            for (let s = 1; s <= t; s++) i = this.getPoint(s / t), r += i.distanceTo(n), e.push(r), n = i;
                            return this.cacheArcLengths = e, e
                        }
                        updateArcLengths() {
                            this.needsUpdate = !0, this.getLengths()
                        }
                        getUtoTmapping(t, e) {
                            const i = this.getLengths();
                            let n = 0;
                            const r = i.length;
                            let s;
                            s = e || t * i[r - 1];
                            let a, o = 0,
                                l = r - 1;
                            for (; o <= l;)
                                if (n = Math.floor(o + (l - o) / 2), a = i[n] - s, a < 0) o = n + 1;
                                else {
                                    if (!(a > 0)) {
                                        l = n;
                                        break
                                    }
                                    l = n - 1
                                } if (n = l, i[n] === s) return n / (r - 1);
                            const h = i[n];
                            return (n + (s - h) / (i[n + 1] - h)) / (r - 1)
                        }
                        getTangent(t, e) {
                            const i = 1e-4;
                            let n = t - i,
                                r = t + i;
                            n < 0 && (n = 0), r > 1 && (r = 1);
                            const s = this.getPoint(n),
                                a = this.getPoint(r),
                                o = e || (s.isVector2 ? new We : new xi);
                            return o.copy(a).sub(s).normalize(), o
                        }
                        getTangentAt(t, e) {
                            const i = this.getUtoTmapping(t);
                            return this.getTangent(i, e)
                        }
                        computeFrenetFrames(t, e) {
                            const i = new xi,
                                n = [],
                                r = [],
                                s = [],
                                a = new xi,
                                o = new Zi;
                            for (let e = 0; e <= t; e++) {
                                const i = e / t;
                                n[e] = this.getTangentAt(i, new xi)
                            }
                            r[0] = new xi, s[0] = new xi;
                            let l = Number.MAX_VALUE;
                            const h = Math.abs(n[0].x),
                                c = Math.abs(n[0].y),
                                u = Math.abs(n[0].z);
                            h <= l && (l = h, i.set(1, 0, 0)), c <= l && (l = c, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), s[0].crossVectors(n[0], r[0]);
                            for (let e = 1; e <= t; e++) {
                                if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(n[e - 1], n[e]), a.length() > Number.EPSILON) {
                                    a.normalize();
                                    const t = Math.acos(ze(n[e - 1].dot(n[e]), -1, 1));
                                    r[e].applyMatrix4(o.makeRotationAxis(a, t))
                                }
                                s[e].crossVectors(n[e], r[e])
                            }
                            if (!0 === e) {
                                let e = Math.acos(ze(r[0].dot(r[t]), -1, 1));
                                e /= t, n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                                for (let i = 1; i <= t; i++) r[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)), s[i].crossVectors(n[i], r[i])
                            }
                            return {
                                tangents: n,
                                normals: r,
                                binormals: s
                            }
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.arcLengthDivisions = t.arcLengthDivisions, this
                        }
                        toJSON() {
                            const t = {
                                metadata: {
                                    version: 4.6,
                                    type: "Curve",
                                    generator: "Curve.toJSON"
                                }
                            };
                            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                        }
                        fromJSON(t) {
                            return this.arcLengthDivisions = t.arcLengthDivisions, this
                        }
                    }
                    class Sh extends bh {
                        constructor(t = 0, e = 0, i = 1, n = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                            super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                        }
                        getPoint(t, e = new We) {
                            const i = e,
                                n = 2 * Math.PI;
                            let r = this.aEndAngle - this.aStartAngle;
                            const s = Math.abs(r) < Number.EPSILON;
                            for (; r < 0;) r += n;
                            for (; r > n;) r -= n;
                            r < Number.EPSILON && (r = s ? 0 : n), !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
                            const a = this.aStartAngle + t * r;
                            let o = this.aX + this.xRadius * Math.cos(a),
                                l = this.aY + this.yRadius * Math.sin(a);
                            if (0 !== this.aRotation) {
                                const t = Math.cos(this.aRotation),
                                    e = Math.sin(this.aRotation),
                                    i = o - this.aX,
                                    n = l - this.aY;
                                o = i * t - n * e + this.aX, l = i * e + n * t + this.aY
                            }
                            return i.set(o, l)
                        }
                        copy(t) {
                            return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                        }
                    }
                    class wh extends Sh {
                        constructor(t, e, i, n, r, s) {
                            super(t, e, i, i, n, r, s), this.isArcCurve = !0, this.type = "ArcCurve"
                        }
                    }

                    function Ah() {
                        let t = 0,
                            e = 0,
                            i = 0,
                            n = 0;

                        function r(r, s, a, o) {
                            t = r, e = a, i = -3 * r + 3 * s - 2 * a - o, n = 2 * r - 2 * s + a + o
                        }
                        return {
                            initCatmullRom: function(t, e, i, n, s) {
                                r(e, i, s * (i - t), s * (n - e))
                            },
                            initNonuniformCatmullRom: function(t, e, i, n, s, a, o) {
                                let l = (e - t) / s - (i - t) / (s + a) + (i - e) / a,
                                    h = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                                l *= a, h *= a, r(e, i, l, h)
                            },
                            calc: function(r) {
                                const s = r * r;
                                return t + e * r + i * s + n * (s * r)
                            }
                        }
                    }
                    const Th = new xi,
                        Eh = new Ah,
                        Ch = new Ah,
                        Rh = new Ah;
                    class Ph extends bh {
                        constructor(t = [], e = !1, i = "centripetal", n = .5) {
                            super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n
                        }
                        getPoint(t, e = new xi) {
                            const i = e,
                                n = this.points,
                                r = n.length,
                                s = (r - (this.closed ? 0 : 1)) * t;
                            let a, o, l = Math.floor(s),
                                h = s - l;
                            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2, h = 1), this.closed || l > 0 ? a = n[(l - 1) % r] : (Th.subVectors(n[0], n[1]).add(n[0]), a = Th);
                            const c = n[l % r],
                                u = n[(l + 1) % r];
                            if (this.closed || l + 2 < r ? o = n[(l + 2) % r] : (Th.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), o = Th), "centripetal" === this.curveType || "chordal" === this.curveType) {
                                const t = "chordal" === this.curveType ? .5 : .25;
                                let e = Math.pow(a.distanceToSquared(c), t),
                                    i = Math.pow(c.distanceToSquared(u), t),
                                    n = Math.pow(u.distanceToSquared(o), t);
                                i < 1e-4 && (i = 1), e < 1e-4 && (e = i), n < 1e-4 && (n = i), Eh.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, e, i, n), Ch.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, e, i, n), Rh.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, e, i, n)
                            } else "catmullrom" === this.curveType && (Eh.initCatmullRom(a.x, c.x, u.x, o.x, this.tension), Ch.initCatmullRom(a.y, c.y, u.y, o.y, this.tension), Rh.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
                            return i.set(Eh.calc(h), Ch.calc(h), Rh.calc(h)), i
                        }
                        copy(t) {
                            super.copy(t), this.points = [];
                            for (let e = 0, i = t.points.length; e < i; e++) {
                                const i = t.points[e];
                                this.points.push(i.clone())
                            }
                            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            t.points = [];
                            for (let e = 0, i = this.points.length; e < i; e++) {
                                const i = this.points[e];
                                t.points.push(i.toArray())
                            }
                            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                        }
                        fromJSON(t) {
                            super.fromJSON(t), this.points = [];
                            for (let e = 0, i = t.points.length; e < i; e++) {
                                const i = t.points[e];
                                this.points.push((new xi).fromArray(i))
                            }
                            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                        }
                    }

                    function Ih(t, e, i, n, r) {
                        const s = .5 * (n - e),
                            a = .5 * (r - i),
                            o = t * t;
                        return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
                    }

                    function Lh(t, e, i, n) {
                        return function(t, e) {
                            const i = 1 - t;
                            return i * i * e
                        }(t, e) + function(t, e) {
                            return 2 * (1 - t) * t * e
                        }(t, i) + function(t, e) {
                            return t * t * e
                        }(t, n)
                    }

                    function Uh(t, e, i, n, r) {
                        return function(t, e) {
                            const i = 1 - t;
                            return i * i * i * e
                        }(t, e) + function(t, e) {
                            const i = 1 - t;
                            return 3 * i * i * t * e
                        }(t, i) + function(t, e) {
                            return 3 * (1 - t) * t * t * e
                        }(t, n) + function(t, e) {
                            return t * t * t * e
                        }(t, r)
                    }
                    class Nh extends bh {
                        constructor(t = new We, e = new We, i = new We, n = new We) {
                            super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
                        }
                        getPoint(t, e = new We) {
                            const i = e,
                                n = this.v0,
                                r = this.v1,
                                s = this.v2,
                                a = this.v3;
                            return i.set(Uh(t, n.x, r.x, s.x, a.x), Uh(t, n.y, r.y, s.y, a.y)), i
                        }
                        copy(t) {
                            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                        }
                    }
                    class Dh extends bh {
                        constructor(t = new xi, e = new xi, i = new xi, n = new xi) {
                            super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
                        }
                        getPoint(t, e = new xi) {
                            const i = e,
                                n = this.v0,
                                r = this.v1,
                                s = this.v2,
                                a = this.v3;
                            return i.set(Uh(t, n.x, r.x, s.x, a.x), Uh(t, n.y, r.y, s.y, a.y), Uh(t, n.z, r.z, s.z, a.z)), i
                        }
                        copy(t) {
                            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                        }
                    }
                    class Oh extends bh {
                        constructor(t = new We, e = new We) {
                            super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
                        }
                        getPoint(t, e = new We) {
                            const i = e;
                            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
                        }
                        getPointAt(t, e) {
                            return this.getPoint(t, e)
                        }
                        getTangent(t, e = new We) {
                            return e.subVectors(this.v2, this.v1).normalize()
                        }
                        getTangentAt(t, e) {
                            return this.getTangent(t, e)
                        }
                        copy(t) {
                            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    }
                    class Bh extends bh {
                        constructor(t = new xi, e = new xi) {
                            super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
                        }
                        getPoint(t, e = new xi) {
                            const i = e;
                            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
                        }
                        getPointAt(t, e) {
                            return this.getPoint(t, e)
                        }
                        getTangent(t, e = new xi) {
                            return e.subVectors(this.v2, this.v1).normalize()
                        }
                        getTangentAt(t, e) {
                            return this.getTangent(t, e)
                        }
                        copy(t) {
                            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    }
                    class zh extends bh {
                        constructor(t = new We, e = new We, i = new We) {
                            super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i
                        }
                        getPoint(t, e = new We) {
                            const i = e,
                                n = this.v0,
                                r = this.v1,
                                s = this.v2;
                            return i.set(Lh(t, n.x, r.x, s.x), Lh(t, n.y, r.y, s.y)), i
                        }
                        copy(t) {
                            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    }
                    class Fh extends bh {
                        constructor(t = new xi, e = new xi, i = new xi) {
                            super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i
                        }
                        getPoint(t, e = new xi) {
                            const i = e,
                                n = this.v0,
                                r = this.v1,
                                s = this.v2;
                            return i.set(Lh(t, n.x, r.x, s.x), Lh(t, n.y, r.y, s.y), Lh(t, n.z, r.z, s.z)), i
                        }
                        copy(t) {
                            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    }
                    class kh extends bh {
                        constructor(t = []) {
                            super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
                        }
                        getPoint(t, e = new We) {
                            const i = e,
                                n = this.points,
                                r = (n.length - 1) * t,
                                s = Math.floor(r),
                                a = r - s,
                                o = n[0 === s ? s : s - 1],
                                l = n[s],
                                h = n[s > n.length - 2 ? n.length - 1 : s + 1],
                                c = n[s > n.length - 3 ? n.length - 1 : s + 2];
                            return i.set(Ih(a, o.x, l.x, h.x, c.x), Ih(a, o.y, l.y, h.y, c.y)), i
                        }
                        copy(t) {
                            super.copy(t), this.points = [];
                            for (let e = 0, i = t.points.length; e < i; e++) {
                                const i = t.points[e];
                                this.points.push(i.clone())
                            }
                            return this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            t.points = [];
                            for (let e = 0, i = this.points.length; e < i; e++) {
                                const i = this.points[e];
                                t.points.push(i.toArray())
                            }
                            return t
                        }
                        fromJSON(t) {
                            super.fromJSON(t), this.points = [];
                            for (let e = 0, i = t.points.length; e < i; e++) {
                                const i = t.points[e];
                                this.points.push((new We).fromArray(i))
                            }
                            return this
                        }
                    }
                    var Vh = Object.freeze({
                        __proto__: null,
                        ArcCurve: wh,
                        CatmullRomCurve3: Ph,
                        CubicBezierCurve: Nh,
                        CubicBezierCurve3: Dh,
                        EllipseCurve: Sh,
                        LineCurve: Oh,
                        LineCurve3: Bh,
                        QuadraticBezierCurve: zh,
                        QuadraticBezierCurve3: Fh,
                        SplineCurve: kh
                    });
                    class Hh extends bh {
                        constructor() {
                            super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                        }
                        add(t) {
                            this.curves.push(t)
                        }
                        closePath() {
                            const t = this.curves[0].getPoint(0),
                                e = this.curves[this.curves.length - 1].getPoint(1);
                            if (!t.equals(e)) {
                                const i = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
                                this.curves.push(new Vh[i](e, t))
                            }
                            return this
                        }
                        getPoint(t, e) {
                            const i = t * this.getLength(),
                                n = this.getCurveLengths();
                            let r = 0;
                            for (; r < n.length;) {
                                if (n[r] >= i) {
                                    const t = n[r] - i,
                                        s = this.curves[r],
                                        a = s.getLength(),
                                        o = 0 === a ? 0 : 1 - t / a;
                                    return s.getPointAt(o, e)
                                }
                                r++
                            }
                            return null
                        }
                        getLength() {
                            const t = this.getCurveLengths();
                            return t[t.length - 1]
                        }
                        updateArcLengths() {
                            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                        }
                        getCurveLengths() {
                            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                            const t = [];
                            let e = 0;
                            for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                            return this.cacheLengths = t, t
                        }
                        getSpacedPoints(t = 40) {
                            const e = [];
                            for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                            return this.autoClose && e.push(e[0]), e
                        }
                        getPoints(t = 12) {
                            const e = [];
                            let i;
                            for (let n = 0, r = this.curves; n < r.length; n++) {
                                const s = r[n],
                                    a = s.isEllipseCurve ? 2 * t : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? t * s.points.length : t,
                                    o = s.getPoints(a);
                                for (let t = 0; t < o.length; t++) {
                                    const n = o[t];
                                    i && i.equals(n) || (e.push(n), i = n)
                                }
                            }
                            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                        }
                        copy(t) {
                            super.copy(t), this.curves = [];
                            for (let e = 0, i = t.curves.length; e < i; e++) {
                                const i = t.curves[e];
                                this.curves.push(i.clone())
                            }
                            return this.autoClose = t.autoClose, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            t.autoClose = this.autoClose, t.curves = [];
                            for (let e = 0, i = this.curves.length; e < i; e++) {
                                const i = this.curves[e];
                                t.curves.push(i.toJSON())
                            }
                            return t
                        }
                        fromJSON(t) {
                            super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                            for (let e = 0, i = t.curves.length; e < i; e++) {
                                const i = t.curves[e];
                                this.curves.push((new Vh[i.type]).fromJSON(i))
                            }
                            return this
                        }
                    }
                    class Gh extends Hh {
                        constructor(t) {
                            super(), this.type = "Path", this.currentPoint = new We, t && this.setFromPoints(t)
                        }
                        setFromPoints(t) {
                            this.moveTo(t[0].x, t[0].y);
                            for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                            return this
                        }
                        moveTo(t, e) {
                            return this.currentPoint.set(t, e), this
                        }
                        lineTo(t, e) {
                            const i = new Oh(this.currentPoint.clone(), new We(t, e));
                            return this.curves.push(i), this.currentPoint.set(t, e), this
                        }
                        quadraticCurveTo(t, e, i, n) {
                            const r = new zh(this.currentPoint.clone(), new We(t, e), new We(i, n));
                            return this.curves.push(r), this.currentPoint.set(i, n), this
                        }
                        bezierCurveTo(t, e, i, n, r, s) {
                            const a = new Nh(this.currentPoint.clone(), new We(t, e), new We(i, n), new We(r, s));
                            return this.curves.push(a), this.currentPoint.set(r, s), this
                        }
                        splineThru(t) {
                            const e = [this.currentPoint.clone()].concat(t),
                                i = new kh(e);
                            return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
                        }
                        arc(t, e, i, n, r, s) {
                            const a = this.currentPoint.x,
                                o = this.currentPoint.y;
                            return this.absarc(t + a, e + o, i, n, r, s), this
                        }
                        absarc(t, e, i, n, r, s) {
                            return this.absellipse(t, e, i, i, n, r, s), this
                        }
                        ellipse(t, e, i, n, r, s, a, o) {
                            const l = this.currentPoint.x,
                                h = this.currentPoint.y;
                            return this.absellipse(t + l, e + h, i, n, r, s, a, o), this
                        }
                        absellipse(t, e, i, n, r, s, a, o) {
                            const l = new Sh(t, e, i, n, r, s, a, o);
                            if (this.curves.length > 0) {
                                const t = l.getPoint(0);
                                t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                            }
                            this.curves.push(l);
                            const h = l.getPoint(1);
                            return this.currentPoint.copy(h), this
                        }
                        copy(t) {
                            return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.currentPoint = this.currentPoint.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                        }
                    }
                    class Wh extends hr {
                        constructor(t = [new We(0, -.5), new We(.5, 0), new We(0, .5)], e = 12, i = 0, n = 2 * Math.PI) {
                            super(), this.type = "LatheGeometry", this.parameters = {
                                points: t,
                                segments: e,
                                phiStart: i,
                                phiLength: n
                            }, e = Math.floor(e), n = ze(n, 0, 2 * Math.PI);
                            const r = [],
                                s = [],
                                a = [],
                                o = [],
                                l = [],
                                h = 1 / e,
                                c = new xi,
                                u = new We,
                                d = new xi,
                                p = new xi,
                                m = new xi;
                            let f = 0,
                                g = 0;
                            for (let e = 0; e <= t.length - 1; e++) switch (e) {
                                case 0:
                                    f = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, m.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                                    break;
                                case t.length - 1:
                                    o.push(m.x, m.y, m.z);
                                    break;
                                default:
                                    f = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, p.copy(d), d.x += m.x, d.y += m.y, d.z += m.z, d.normalize(), o.push(d.x, d.y, d.z), m.copy(p)
                            }
                            for (let r = 0; r <= e; r++) {
                                const d = i + r * h * n,
                                    p = Math.sin(d),
                                    m = Math.cos(d);
                                for (let i = 0; i <= t.length - 1; i++) {
                                    c.x = t[i].x * p, c.y = t[i].y, c.z = t[i].x * m, s.push(c.x, c.y, c.z), u.x = r / e, u.y = i / (t.length - 1), a.push(u.x, u.y);
                                    const n = o[3 * i + 0] * p,
                                        h = o[3 * i + 1],
                                        d = o[3 * i + 0] * m;
                                    l.push(n, h, d)
                                }
                            }
                            for (let i = 0; i < e; i++)
                                for (let e = 0; e < t.length - 1; e++) {
                                    const n = e + i * t.length,
                                        s = n,
                                        a = n + t.length,
                                        o = n + t.length + 1,
                                        l = n + 1;
                                    r.push(s, a, l), r.push(o, l, a)
                                }
                            this.setIndex(r), this.setAttribute("position", new er(s, 3)), this.setAttribute("uv", new er(a, 2)), this.setAttribute("normal", new er(l, 3))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Wh(t.points, t.segments, t.phiStart, t.phiLength)
                        }
                    }
                    class jh extends Wh {
                        constructor(t = 1, e = 1, i = 4, n = 8) {
                            const r = new Gh;
                            r.absarc(0, -e / 2, t, 1.5 * Math.PI, 0), r.absarc(0, e / 2, t, 0, .5 * Math.PI), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
                                radius: t,
                                length: e,
                                capSegments: i,
                                radialSegments: n
                            }
                        }
                        static fromJSON(t) {
                            return new jh(t.radius, t.length, t.capSegments, t.radialSegments)
                        }
                    }
                    class Xh extends hr {
                        constructor(t = 1, e = 32, i = 0, n = 2 * Math.PI) {
                            super(), this.type = "CircleGeometry", this.parameters = {
                                radius: t,
                                segments: e,
                                thetaStart: i,
                                thetaLength: n
                            }, e = Math.max(3, e);
                            const r = [],
                                s = [],
                                a = [],
                                o = [],
                                l = new xi,
                                h = new We;
                            s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
                            for (let r = 0, c = 3; r <= e; r++, c += 3) {
                                const u = i + r / e * n;
                                l.x = t * Math.cos(u), l.y = t * Math.sin(u), s.push(l.x, l.y, l.z), a.push(0, 0, 1), h.x = (s[c] / t + 1) / 2, h.y = (s[c + 1] / t + 1) / 2, o.push(h.x, h.y)
                            }
                            for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
                            this.setIndex(r), this.setAttribute("position", new er(s, 3)), this.setAttribute("normal", new er(a, 3)), this.setAttribute("uv", new er(o, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Xh(t.radius, t.segments, t.thetaStart, t.thetaLength)
                        }
                    }
                    class qh extends hr {
                        constructor(t = 1, e = 1, i = 1, n = 32, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
                            super(), this.type = "CylinderGeometry", this.parameters = {
                                radiusTop: t,
                                radiusBottom: e,
                                height: i,
                                radialSegments: n,
                                heightSegments: r,
                                openEnded: s,
                                thetaStart: a,
                                thetaLength: o
                            };
                            const l = this;
                            n = Math.floor(n), r = Math.floor(r);
                            const h = [],
                                c = [],
                                u = [],
                                d = [];
                            let p = 0;
                            const m = [],
                                f = i / 2;
                            let g = 0;

                            function v(i) {
                                const r = p,
                                    s = new We,
                                    m = new xi;
                                let v = 0;
                                const _ = !0 === i ? t : e,
                                    y = !0 === i ? 1 : -1;
                                for (let t = 1; t <= n; t++) c.push(0, f * y, 0), u.push(0, y, 0), d.push(.5, .5), p++;
                                const x = p;
                                for (let t = 0; t <= n; t++) {
                                    const e = t / n * o + a,
                                        i = Math.cos(e),
                                        r = Math.sin(e);
                                    m.x = _ * r, m.y = f * y, m.z = _ * i, c.push(m.x, m.y, m.z), u.push(0, y, 0), s.x = .5 * i + .5, s.y = .5 * r * y + .5, d.push(s.x, s.y), p++
                                }
                                for (let t = 0; t < n; t++) {
                                    const e = r + t,
                                        n = x + t;
                                    !0 === i ? h.push(n, n + 1, e) : h.push(n + 1, n, e), v += 3
                                }
                                l.addGroup(g, v, !0 === i ? 1 : 2), g += v
                            }! function() {
                                const s = new xi,
                                    v = new xi;
                                let _ = 0;
                                const y = (e - t) / i;
                                for (let l = 0; l <= r; l++) {
                                    const h = [],
                                        g = l / r,
                                        _ = g * (e - t) + t;
                                    for (let t = 0; t <= n; t++) {
                                        const e = t / n,
                                            r = e * o + a,
                                            l = Math.sin(r),
                                            m = Math.cos(r);
                                        v.x = _ * l, v.y = -g * i + f, v.z = _ * m, c.push(v.x, v.y, v.z), s.set(l, y, m).normalize(), u.push(s.x, s.y, s.z), d.push(e, 1 - g), h.push(p++)
                                    }
                                    m.push(h)
                                }
                                for (let t = 0; t < n; t++)
                                    for (let e = 0; e < r; e++) {
                                        const i = m[e][t],
                                            n = m[e + 1][t],
                                            r = m[e + 1][t + 1],
                                            s = m[e][t + 1];
                                        h.push(i, n, s), h.push(n, r, s), _ += 6
                                    }
                                l.addGroup(g, _, 0), g += _
                            }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(h), this.setAttribute("position", new er(c, 3)), this.setAttribute("normal", new er(u, 3)), this.setAttribute("uv", new er(d, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new qh(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                        }
                    }
                    class Yh extends qh {
                        constructor(t = 1, e = 1, i = 32, n = 1, r = !1, s = 0, a = 2 * Math.PI) {
                            super(0, t, e, i, n, r, s, a), this.type = "ConeGeometry", this.parameters = {
                                radius: t,
                                height: e,
                                radialSegments: i,
                                heightSegments: n,
                                openEnded: r,
                                thetaStart: s,
                                thetaLength: a
                            }
                        }
                        static fromJSON(t) {
                            return new Yh(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                        }
                    }
                    class Jh extends hr {
                        constructor(t = [], e = [], i = 1, n = 0) {
                            super(), this.type = "PolyhedronGeometry", this.parameters = {
                                vertices: t,
                                indices: e,
                                radius: i,
                                detail: n
                            };
                            const r = [],
                                s = [];

                            function a(t, e, i, n) {
                                const r = n + 1,
                                    s = [];
                                for (let n = 0; n <= r; n++) {
                                    s[n] = [];
                                    const a = t.clone().lerp(i, n / r),
                                        o = e.clone().lerp(i, n / r),
                                        l = r - n;
                                    for (let t = 0; t <= l; t++) s[n][t] = 0 === t && n === r ? a : a.clone().lerp(o, t / l)
                                }
                                for (let t = 0; t < r; t++)
                                    for (let e = 0; e < 2 * (r - t) - 1; e++) {
                                        const i = Math.floor(e / 2);
                                        e % 2 == 0 ? (o(s[t][i + 1]), o(s[t + 1][i]), o(s[t][i])) : (o(s[t][i + 1]), o(s[t + 1][i + 1]), o(s[t + 1][i]))
                                    }
                            }

                            function o(t) {
                                r.push(t.x, t.y, t.z)
                            }

                            function l(e, i) {
                                const n = 3 * e;
                                i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
                            }

                            function h(t, e, i, n) {
                                n < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === i.x && 0 === i.z && (s[e] = n / 2 / Math.PI + .5)
                            }

                            function c(t) {
                                return Math.atan2(t.z, -t.x)
                            }! function(t) {
                                const i = new xi,
                                    n = new xi,
                                    r = new xi;
                                for (let s = 0; s < e.length; s += 3) l(e[s + 0], i), l(e[s + 1], n), l(e[s + 2], r), a(i, n, r, t)
                            }(n),
                            function(t) {
                                const e = new xi;
                                for (let i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
                            }(i),
                            function() {
                                const t = new xi;
                                for (let i = 0; i < r.length; i += 3) {
                                    t.x = r[i + 0], t.y = r[i + 1], t.z = r[i + 2];
                                    const n = c(t) / 2 / Math.PI + .5,
                                        a = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
                                    s.push(n, 1 - a)
                                }
                                var e;
                                (function() {
                                    const t = new xi,
                                        e = new xi,
                                        i = new xi,
                                        n = new xi,
                                        a = new We,
                                        o = new We,
                                        l = new We;
                                    for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                                        t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[u + 6], r[u + 7], r[u + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                                        const p = c(n);
                                        h(a, d + 0, t, p), h(o, d + 2, e, p), h(l, d + 4, i, p)
                                    }
                                })(),
                                function() {
                                    for (let t = 0; t < s.length; t += 6) {
                                        const e = s[t + 0],
                                            i = s[t + 2],
                                            n = s[t + 4],
                                            r = Math.max(e, i, n),
                                            a = Math.min(e, i, n);
                                        r > .9 && a < .1 && (e < .2 && (s[t + 0] += 1), i < .2 && (s[t + 2] += 1), n < .2 && (s[t + 4] += 1))
                                    }
                                }()
                            }(), this.setAttribute("position", new er(r, 3)), this.setAttribute("normal", new er(r.slice(), 3)), this.setAttribute("uv", new er(s, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Jh(t.vertices, t.indices, t.radius, t.details)
                        }
                    }
                    class Zh extends Jh {
                        constructor(t = 1, e = 0) {
                            const i = (1 + Math.sqrt(5)) / 2,
                                n = 1 / i;
                            super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
                                radius: t,
                                detail: e
                            }
                        }
                        static fromJSON(t) {
                            return new Zh(t.radius, t.detail)
                        }
                    }
                    const Kh = new xi,
                        Qh = new xi,
                        $h = new xi,
                        tc = new Dn;
                    class ec extends hr {
                        constructor(t = null, e = 1) {
                            if (super(), this.type = "EdgesGeometry", this.parameters = {
                                    geometry: t,
                                    thresholdAngle: e
                                }, null !== t) {
                                const i = 4,
                                    n = Math.pow(10, i),
                                    r = Math.cos(De * e),
                                    s = t.getIndex(),
                                    a = t.getAttribute("position"),
                                    o = s ? s.count : a.count,
                                    l = [0, 0, 0],
                                    h = ["a", "b", "c"],
                                    c = new Array(3),
                                    u = {},
                                    d = [];
                                for (let t = 0; t < o; t += 3) {
                                    s ? (l[0] = s.getX(t), l[1] = s.getX(t + 1), l[2] = s.getX(t + 2)) : (l[0] = t, l[1] = t + 1, l[2] = t + 2);
                                    const {
                                        a: e,
                                        b: i,
                                        c: o
                                    } = tc;
                                    if (e.fromBufferAttribute(a, l[0]), i.fromBufferAttribute(a, l[1]), o.fromBufferAttribute(a, l[2]), tc.getNormal($h), c[0] = `${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`, c[1] = `${Math.round(i.x*n)},${Math.round(i.y*n)},${Math.round(i.z*n)}`, c[2] = `${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
                                        for (let t = 0; t < 3; t++) {
                                            const e = (t + 1) % 3,
                                                i = c[t],
                                                n = c[e],
                                                s = tc[h[t]],
                                                a = tc[h[e]],
                                                o = `${i}_${n}`,
                                                p = `${n}_${i}`;
                                            p in u && u[p] ? ($h.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z), d.push(a.x, a.y, a.z)), u[p] = null) : o in u || (u[o] = {
                                                index0: l[t],
                                                index1: l[e],
                                                normal: $h.clone()
                                            })
                                        }
                                }
                                for (const t in u)
                                    if (u[t]) {
                                        const {
                                            index0: e,
                                            index1: i
                                        } = u[t];
                                        Kh.fromBufferAttribute(a, e), Qh.fromBufferAttribute(a, i), d.push(Kh.x, Kh.y, Kh.z), d.push(Qh.x, Qh.y, Qh.z)
                                    } this.setAttribute("position", new er(d, 3))
                            }
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                    }
                    class ic extends Gh {
                        constructor(t) {
                            super(t), this.uuid = Be(), this.type = "Shape", this.holes = []
                        }
                        getPointsHoles(t) {
                            const e = [];
                            for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                            return e
                        }
                        extractPoints(t) {
                            return {
                                shape: this.getPoints(t),
                                holes: this.getPointsHoles(t)
                            }
                        }
                        copy(t) {
                            super.copy(t), this.holes = [];
                            for (let e = 0, i = t.holes.length; e < i; e++) {
                                const i = t.holes[e];
                                this.holes.push(i.clone())
                            }
                            return this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            t.uuid = this.uuid, t.holes = [];
                            for (let e = 0, i = this.holes.length; e < i; e++) {
                                const i = this.holes[e];
                                t.holes.push(i.toJSON())
                            }
                            return t
                        }
                        fromJSON(t) {
                            super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                            for (let e = 0, i = t.holes.length; e < i; e++) {
                                const i = t.holes[e];
                                this.holes.push((new Gh).fromJSON(i))
                            }
                            return this
                        }
                    }

                    function nc(t, e, i, n, r) {
                        let s, a;
                        if (r === function(t, e, i, n) {
                                let r = 0;
                                for (let s = e, a = i - n; s < i; s += n) r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
                                return r
                            }(t, e, i, n) > 0)
                            for (s = e; s < i; s += n) a = wc(s, t[s], t[s + 1], a);
                        else
                            for (s = i - n; s >= e; s -= n) a = wc(s, t[s], t[s + 1], a);
                        return a && _c(a, a.next) && (Ac(a), a = a.next), a
                    }

                    function rc(t, e) {
                        if (!t) return t;
                        e || (e = t);
                        let i, n = t;
                        do {
                            if (i = !1, n.steiner || !_c(n, n.next) && 0 !== vc(n.prev, n, n.next)) n = n.next;
                            else {
                                if (Ac(n), n = e = n.prev, n === n.next) break;
                                i = !0
                            }
                        } while (i || n !== e);
                        return e
                    }

                    function sc(t, e, i, n, r, s, a) {
                        if (!t) return;
                        !a && s && function(t, e, i, n) {
                            let r = t;
                            do {
                                0 === r.z && (r.z = pc(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                            } while (r !== t);
                            r.prevZ.nextZ = null, r.prevZ = null,
                                function(t) {
                                    let e, i, n, r, s, a, o, l, h = 1;
                                    do {
                                        for (i = t, t = null, s = null, a = 0; i;) {
                                            for (a++, n = i, o = 0, e = 0; e < h && (o++, n = n.nextZ, n); e++);
                                            for (l = h; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                            i = n
                                        }
                                        s.nextZ = null, h *= 2
                                    } while (a > 1)
                                }(r)
                        }(t, n, r, s);
                        let o, l, h = t;
                        for (; t.prev !== t.next;)
                            if (o = t.prev, l = t.next, s ? oc(t, n, r, s) : ac(t)) e.push(o.i / i | 0), e.push(t.i / i | 0), e.push(l.i / i | 0), Ac(t), t = l.next, h = l.next;
                            else if ((t = l) === h) {
                            a ? 1 === a ? sc(t = lc(rc(t), e, i), e, i, n, r, s, 2) : 2 === a && hc(t, e, i, n, r, s) : sc(rc(t), e, i, n, r, s, 1);
                            break
                        }
                    }

                    function ac(t) {
                        const e = t.prev,
                            i = t,
                            n = t.next;
                        if (vc(e, i, n) >= 0) return !1;
                        const r = e.x,
                            s = i.x,
                            a = n.x,
                            o = e.y,
                            l = i.y,
                            h = n.y,
                            c = r < s ? r < a ? r : a : s < a ? s : a,
                            u = o < l ? o < h ? o : h : l < h ? l : h,
                            d = r > s ? r > a ? r : a : s > a ? s : a,
                            p = o > l ? o > h ? o : h : l > h ? l : h;
                        let m = n.next;
                        for (; m !== e;) {
                            if (m.x >= c && m.x <= d && m.y >= u && m.y <= p && fc(r, o, s, l, a, h, m.x, m.y) && vc(m.prev, m, m.next) >= 0) return !1;
                            m = m.next
                        }
                        return !0
                    }

                    function oc(t, e, i, n) {
                        const r = t.prev,
                            s = t,
                            a = t.next;
                        if (vc(r, s, a) >= 0) return !1;
                        const o = r.x,
                            l = s.x,
                            h = a.x,
                            c = r.y,
                            u = s.y,
                            d = a.y,
                            p = o < l ? o < h ? o : h : l < h ? l : h,
                            m = c < u ? c < d ? c : d : u < d ? u : d,
                            f = o > l ? o > h ? o : h : l > h ? l : h,
                            g = c > u ? c > d ? c : d : u > d ? u : d,
                            v = pc(p, m, e, i, n),
                            _ = pc(f, g, e, i, n);
                        let y = t.prevZ,
                            x = t.nextZ;
                        for (; y && y.z >= v && x && x.z <= _;) {
                            if (y.x >= p && y.x <= f && y.y >= m && y.y <= g && y !== r && y !== a && fc(o, c, l, u, h, d, y.x, y.y) && vc(y.prev, y, y.next) >= 0) return !1;
                            if (y = y.prevZ, x.x >= p && x.x <= f && x.y >= m && x.y <= g && x !== r && x !== a && fc(o, c, l, u, h, d, x.x, x.y) && vc(x.prev, x, x.next) >= 0) return !1;
                            x = x.nextZ
                        }
                        for (; y && y.z >= v;) {
                            if (y.x >= p && y.x <= f && y.y >= m && y.y <= g && y !== r && y !== a && fc(o, c, l, u, h, d, y.x, y.y) && vc(y.prev, y, y.next) >= 0) return !1;
                            y = y.prevZ
                        }
                        for (; x && x.z <= _;) {
                            if (x.x >= p && x.x <= f && x.y >= m && x.y <= g && x !== r && x !== a && fc(o, c, l, u, h, d, x.x, x.y) && vc(x.prev, x, x.next) >= 0) return !1;
                            x = x.nextZ
                        }
                        return !0
                    }

                    function lc(t, e, i) {
                        let n = t;
                        do {
                            const r = n.prev,
                                s = n.next.next;
                            !_c(r, s) && yc(r, n, n.next, s) && bc(r, s) && bc(s, r) && (e.push(r.i / i | 0), e.push(n.i / i | 0), e.push(s.i / i | 0), Ac(n), Ac(n.next), n = t = s), n = n.next
                        } while (n !== t);
                        return rc(n)
                    }

                    function hc(t, e, i, n, r, s) {
                        let a = t;
                        do {
                            let t = a.next.next;
                            for (; t !== a.prev;) {
                                if (a.i !== t.i && gc(a, t)) {
                                    let o = Sc(a, t);
                                    return a = rc(a, a.next), o = rc(o, o.next), sc(a, e, i, n, r, s, 0), void sc(o, e, i, n, r, s, 0)
                                }
                                t = t.next
                            }
                            a = a.next
                        } while (a !== t)
                    }

                    function cc(t, e) {
                        return t.x - e.x
                    }

                    function uc(t, e) {
                        const i = function(t, e) {
                            let i, n = e,
                                r = -1 / 0;
                            const s = t.x,
                                a = t.y;
                            do {
                                if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                                    const t = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                    if (t <= s && t > r && (r = t, i = n.x < n.next.x ? n : n.next, t === s)) return i
                                }
                                n = n.next
                            } while (n !== e);
                            if (!i) return null;
                            const o = i,
                                l = i.x,
                                h = i.y;
                            let c, u = 1 / 0;
                            n = i;
                            do {
                                s >= n.x && n.x >= l && s !== n.x && fc(a < h ? s : r, a, l, h, a < h ? r : s, a, n.x, n.y) && (c = Math.abs(a - n.y) / (s - n.x), bc(n, t) && (c < u || c === u && (n.x > i.x || n.x === i.x && dc(i, n))) && (i = n, u = c)), n = n.next
                            } while (n !== o);
                            return i
                        }(t, e);
                        if (!i) return e;
                        const n = Sc(i, t);
                        return rc(n, n.next), rc(i, i.next)
                    }

                    function dc(t, e) {
                        return vc(t.prev, t, e.prev) < 0 && vc(e.next, t, t.next) < 0
                    }

                    function pc(t, e, i, n, r) {
                        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                    }

                    function mc(t) {
                        let e = t,
                            i = t;
                        do {
                            (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next
                        } while (e !== t);
                        return i
                    }

                    function fc(t, e, i, n, r, s, a, o) {
                        return (r - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (i - a) * (e - o) && (i - a) * (s - o) >= (r - a) * (n - o)
                    }

                    function gc(t, e) {
                        return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                            let i = t;
                            do {
                                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && yc(i, i.next, t, e)) return !0;
                                i = i.next
                            } while (i !== t);
                            return !1
                        }(t, e) && (bc(t, e) && bc(e, t) && function(t, e) {
                            let i = t,
                                n = !1;
                            const r = (t.x + e.x) / 2,
                                s = (t.y + e.y) / 2;
                            do {
                                i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                            } while (i !== t);
                            return n
                        }(t, e) && (vc(t.prev, t, e.prev) || vc(t, e.prev, e)) || _c(t, e) && vc(t.prev, t, t.next) > 0 && vc(e.prev, e, e.next) > 0)
                    }

                    function vc(t, e, i) {
                        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
                    }

                    function _c(t, e) {
                        return t.x === e.x && t.y === e.y
                    }

                    function yc(t, e, i, n) {
                        const r = Mc(vc(t, e, i)),
                            s = Mc(vc(t, e, n)),
                            a = Mc(vc(i, n, t)),
                            o = Mc(vc(i, n, e));
                        return r !== s && a !== o || !(0 !== r || !xc(t, i, e)) || !(0 !== s || !xc(t, n, e)) || !(0 !== a || !xc(i, t, n)) || !(0 !== o || !xc(i, e, n))
                    }

                    function xc(t, e, i) {
                        return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
                    }

                    function Mc(t) {
                        return t > 0 ? 1 : t < 0 ? -1 : 0
                    }

                    function bc(t, e) {
                        return vc(t.prev, t, t.next) < 0 ? vc(t, e, t.next) >= 0 && vc(t, t.prev, e) >= 0 : vc(t, e, t.prev) < 0 || vc(t, t.next, e) < 0
                    }

                    function Sc(t, e) {
                        const i = new Tc(t.i, t.x, t.y),
                            n = new Tc(e.i, e.x, e.y),
                            r = t.next,
                            s = e.prev;
                        return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n
                    }

                    function wc(t, e, i, n) {
                        const r = new Tc(t, e, i);
                        return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
                    }

                    function Ac(t) {
                        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                    }

                    function Tc(t, e, i) {
                        this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
                    }
                    class Ec {
                        static area(t) {
                            const e = t.length;
                            let i = 0;
                            for (let n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                            return .5 * i
                        }
                        static isClockWise(t) {
                            return Ec.area(t) < 0
                        }
                        static triangulateShape(t, e) {
                            const i = [],
                                n = [],
                                r = [];
                            Cc(t), Rc(i, t);
                            let s = t.length;
                            e.forEach(Cc);
                            for (let t = 0; t < e.length; t++) n.push(s), s += e[t].length, Rc(i, e[t]);
                            const a = function(t, e, i = 2) {
                                const n = e && e.length,
                                    r = n ? e[0] * i : t.length;
                                let s = nc(t, 0, r, i, !0);
                                const a = [];
                                if (!s || s.next === s.prev) return a;
                                let o, l, h, c, u, d, p;
                                if (n && (s = function(t, e, i, n) {
                                        const r = [];
                                        let s, a, o, l, h;
                                        for (s = 0, a = e.length; s < a; s++) o = e[s] * n, l = s < a - 1 ? e[s + 1] * n : t.length, h = nc(t, o, l, n, !1), h === h.next && (h.steiner = !0), r.push(mc(h));
                                        for (r.sort(cc), s = 0; s < r.length; s++) i = uc(r[s], i);
                                        return i
                                    }(t, e, s, i)), t.length > 80 * i) {
                                    o = h = t[0], l = c = t[1];
                                    for (let e = i; e < r; e += i) u = t[e], d = t[e + 1], u < o && (o = u), d < l && (l = d), u > h && (h = u), d > c && (c = d);
                                    p = Math.max(h - o, c - l), p = 0 !== p ? 32767 / p : 0
                                }
                                return sc(s, a, i, o, l, p, 0), a
                            }(i, n);
                            for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                            return r
                        }
                    }

                    function Cc(t) {
                        const e = t.length;
                        e > 2 && t[e - 1].equals(t[0]) && t.pop()
                    }

                    function Rc(t, e) {
                        for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
                    }
                    class Pc extends hr {
                        constructor(t = new ic([new We(.5, .5), new We(-.5, .5), new We(-.5, -.5), new We(.5, -.5)]), e = {}) {
                            super(), this.type = "ExtrudeGeometry", this.parameters = {
                                shapes: t,
                                options: e
                            }, t = Array.isArray(t) ? t : [t];
                            const i = this,
                                n = [],
                                r = [];
                            for (let e = 0, i = t.length; e < i; e++) s(t[e]);

                            function s(t) {
                                const s = [],
                                    a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                    o = void 0 !== e.steps ? e.steps : 1,
                                    l = void 0 !== e.depth ? e.depth : 1;
                                let h = void 0 === e.bevelEnabled || e.bevelEnabled,
                                    c = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                    u = void 0 !== e.bevelSize ? e.bevelSize : c - .1,
                                    d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                    p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                                const m = e.extrudePath,
                                    f = void 0 !== e.UVGenerator ? e.UVGenerator : Ic;
                                let g, v, _, y, x, M = !1;
                                m && (g = m.getSpacedPoints(o), M = !0, h = !1, v = m.computeFrenetFrames(o, !1), _ = new xi, y = new xi, x = new xi), h || (p = 0, c = 0, u = 0, d = 0);
                                const b = t.extractPoints(a);
                                let S = b.shape;
                                const w = b.holes;
                                if (!Ec.isClockWise(S)) {
                                    S = S.reverse();
                                    for (let t = 0, e = w.length; t < e; t++) {
                                        const e = w[t];
                                        Ec.isClockWise(e) && (w[t] = e.reverse())
                                    }
                                }
                                const A = Ec.triangulateShape(S, w),
                                    T = S;
                                for (let t = 0, e = w.length; t < e; t++) {
                                    const e = w[t];
                                    S = S.concat(e)
                                }

                                function E(t, e, i) {
                                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().addScaledVector(e, i)
                                }
                                const C = S.length,
                                    R = A.length;

                                function P(t, e, i) {
                                    let n, r, s;
                                    const a = t.x - e.x,
                                        o = t.y - e.y,
                                        l = i.x - t.x,
                                        h = i.y - t.y,
                                        c = a * a + o * o,
                                        u = a * h - o * l;
                                    if (Math.abs(u) > Number.EPSILON) {
                                        const u = Math.sqrt(c),
                                            d = Math.sqrt(l * l + h * h),
                                            p = e.x - o / u,
                                            m = e.y + a / u,
                                            f = ((i.x - h / d - p) * h - (i.y + l / d - m) * l) / (a * h - o * l);
                                        n = p + a * f - t.x, r = m + o * f - t.y;
                                        const g = n * n + r * r;
                                        if (g <= 2) return new We(n, r);
                                        s = Math.sqrt(g / 2)
                                    } else {
                                        let t = !1;
                                        a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(h) && (t = !0), t ? (n = -o, r = a, s = Math.sqrt(c)) : (n = a, r = o, s = Math.sqrt(c / 2))
                                    }
                                    return new We(n / s, r / s)
                                }
                                const I = [];
                                for (let t = 0, e = T.length, i = e - 1, n = t + 1; t < e; t++, i++, n++) i === e && (i = 0), n === e && (n = 0), I[t] = P(T[t], T[i], T[n]);
                                const L = [];
                                let U, N = I.concat();
                                for (let t = 0, e = w.length; t < e; t++) {
                                    const e = w[t];
                                    U = [];
                                    for (let t = 0, i = e.length, n = i - 1, r = t + 1; t < i; t++, n++, r++) n === i && (n = 0), r === i && (r = 0), U[t] = P(e[t], e[n], e[r]);
                                    L.push(U), N = N.concat(U)
                                }
                                for (let t = 0; t < p; t++) {
                                    const e = t / p,
                                        i = c * Math.cos(e * Math.PI / 2),
                                        n = u * Math.sin(e * Math.PI / 2) + d;
                                    for (let t = 0, e = T.length; t < e; t++) {
                                        const e = E(T[t], I[t], n);
                                        B(e.x, e.y, -i)
                                    }
                                    for (let t = 0, e = w.length; t < e; t++) {
                                        const e = w[t];
                                        U = L[t];
                                        for (let t = 0, r = e.length; t < r; t++) {
                                            const r = E(e[t], U[t], n);
                                            B(r.x, r.y, -i)
                                        }
                                    }
                                }
                                const D = u + d;
                                for (let t = 0; t < C; t++) {
                                    const e = h ? E(S[t], N[t], D) : S[t];
                                    M ? (y.copy(v.normals[0]).multiplyScalar(e.x), _.copy(v.binormals[0]).multiplyScalar(e.y), x.copy(g[0]).add(y).add(_), B(x.x, x.y, x.z)) : B(e.x, e.y, 0)
                                }
                                for (let t = 1; t <= o; t++)
                                    for (let e = 0; e < C; e++) {
                                        const i = h ? E(S[e], N[e], D) : S[e];
                                        M ? (y.copy(v.normals[t]).multiplyScalar(i.x), _.copy(v.binormals[t]).multiplyScalar(i.y), x.copy(g[t]).add(y).add(_), B(x.x, x.y, x.z)) : B(i.x, i.y, l / o * t)
                                    }
                                for (let t = p - 1; t >= 0; t--) {
                                    const e = t / p,
                                        i = c * Math.cos(e * Math.PI / 2),
                                        n = u * Math.sin(e * Math.PI / 2) + d;
                                    for (let t = 0, e = T.length; t < e; t++) {
                                        const e = E(T[t], I[t], n);
                                        B(e.x, e.y, l + i)
                                    }
                                    for (let t = 0, e = w.length; t < e; t++) {
                                        const e = w[t];
                                        U = L[t];
                                        for (let t = 0, r = e.length; t < r; t++) {
                                            const r = E(e[t], U[t], n);
                                            M ? B(r.x, r.y + g[o - 1].y, g[o - 1].x + i) : B(r.x, r.y, l + i)
                                        }
                                    }
                                }

                                function O(t, e) {
                                    let i = t.length;
                                    for (; --i >= 0;) {
                                        const n = i;
                                        let r = i - 1;
                                        r < 0 && (r = t.length - 1);
                                        for (let t = 0, i = o + 2 * p; t < i; t++) {
                                            const i = C * t,
                                                s = C * (t + 1);
                                            F(e + n + i, e + r + i, e + r + s, e + n + s)
                                        }
                                    }
                                }

                                function B(t, e, i) {
                                    s.push(t), s.push(e), s.push(i)
                                }

                                function z(t, e, r) {
                                    k(t), k(e), k(r);
                                    const s = n.length / 3,
                                        a = f.generateTopUV(i, n, s - 3, s - 2, s - 1);
                                    V(a[0]), V(a[1]), V(a[2])
                                }

                                function F(t, e, r, s) {
                                    k(t), k(e), k(s), k(e), k(r), k(s);
                                    const a = n.length / 3,
                                        o = f.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                                    V(o[0]), V(o[1]), V(o[3]), V(o[1]), V(o[2]), V(o[3])
                                }

                                function k(t) {
                                    n.push(s[3 * t + 0]), n.push(s[3 * t + 1]), n.push(s[3 * t + 2])
                                }

                                function V(t) {
                                    r.push(t.x), r.push(t.y)
                                }! function() {
                                    const t = n.length / 3;
                                    if (h) {
                                        let t = 0,
                                            e = C * t;
                                        for (let t = 0; t < R; t++) {
                                            const i = A[t];
                                            z(i[2] + e, i[1] + e, i[0] + e)
                                        }
                                        t = o + 2 * p, e = C * t;
                                        for (let t = 0; t < R; t++) {
                                            const i = A[t];
                                            z(i[0] + e, i[1] + e, i[2] + e)
                                        }
                                    } else {
                                        for (let t = 0; t < R; t++) {
                                            const e = A[t];
                                            z(e[2], e[1], e[0])
                                        }
                                        for (let t = 0; t < R; t++) {
                                            const e = A[t];
                                            z(e[0] + C * o, e[1] + C * o, e[2] + C * o)
                                        }
                                    }
                                    i.addGroup(t, n.length / 3 - t, 0)
                                }(),
                                function() {
                                    const t = n.length / 3;
                                    let e = 0;
                                    O(T, e), e += T.length;
                                    for (let t = 0, i = w.length; t < i; t++) {
                                        const i = w[t];
                                        O(i, e), e += i.length
                                    }
                                    i.addGroup(t, n.length / 3 - t, 1)
                                }()
                            }
                            this.setAttribute("position", new er(n, 3)), this.setAttribute("uv", new er(r, 2)), this.computeVertexNormals()
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return function(t, e, i) {
                                if (i.shapes = [], Array.isArray(t))
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e];
                                        i.shapes.push(n.uuid)
                                    } else i.shapes.push(t.uuid);
                                return i.options = Object.assign({}, e), void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
                            }(this.parameters.shapes, this.parameters.options, t)
                        }
                        static fromJSON(t, e) {
                            const i = [];
                            for (let n = 0, r = t.shapes.length; n < r; n++) {
                                const r = e[t.shapes[n]];
                                i.push(r)
                            }
                            const n = t.options.extrudePath;
                            return void 0 !== n && (t.options.extrudePath = (new Vh[n.type]).fromJSON(n)), new Pc(i, t.options)
                        }
                    }
                    const Ic = {
                        generateTopUV: function(t, e, i, n, r) {
                            const s = e[3 * i],
                                a = e[3 * i + 1],
                                o = e[3 * n],
                                l = e[3 * n + 1],
                                h = e[3 * r],
                                c = e[3 * r + 1];
                            return [new We(s, a), new We(o, l), new We(h, c)]
                        },
                        generateSideWallUV: function(t, e, i, n, r, s) {
                            const a = e[3 * i],
                                o = e[3 * i + 1],
                                l = e[3 * i + 2],
                                h = e[3 * n],
                                c = e[3 * n + 1],
                                u = e[3 * n + 2],
                                d = e[3 * r],
                                p = e[3 * r + 1],
                                m = e[3 * r + 2],
                                f = e[3 * s],
                                g = e[3 * s + 1],
                                v = e[3 * s + 2];
                            return Math.abs(o - c) < Math.abs(a - h) ? [new We(a, 1 - l), new We(h, 1 - u), new We(d, 1 - m), new We(f, 1 - v)] : [new We(o, 1 - l), new We(c, 1 - u), new We(p, 1 - m), new We(g, 1 - v)]
                        }
                    };
                    class Lc extends Jh {
                        constructor(t = 1, e = 0) {
                            const i = (1 + Math.sqrt(5)) / 2;
                            super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
                                radius: t,
                                detail: e
                            }
                        }
                        static fromJSON(t) {
                            return new Lc(t.radius, t.detail)
                        }
                    }
                    class Uc extends Jh {
                        constructor(t = 1, e = 0) {
                            super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                                radius: t,
                                detail: e
                            }
                        }
                        static fromJSON(t) {
                            return new Uc(t.radius, t.detail)
                        }
                    }
                    class Nc extends hr {
                        constructor(t = .5, e = 1, i = 32, n = 1, r = 0, s = 2 * Math.PI) {
                            super(), this.type = "RingGeometry", this.parameters = {
                                innerRadius: t,
                                outerRadius: e,
                                thetaSegments: i,
                                phiSegments: n,
                                thetaStart: r,
                                thetaLength: s
                            }, i = Math.max(3, i);
                            const a = [],
                                o = [],
                                l = [],
                                h = [];
                            let c = t;
                            const u = (e - t) / (n = Math.max(1, n)),
                                d = new xi,
                                p = new We;
                            for (let t = 0; t <= n; t++) {
                                for (let t = 0; t <= i; t++) {
                                    const n = r + t / i * s;
                                    d.x = c * Math.cos(n), d.y = c * Math.sin(n), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, h.push(p.x, p.y)
                                }
                                c += u
                            }
                            for (let t = 0; t < n; t++) {
                                const e = t * (i + 1);
                                for (let t = 0; t < i; t++) {
                                    const n = t + e,
                                        r = n,
                                        s = n + i + 1,
                                        o = n + i + 2,
                                        l = n + 1;
                                    a.push(r, s, l), a.push(s, o, l)
                                }
                            }
                            this.setIndex(a), this.setAttribute("position", new er(o, 3)), this.setAttribute("normal", new er(l, 3)), this.setAttribute("uv", new er(h, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Nc(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
                        }
                    }
                    class Dc extends hr {
                        constructor(t = new ic([new We(0, .5), new We(-.5, -.5), new We(.5, -.5)]), e = 12) {
                            super(), this.type = "ShapeGeometry", this.parameters = {
                                shapes: t,
                                curveSegments: e
                            };
                            const i = [],
                                n = [],
                                r = [],
                                s = [];
                            let a = 0,
                                o = 0;
                            if (!1 === Array.isArray(t)) l(t);
                            else
                                for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), a += o, o = 0;

                            function l(t) {
                                const a = n.length / 3,
                                    l = t.extractPoints(e);
                                let h = l.shape;
                                const c = l.holes;
                                !1 === Ec.isClockWise(h) && (h = h.reverse());
                                for (let t = 0, e = c.length; t < e; t++) {
                                    const e = c[t];
                                    !0 === Ec.isClockWise(e) && (c[t] = e.reverse())
                                }
                                const u = Ec.triangulateShape(h, c);
                                for (let t = 0, e = c.length; t < e; t++) {
                                    const e = c[t];
                                    h = h.concat(e)
                                }
                                for (let t = 0, e = h.length; t < e; t++) {
                                    const e = h[t];
                                    n.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
                                }
                                for (let t = 0, e = u.length; t < e; t++) {
                                    const e = u[t],
                                        n = e[0] + a,
                                        r = e[1] + a,
                                        s = e[2] + a;
                                    i.push(n, r, s), o += 3
                                }
                            }
                            this.setIndex(i), this.setAttribute("position", new er(n, 3)), this.setAttribute("normal", new er(r, 3)), this.setAttribute("uv", new er(s, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return function(t, e) {
                                if (e.shapes = [], Array.isArray(t))
                                    for (let i = 0, n = t.length; i < n; i++) {
                                        const n = t[i];
                                        e.shapes.push(n.uuid)
                                    } else e.shapes.push(t.uuid);
                                return e
                            }(this.parameters.shapes, t)
                        }
                        static fromJSON(t, e) {
                            const i = [];
                            for (let n = 0, r = t.shapes.length; n < r; n++) {
                                const r = e[t.shapes[n]];
                                i.push(r)
                            }
                            return new Dc(i, t.curveSegments)
                        }
                    }
                    class Oc extends hr {
                        constructor(t = 1, e = 32, i = 16, n = 0, r = 2 * Math.PI, s = 0, a = Math.PI) {
                            super(), this.type = "SphereGeometry", this.parameters = {
                                radius: t,
                                widthSegments: e,
                                heightSegments: i,
                                phiStart: n,
                                phiLength: r,
                                thetaStart: s,
                                thetaLength: a
                            }, e = Math.max(3, Math.floor(e)), i = Math.max(2, Math.floor(i));
                            const o = Math.min(s + a, Math.PI);
                            let l = 0;
                            const h = [],
                                c = new xi,
                                u = new xi,
                                d = [],
                                p = [],
                                m = [],
                                f = [];
                            for (let d = 0; d <= i; d++) {
                                const g = [],
                                    v = d / i;
                                let _ = 0;
                                0 === d && 0 === s ? _ = .5 / e : d === i && o === Math.PI && (_ = -.5 / e);
                                for (let i = 0; i <= e; i++) {
                                    const o = i / e;
                                    c.x = -t * Math.cos(n + o * r) * Math.sin(s + v * a), c.y = t * Math.cos(s + v * a), c.z = t * Math.sin(n + o * r) * Math.sin(s + v * a), p.push(c.x, c.y, c.z), u.copy(c).normalize(), m.push(u.x, u.y, u.z), f.push(o + _, 1 - v), g.push(l++)
                                }
                                h.push(g)
                            }
                            for (let t = 0; t < i; t++)
                                for (let n = 0; n < e; n++) {
                                    const e = h[t][n + 1],
                                        r = h[t][n],
                                        a = h[t + 1][n],
                                        l = h[t + 1][n + 1];
                                    (0 !== t || s > 0) && d.push(e, r, l), (t !== i - 1 || o < Math.PI) && d.push(r, a, l)
                                }
                            this.setIndex(d), this.setAttribute("position", new er(p, 3)), this.setAttribute("normal", new er(m, 3)), this.setAttribute("uv", new er(f, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Oc(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
                        }
                    }
                    class Bc extends Jh {
                        constructor(t = 1, e = 0) {
                            super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
                                radius: t,
                                detail: e
                            }
                        }
                        static fromJSON(t) {
                            return new Bc(t.radius, t.detail)
                        }
                    }
                    class zc extends hr {
                        constructor(t = 1, e = .4, i = 12, n = 48, r = 2 * Math.PI) {
                            super(), this.type = "TorusGeometry", this.parameters = {
                                radius: t,
                                tube: e,
                                radialSegments: i,
                                tubularSegments: n,
                                arc: r
                            }, i = Math.floor(i), n = Math.floor(n);
                            const s = [],
                                a = [],
                                o = [],
                                l = [],
                                h = new xi,
                                c = new xi,
                                u = new xi;
                            for (let s = 0; s <= i; s++)
                                for (let d = 0; d <= n; d++) {
                                    const p = d / n * r,
                                        m = s / i * Math.PI * 2;
                                    c.x = (t + e * Math.cos(m)) * Math.cos(p), c.y = (t + e * Math.cos(m)) * Math.sin(p), c.z = e * Math.sin(m), a.push(c.x, c.y, c.z), h.x = t * Math.cos(p), h.y = t * Math.sin(p), u.subVectors(c, h).normalize(), o.push(u.x, u.y, u.z), l.push(d / n), l.push(s / i)
                                }
                            for (let t = 1; t <= i; t++)
                                for (let e = 1; e <= n; e++) {
                                    const i = (n + 1) * t + e - 1,
                                        r = (n + 1) * (t - 1) + e - 1,
                                        a = (n + 1) * (t - 1) + e,
                                        o = (n + 1) * t + e;
                                    s.push(i, r, o), s.push(r, a, o)
                                }
                            this.setIndex(s), this.setAttribute("position", new er(a, 3)), this.setAttribute("normal", new er(o, 3)), this.setAttribute("uv", new er(l, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new zc(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
                        }
                    }
                    class Fc extends hr {
                        constructor(t = 1, e = .4, i = 64, n = 8, r = 2, s = 3) {
                            super(), this.type = "TorusKnotGeometry", this.parameters = {
                                radius: t,
                                tube: e,
                                tubularSegments: i,
                                radialSegments: n,
                                p: r,
                                q: s
                            }, i = Math.floor(i), n = Math.floor(n);
                            const a = [],
                                o = [],
                                l = [],
                                h = [],
                                c = new xi,
                                u = new xi,
                                d = new xi,
                                p = new xi,
                                m = new xi,
                                f = new xi,
                                g = new xi;
                            for (let a = 0; a <= i; ++a) {
                                const _ = a / i * r * Math.PI * 2;
                                v(_, r, s, t, d), v(_ + .01, r, s, t, p), f.subVectors(p, d), g.addVectors(p, d), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
                                for (let t = 0; t <= n; ++t) {
                                    const r = t / n * Math.PI * 2,
                                        s = -e * Math.cos(r),
                                        p = e * Math.sin(r);
                                    c.x = d.x + (s * g.x + p * m.x), c.y = d.y + (s * g.y + p * m.y), c.z = d.z + (s * g.z + p * m.z), o.push(c.x, c.y, c.z), u.subVectors(c, d).normalize(), l.push(u.x, u.y, u.z), h.push(a / i), h.push(t / n)
                                }
                            }
                            for (let t = 1; t <= i; t++)
                                for (let e = 1; e <= n; e++) {
                                    const i = (n + 1) * (t - 1) + (e - 1),
                                        r = (n + 1) * t + (e - 1),
                                        s = (n + 1) * t + e,
                                        o = (n + 1) * (t - 1) + e;
                                    a.push(i, r, o), a.push(r, s, o)
                                }

                            function v(t, e, i, n, r) {
                                const s = Math.cos(t),
                                    a = Math.sin(t),
                                    o = i / e * t,
                                    l = Math.cos(o);
                                r.x = n * (2 + l) * .5 * s, r.y = n * (2 + l) * a * .5, r.z = n * Math.sin(o) * .5
                            }
                            this.setIndex(a), this.setAttribute("position", new er(o, 3)), this.setAttribute("normal", new er(l, 3)), this.setAttribute("uv", new er(h, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new Fc(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
                        }
                    }
                    class kc extends hr {
                        constructor(t = new Fh(new xi(-1, -1, 0), new xi(-1, 1, 0), new xi(1, 1, 0)), e = 64, i = 1, n = 8, r = !1) {
                            super(), this.type = "TubeGeometry", this.parameters = {
                                path: t,
                                tubularSegments: e,
                                radius: i,
                                radialSegments: n,
                                closed: r
                            };
                            const s = t.computeFrenetFrames(e, r);
                            this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
                            const a = new xi,
                                o = new xi,
                                l = new We;
                            let h = new xi;
                            const c = [],
                                u = [],
                                d = [],
                                p = [];

                            function m(r) {
                                h = t.getPointAt(r / e, h);
                                const l = s.normals[r],
                                    d = s.binormals[r];
                                for (let t = 0; t <= n; t++) {
                                    const e = t / n * Math.PI * 2,
                                        r = Math.sin(e),
                                        s = -Math.cos(e);
                                    o.x = s * l.x + r * d.x, o.y = s * l.y + r * d.y, o.z = s * l.z + r * d.z, o.normalize(), u.push(o.x, o.y, o.z), a.x = h.x + i * o.x, a.y = h.y + i * o.y, a.z = h.z + i * o.z, c.push(a.x, a.y, a.z)
                                }
                            }! function() {
                                for (let t = 0; t < e; t++) m(t);
                                m(!1 === r ? e : 0),
                                    function() {
                                        for (let t = 0; t <= e; t++)
                                            for (let i = 0; i <= n; i++) l.x = t / e, l.y = i / n, d.push(l.x, l.y)
                                    }(),
                                    function() {
                                        for (let t = 1; t <= e; t++)
                                            for (let e = 1; e <= n; e++) {
                                                const i = (n + 1) * (t - 1) + (e - 1),
                                                    r = (n + 1) * t + (e - 1),
                                                    s = (n + 1) * t + e,
                                                    a = (n + 1) * (t - 1) + e;
                                                p.push(i, r, a), p.push(r, s, a)
                                            }
                                    }()
                            }(), this.setIndex(p), this.setAttribute("position", new er(c, 3)), this.setAttribute("normal", new er(u, 3)), this.setAttribute("uv", new er(d, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.path = this.parameters.path.toJSON(), t
                        }
                        static fromJSON(t) {
                            return new kc((new Vh[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
                        }
                    }
                    class Vc extends hr {
                        constructor(t = null) {
                            if (super(), this.type = "WireframeGeometry", this.parameters = {
                                    geometry: t
                                }, null !== t) {
                                const e = [],
                                    i = new Set,
                                    n = new xi,
                                    r = new xi;
                                if (null !== t.index) {
                                    const s = t.attributes.position,
                                        a = t.index;
                                    let o = t.groups;
                                    0 === o.length && (o = [{
                                        start: 0,
                                        count: a.count,
                                        materialIndex: 0
                                    }]);
                                    for (let t = 0, l = o.length; t < l; ++t) {
                                        const l = o[t],
                                            h = l.start;
                                        for (let t = h, o = h + l.count; t < o; t += 3)
                                            for (let o = 0; o < 3; o++) {
                                                const l = a.getX(t + o),
                                                    h = a.getX(t + (o + 1) % 3);
                                                n.fromBufferAttribute(s, l), r.fromBufferAttribute(s, h), !0 === Hc(n, r, i) && (e.push(n.x, n.y, n.z), e.push(r.x, r.y, r.z))
                                            }
                                    }
                                } else {
                                    const s = t.attributes.position;
                                    for (let t = 0, a = s.count / 3; t < a; t++)
                                        for (let a = 0; a < 3; a++) {
                                            const o = 3 * t + a,
                                                l = 3 * t + (a + 1) % 3;
                                            n.fromBufferAttribute(s, o), r.fromBufferAttribute(s, l), !0 === Hc(n, r, i) && (e.push(n.x, n.y, n.z), e.push(r.x, r.y, r.z))
                                        }
                                }
                                this.setAttribute("position", new er(e, 3))
                            }
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                    }

                    function Hc(t, e, i) {
                        const n = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
                            r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
                        return !0 !== i.has(n) && !0 !== i.has(r) && (i.add(n), i.add(r), !0)
                    }
                    var Gc = Object.freeze({
                        __proto__: null,
                        BoxGeometry: Rr,
                        CapsuleGeometry: jh,
                        CircleGeometry: Xh,
                        ConeGeometry: Yh,
                        CylinderGeometry: qh,
                        DodecahedronGeometry: Zh,
                        EdgesGeometry: ec,
                        ExtrudeGeometry: Pc,
                        IcosahedronGeometry: Lc,
                        LatheGeometry: Wh,
                        OctahedronGeometry: Uc,
                        PlaneGeometry: $r,
                        PolyhedronGeometry: Jh,
                        RingGeometry: Nc,
                        ShapeGeometry: Dc,
                        SphereGeometry: Oc,
                        TetrahedronGeometry: Bc,
                        TorusGeometry: zc,
                        TorusKnotGeometry: Fc,
                        TubeGeometry: kc,
                        WireframeGeometry: Vc
                    });
                    class Wc extends Gn {
                        constructor(t) {
                            super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new kn(0), this.transparent = !0, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.fog = t.fog, this
                        }
                    }
                    class jc extends Nr {
                        constructor(t) {
                            super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                        }
                    }
                    class Xc extends Gn {
                        constructor(t) {
                            super(), this.isMeshStandardMaterial = !0, this.defines = {
                                STANDARD: ""
                            }, this.type = "MeshStandardMaterial", this.color = new kn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new on, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.defines = {
                                STANDARD: ""
                            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                        }
                    }
                    class qc extends Xc {
                        constructor(t) {
                            super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                                STANDARD: "",
                                PHYSICAL: ""
                            }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new We(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                                get: function() {
                                    return ze(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                                },
                                set: function(t) {
                                    this.ior = (1 + .4 * t) / (1 - .4 * t)
                                }
                            }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new kn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new kn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new kn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t)
                        }
                        get anisotropy() {
                            return this._anisotropy
                        }
                        set anisotropy(t) {
                            this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t
                        }
                        get clearcoat() {
                            return this._clearcoat
                        }
                        set clearcoat(t) {
                            this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
                        }
                        get iridescence() {
                            return this._iridescence
                        }
                        set iridescence(t) {
                            this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
                        }
                        get dispersion() {
                            return this._dispersion
                        }
                        set dispersion(t) {
                            this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t
                        }
                        get sheen() {
                            return this._sheen
                        }
                        set sheen(t) {
                            this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                        }
                        get transmission() {
                            return this._transmission
                        }
                        set transmission(t) {
                            this._transmission > 0 != t > 0 && this.version++, this._transmission = t
                        }
                        copy(t) {
                            return super.copy(t), this.defines = {
                                STANDARD: "",
                                PHYSICAL: ""
                            }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                        }
                    }
                    class Yc extends Gn {
                        constructor(t) {
                            super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new kn(16777215), this.specular = new kn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new on, this.combine = E, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                        }
                    }
                    class Jc extends Gn {
                        constructor(t) {
                            super(), this.isMeshToonMaterial = !0, this.defines = {
                                TOON: ""
                            }, this.type = "MeshToonMaterial", this.color = new kn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
                        }
                    }
                    class Zc extends Gn {
                        constructor(t) {
                            super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                        }
                    }
                    class Kc extends Gn {
                        constructor(t) {
                            super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new kn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new on, this.combine = E, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                        }
                    }
                    class Qc extends Gn {
                        constructor(t) {
                            super(), this.isMeshMatcapMaterial = !0, this.defines = {
                                MATCAP: ""
                            }, this.type = "MeshMatcapMaterial", this.color = new kn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.defines = {
                                MATCAP: ""
                            }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this.fog = t.fog, this
                        }
                    }
                    class $c extends th {
                        constructor(t) {
                            super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                        }
                    }

                    function tu(t, e, i) {
                        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    }

                    function eu(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    }

                    function iu(t) {
                        const e = t.length,
                            i = new Array(e);
                        for (let t = 0; t !== e; ++t) i[t] = t;
                        return i.sort((function(e, i) {
                            return t[e] - t[i]
                        })), i
                    }

                    function nu(t, e, i) {
                        const n = t.length,
                            r = new t.constructor(n);
                        for (let s = 0, a = 0; a !== n; ++s) {
                            const n = i[s] * e;
                            for (let i = 0; i !== e; ++i) r[a++] = t[n + i]
                        }
                        return r
                    }

                    function ru(t, e, i, n) {
                        let r = 1,
                            s = t[0];
                        for (; void 0 !== s && void 0 === s[n];) s = t[r++];
                        if (void 0 === s) return;
                        let a = s[n];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do {
                                    a = s[n], void 0 !== a && (e.push(s.time), i.push.apply(i, a)), s = t[r++]
                                } while (void 0 !== s);
                            else if (void 0 !== a.toArray)
                            do {
                                a = s[n], void 0 !== a && (e.push(s.time), a.toArray(i, i.length)), s = t[r++]
                            } while (void 0 !== s);
                        else
                            do {
                                a = s[n], void 0 !== a && (e.push(s.time), i.push(a)), s = t[r++]
                            } while (void 0 !== s)
                    }
                    const su = {
                        convertArray: tu,
                        isTypedArray: eu,
                        getKeyframeOrder: iu,
                        sortedArray: nu,
                        flattenJSON: ru,
                        subclip: function(t, e, i, n, r = 30) {
                            const s = t.clone();
                            s.name = e;
                            const a = [];
                            for (let t = 0; t < s.tracks.length; ++t) {
                                const e = s.tracks[t],
                                    o = e.getValueSize(),
                                    l = [],
                                    h = [];
                                for (let t = 0; t < e.times.length; ++t) {
                                    const s = e.times[t] * r;
                                    if (!(s < i || s >= n)) {
                                        l.push(e.times[t]);
                                        for (let i = 0; i < o; ++i) h.push(e.values[t * o + i])
                                    }
                                }
                                0 !== l.length && (e.times = tu(l, e.times.constructor), e.values = tu(h, e.values.constructor), a.push(e))
                            }
                            s.tracks = a;
                            let o = 1 / 0;
                            for (let t = 0; t < s.tracks.length; ++t) o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                            for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
                            return s.resetDuration(), s
                        },
                        makeClipAdditive: function(t, e = 0, i = t, n = 30) {
                            n <= 0 && (n = 30);
                            const r = i.tracks.length,
                                s = e / n;
                            for (let e = 0; e < r; ++e) {
                                const n = i.tracks[e],
                                    r = n.ValueTypeName;
                                if ("bool" === r || "string" === r) continue;
                                const a = t.tracks.find((function(t) {
                                    return t.name === n.name && t.ValueTypeName === r
                                }));
                                if (void 0 === a) continue;
                                let o = 0;
                                const l = n.getValueSize();
                                n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                                let h = 0;
                                const c = a.getValueSize();
                                a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
                                const u = n.times.length - 1;
                                let d;
                                if (s <= n.times[0]) {
                                    const t = o,
                                        e = l - o;
                                    d = n.values.slice(t, e)
                                } else if (s >= n.times[u]) {
                                    const t = u * l + o,
                                        e = t + l - o;
                                    d = n.values.slice(t, e)
                                } else {
                                    const t = n.createInterpolant(),
                                        e = o,
                                        i = l - o;
                                    t.evaluate(s), d = t.resultBuffer.slice(e, i)
                                }
                                "quaternion" === r && (new yi).fromArray(d).normalize().conjugate().toArray(d);
                                const p = a.times.length;
                                for (let t = 0; t < p; ++t) {
                                    const e = t * c + h;
                                    if ("quaternion" === r) yi.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                                    else {
                                        const t = c - 2 * h;
                                        for (let i = 0; i < t; ++i) a.values[e + i] -= d[i]
                                    }
                                }
                            }
                            return t.blendMode = he, t
                        }
                    };
                    class au {
                        constructor(t, e, i, n) {
                            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
                        }
                        evaluate(t) {
                            const e = this.parameterPositions;
                            let i = this._cachedIndex,
                                n = e[i],
                                r = e[i - 1];
                            t: {
                                e: {
                                    let s;i: {
                                        n: if (!(t < n)) {
                                            for (let s = i + 2;;) {
                                                if (void 0 === n) {
                                                    if (t < r) break n;
                                                    return i = e.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                                                }
                                                if (i === s) break;
                                                if (r = n, n = e[++i], t < n) break e
                                            }
                                            s = e.length;
                                            break i
                                        }if (t >= r) break t;
                                        {
                                            const a = e[1];
                                            t < a && (i = 2, r = a);
                                            for (let s = i - 2;;) {
                                                if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                                if (i === s) break;
                                                if (n = r, r = e[--i - 1], t >= r) break e
                                            }
                                            s = i, i = 0
                                        }
                                    }
                                    for (; i < s;) {
                                        const n = i + s >>> 1;
                                        t < e[n] ? s = n : i = n + 1
                                    }
                                    if (n = e[i], r = e[i - 1], void 0 === r) return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                    if (void 0 === n) return i = e.length,
                                    this._cachedIndex = i,
                                    this.copySampleValue_(i - 1)
                                }
                                this._cachedIndex = i,
                                this.intervalChanged_(i, r, n)
                            }
                            return this.interpolate_(i, r, t, n)
                        }
                        getSettings_() {
                            return this.settings || this.DefaultSettings_
                        }
                        copySampleValue_(t) {
                            const e = this.resultBuffer,
                                i = this.sampleValues,
                                n = this.valueSize,
                                r = t * n;
                            for (let t = 0; t !== n; ++t) e[t] = i[r + t];
                            return e
                        }
                        interpolate_() {
                            throw new Error("call to abstract method")
                        }
                        intervalChanged_() {}
                    }
                    class ou extends au {
                        constructor(t, e, i, n) {
                            super(t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                                endingStart: ae,
                                endingEnd: ae
                            }
                        }
                        intervalChanged_(t, e, i) {
                            const n = this.parameterPositions;
                            let r = t - 2,
                                s = t + 1,
                                a = n[r],
                                o = n[s];
                            if (void 0 === a) switch (this.getSettings_().endingStart) {
                                case oe:
                                    r = t, a = 2 * e - i;
                                    break;
                                case le:
                                    r = n.length - 2, a = e + n[r] - n[r + 1];
                                    break;
                                default:
                                    r = t, a = i
                            }
                            if (void 0 === o) switch (this.getSettings_().endingEnd) {
                                case oe:
                                    s = t, o = 2 * i - e;
                                    break;
                                case le:
                                    s = 1, o = i + n[1] - n[0];
                                    break;
                                default:
                                    s = t - 1, o = e
                            }
                            const l = .5 * (i - e),
                                h = this.valueSize;
                            this._weightPrev = l / (e - a), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = s * h
                        }
                        interpolate_(t, e, i, n) {
                            const r = this.resultBuffer,
                                s = this.sampleValues,
                                a = this.valueSize,
                                o = t * a,
                                l = o - a,
                                h = this._offsetPrev,
                                c = this._offsetNext,
                                u = this._weightPrev,
                                d = this._weightNext,
                                p = (i - e) / (n - e),
                                m = p * p,
                                f = m * p,
                                g = -u * f + 2 * u * m - u * p,
                                v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                                _ = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                                y = d * f - d * m;
                            for (let t = 0; t !== a; ++t) r[t] = g * s[h + t] + v * s[l + t] + _ * s[o + t] + y * s[c + t];
                            return r
                        }
                    }
                    class lu extends au {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                        interpolate_(t, e, i, n) {
                            const r = this.resultBuffer,
                                s = this.sampleValues,
                                a = this.valueSize,
                                o = t * a,
                                l = o - a,
                                h = (i - e) / (n - e),
                                c = 1 - h;
                            for (let t = 0; t !== a; ++t) r[t] = s[l + t] * c + s[o + t] * h;
                            return r
                        }
                    }
                    class hu extends au {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                        interpolate_(t) {
                            return this.copySampleValue_(t - 1)
                        }
                    }
                    class cu {
                        constructor(t, e, i, n) {
                            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                            this.name = t, this.times = tu(e, this.TimeBufferType), this.values = tu(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
                        }
                        static toJSON(t) {
                            const e = t.constructor;
                            let i;
                            if (e.toJSON !== this.toJSON) i = e.toJSON(t);
                            else {
                                i = {
                                    name: t.name,
                                    times: tu(t.times, Array),
                                    values: tu(t.values, Array)
                                };
                                const e = t.getInterpolation();
                                e !== t.DefaultInterpolation && (i.interpolation = e)
                            }
                            return i.type = t.ValueTypeName, i
                        }
                        InterpolantFactoryMethodDiscrete(t) {
                            return new hu(this.times, this.values, this.getValueSize(), t)
                        }
                        InterpolantFactoryMethodLinear(t) {
                            return new lu(this.times, this.values, this.getValueSize(), t)
                        }
                        InterpolantFactoryMethodSmooth(t) {
                            return new ou(this.times, this.values, this.getValueSize(), t)
                        }
                        setInterpolation(t) {
                            let e;
                            switch (t) {
                                case ne:
                                    e = this.InterpolantFactoryMethodDiscrete;
                                    break;
                                case re:
                                    e = this.InterpolantFactoryMethodLinear;
                                    break;
                                case se:
                                    e = this.InterpolantFactoryMethodSmooth
                            }
                            if (void 0 === e) {
                                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                                if (void 0 === this.createInterpolant) {
                                    if (t === this.DefaultInterpolation) throw new Error(e);
                                    this.setInterpolation(this.DefaultInterpolation)
                                }
                                return console.warn("THREE.KeyframeTrack:", e), this
                            }
                            return this.createInterpolant = e, this
                        }
                        getInterpolation() {
                            switch (this.createInterpolant) {
                                case this.InterpolantFactoryMethodDiscrete:
                                    return ne;
                                case this.InterpolantFactoryMethodLinear:
                                    return re;
                                case this.InterpolantFactoryMethodSmooth:
                                    return se
                            }
                        }
                        getValueSize() {
                            return this.values.length / this.times.length
                        }
                        shift(t) {
                            if (0 !== t) {
                                const e = this.times;
                                for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
                            }
                            return this
                        }
                        scale(t) {
                            if (1 !== t) {
                                const e = this.times;
                                for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
                            }
                            return this
                        }
                        trim(t, e) {
                            const i = this.times,
                                n = i.length;
                            let r = 0,
                                s = n - 1;
                            for (; r !== n && i[r] < t;) ++r;
                            for (; - 1 !== s && i[s] > e;) --s;
                            if (++s, 0 !== r || s !== n) {
                                r >= s && (s = Math.max(s, 1), r = s - 1);
                                const t = this.getValueSize();
                                this.times = i.slice(r, s), this.values = this.values.slice(r * t, s * t)
                            }
                            return this
                        }
                        validate() {
                            let t = !0;
                            const e = this.getValueSize();
                            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                            const i = this.times,
                                n = this.values,
                                r = i.length;
                            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                            let s = null;
                            for (let e = 0; e !== r; e++) {
                                const n = i[e];
                                if ("number" == typeof n && isNaN(n)) {
                                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), t = !1;
                                    break
                                }
                                if (null !== s && s > n) {
                                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, s), t = !1;
                                    break
                                }
                                s = n
                            }
                            if (void 0 !== n && eu(n))
                                for (let e = 0, i = n.length; e !== i; ++e) {
                                    const i = n[e];
                                    if (isNaN(i)) {
                                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i), t = !1;
                                        break
                                    }
                                }
                            return t
                        }
                        optimize() {
                            const t = this.times.slice(),
                                e = this.values.slice(),
                                i = this.getValueSize(),
                                n = this.getInterpolation() === se,
                                r = t.length - 1;
                            let s = 1;
                            for (let a = 1; a < r; ++a) {
                                let r = !1;
                                const o = t[a];
                                if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                                    if (n) r = !0;
                                    else {
                                        const t = a * i,
                                            n = t - i,
                                            s = t + i;
                                        for (let a = 0; a !== i; ++a) {
                                            const i = e[t + a];
                                            if (i !== e[n + a] || i !== e[s + a]) {
                                                r = !0;
                                                break
                                            }
                                        }
                                    } if (r) {
                                    if (a !== s) {
                                        t[s] = t[a];
                                        const n = a * i,
                                            r = s * i;
                                        for (let t = 0; t !== i; ++t) e[r + t] = e[n + t]
                                    }++s
                                }
                            }
                            if (r > 0) {
                                t[s] = t[r];
                                for (let t = r * i, n = s * i, a = 0; a !== i; ++a) e[n + a] = e[t + a];
                                ++s
                            }
                            return s !== t.length ? (this.times = t.slice(0, s), this.values = e.slice(0, s * i)) : (this.times = t, this.values = e), this
                        }
                        clone() {
                            const t = this.times.slice(),
                                e = this.values.slice(),
                                i = new(0, this.constructor)(this.name, t, e);
                            return i.createInterpolant = this.createInterpolant, i
                        }
                    }
                    cu.prototype.TimeBufferType = Float32Array, cu.prototype.ValueBufferType = Float32Array, cu.prototype.DefaultInterpolation = re;
                    class uu extends cu {
                        constructor(t, e, i) {
                            super(t, e, i)
                        }
                    }
                    uu.prototype.ValueTypeName = "bool", uu.prototype.ValueBufferType = Array, uu.prototype.DefaultInterpolation = ne, uu.prototype.InterpolantFactoryMethodLinear = void 0, uu.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class du extends cu {}
                    du.prototype.ValueTypeName = "color";
                    class pu extends cu {}
                    pu.prototype.ValueTypeName = "number";
                    class mu extends au {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                        interpolate_(t, e, i, n) {
                            const r = this.resultBuffer,
                                s = this.sampleValues,
                                a = this.valueSize,
                                o = (i - e) / (n - e);
                            let l = t * a;
                            for (let t = l + a; l !== t; l += 4) yi.slerpFlat(r, 0, s, l - a, s, l, o);
                            return r
                        }
                    }
                    class fu extends cu {
                        InterpolantFactoryMethodLinear(t) {
                            return new mu(this.times, this.values, this.getValueSize(), t)
                        }
                    }
                    fu.prototype.ValueTypeName = "quaternion", fu.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class gu extends cu {
                        constructor(t, e, i) {
                            super(t, e, i)
                        }
                    }
                    gu.prototype.ValueTypeName = "string", gu.prototype.ValueBufferType = Array, gu.prototype.DefaultInterpolation = ne, gu.prototype.InterpolantFactoryMethodLinear = void 0, gu.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class vu extends cu {}
                    vu.prototype.ValueTypeName = "vector";
                    class _u {
                        constructor(t = "", e = -1, i = [], n = 2500) {
                            this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = Be(), this.duration < 0 && this.resetDuration()
                        }
                        static parse(t) {
                            const e = [],
                                i = t.tracks,
                                n = 1 / (t.fps || 1);
                            for (let t = 0, r = i.length; t !== r; ++t) e.push(yu(i[t]).scale(n));
                            const r = new this(t.name, t.duration, e, t.blendMode);
                            return r.uuid = t.uuid, r
                        }
                        static toJSON(t) {
                            const e = [],
                                i = t.tracks,
                                n = {
                                    name: t.name,
                                    duration: t.duration,
                                    tracks: e,
                                    uuid: t.uuid,
                                    blendMode: t.blendMode
                                };
                            for (let t = 0, n = i.length; t !== n; ++t) e.push(cu.toJSON(i[t]));
                            return n
                        }
                        static CreateFromMorphTargetSequence(t, e, i, n) {
                            const r = e.length,
                                s = [];
                            for (let t = 0; t < r; t++) {
                                let a = [],
                                    o = [];
                                a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
                                const l = iu(a);
                                a = nu(a, 1, l), o = nu(o, 1, l), n || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new pu(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / i))
                            }
                            return new this(t, -1, s)
                        }
                        static findByName(t, e) {
                            let i = t;
                            if (!Array.isArray(t)) {
                                const e = t;
                                i = e.geometry && e.geometry.animations || e.animations
                            }
                            for (let t = 0; t < i.length; t++)
                                if (i[t].name === e) return i[t];
                            return null
                        }
                        static CreateClipsFromMorphTargetSequences(t, e, i) {
                            const n = {},
                                r = /^([\w-]*?)([\d]+)$/;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e],
                                    s = i.name.match(r);
                                if (s && s.length > 1) {
                                    const t = s[1];
                                    let e = n[t];
                                    e || (n[t] = e = []), e.push(i)
                                }
                            }
                            const s = [];
                            for (const t in n) s.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
                            return s
                        }
                        static parseAnimation(t, e) {
                            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                            const i = function(t, e, i, n, r) {
                                    if (0 !== i.length) {
                                        const s = [],
                                            a = [];
                                        ru(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a))
                                    }
                                },
                                n = [],
                                r = t.name || "default",
                                s = t.fps || 30,
                                a = t.blendMode;
                            let o = t.length || -1;
                            const l = t.hierarchy || [];
                            for (let t = 0; t < l.length; t++) {
                                const r = l[t].keys;
                                if (r && 0 !== r.length)
                                    if (r[0].morphTargets) {
                                        const t = {};
                                        let e;
                                        for (e = 0; e < r.length; e++)
                                            if (r[e].morphTargets)
                                                for (let i = 0; i < r[e].morphTargets.length; i++) t[r[e].morphTargets[i]] = -1;
                                        for (const i in t) {
                                            const t = [],
                                                s = [];
                                            for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                                                const n = r[e];
                                                t.push(n.time), s.push(n.morphTarget === i ? 1 : 0)
                                            }
                                            n.push(new pu(".morphTargetInfluence[" + i + "]", t, s))
                                        }
                                        o = t.length * s
                                    } else {
                                        const s = ".bones[" + e[t].name + "]";
                                        i(vu, s + ".position", r, "pos", n), i(fu, s + ".quaternion", r, "rot", n), i(vu, s + ".scale", r, "scl", n)
                                    }
                            }
                            return 0 === n.length ? null : new this(r, o, n, a)
                        }
                        resetDuration() {
                            let t = 0;
                            for (let e = 0, i = this.tracks.length; e !== i; ++e) {
                                const i = this.tracks[e];
                                t = Math.max(t, i.times[i.times.length - 1])
                            }
                            return this.duration = t, this
                        }
                        trim() {
                            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                            return this
                        }
                        validate() {
                            let t = !0;
                            for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                            return t
                        }
                        optimize() {
                            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                            return this
                        }
                        clone() {
                            const t = [];
                            for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                            return new this.constructor(this.name, this.duration, t, this.blendMode)
                        }
                        toJSON() {
                            return this.constructor.toJSON(this)
                        }
                    }

                    function yu(t) {
                        if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        const e = function(t) {
                            switch (t.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return pu;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return vu;
                                case "color":
                                    return du;
                                case "quaternion":
                                    return fu;
                                case "bool":
                                case "boolean":
                                    return uu;
                                case "string":
                                    return gu
                            }
                            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                        }(t.type);
                        if (void 0 === t.times) {
                            const e = [],
                                i = [];
                            ru(t.keys, e, i, "value"), t.times = e, t.values = i
                        }
                        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                    }
                    const xu = {
                        enabled: !1,
                        files: {},
                        add: function(t, e) {
                            !1 !== this.enabled && (this.files[t] = e)
                        },
                        get: function(t) {
                            if (!1 !== this.enabled) return this.files[t]
                        },
                        remove: function(t) {
                            delete this.files[t]
                        },
                        clear: function() {
                            this.files = {}
                        }
                    };
                    class Mu {
                        constructor(t, e, i) {
                            const n = this;
                            let r, s = !1,
                                a = 0,
                                o = 0;
                            const l = [];
                            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                                o++, !1 === s && void 0 !== n.onStart && n.onStart(t, a, o), s = !0
                            }, this.itemEnd = function(t) {
                                a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (s = !1, void 0 !== n.onLoad && n.onLoad())
                            }, this.itemError = function(t) {
                                void 0 !== n.onError && n.onError(t)
                            }, this.resolveURL = function(t) {
                                return r ? r(t) : t
                            }, this.setURLModifier = function(t) {
                                return r = t, this
                            }, this.addHandler = function(t, e) {
                                return l.push(t, e), this
                            }, this.removeHandler = function(t) {
                                const e = l.indexOf(t);
                                return -1 !== e && l.splice(e, 2), this
                            }, this.getHandler = function(t) {
                                for (let e = 0, i = l.length; e < i; e += 2) {
                                    const i = l[e],
                                        n = l[e + 1];
                                    if (i.global && (i.lastIndex = 0), i.test(t)) return n
                                }
                                return null
                            }
                        }
                    }
                    const bu = new Mu;
                    class Su {
                        constructor(t) {
                            this.manager = void 0 !== t ? t : bu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                        }
                        load() {}
                        loadAsync(t, e) {
                            const i = this;
                            return new Promise((function(n, r) {
                                i.load(t, n, e, r)
                            }))
                        }
                        parse() {}
                        setCrossOrigin(t) {
                            return this.crossOrigin = t, this
                        }
                        setWithCredentials(t) {
                            return this.withCredentials = t, this
                        }
                        setPath(t) {
                            return this.path = t, this
                        }
                        setResourcePath(t) {
                            return this.resourcePath = t, this
                        }
                        setRequestHeader(t) {
                            return this.requestHeader = t, this
                        }
                    }
                    Su.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                    const wu = {};
                    class Au extends Error {
                        constructor(t, e) {
                            super(t), this.response = e
                        }
                    }
                    class Tu extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                            const r = xu.get(t);
                            if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                                e && e(r), this.manager.itemEnd(t)
                            }), 0), r;
                            if (void 0 !== wu[t]) return void wu[t].push({
                                onLoad: e,
                                onProgress: i,
                                onError: n
                            });
                            wu[t] = [], wu[t].push({
                                onLoad: e,
                                onProgress: i,
                                onError: n
                            });
                            const s = new Request(t, {
                                    headers: new Headers(this.requestHeader),
                                    credentials: this.withCredentials ? "include" : "same-origin"
                                }),
                                a = this.mimeType,
                                o = this.responseType;
                            fetch(s).then((e => {
                                if (200 === e.status || 0 === e.status) {
                                    if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                                    const i = wu[t],
                                        n = e.body.getReader(),
                                        r = e.headers.get("X-File-Size") || e.headers.get("Content-Length"),
                                        s = r ? parseInt(r) : 0,
                                        a = 0 !== s;
                                    let o = 0;
                                    const l = new ReadableStream({
                                        start(t) {
                                            ! function e() {
                                                n.read().then((({
                                                    done: n,
                                                    value: r
                                                }) => {
                                                    if (n) t.close();
                                                    else {
                                                        o += r.byteLength;
                                                        const n = new ProgressEvent("progress", {
                                                            lengthComputable: a,
                                                            loaded: o,
                                                            total: s
                                                        });
                                                        for (let t = 0, e = i.length; t < e; t++) {
                                                            const e = i[t];
                                                            e.onProgress && e.onProgress(n)
                                                        }
                                                        t.enqueue(r), e()
                                                    }
                                                }), (e => {
                                                    t.error(e)
                                                }))
                                            }()
                                        }
                                    });
                                    return new Response(l)
                                }
                                throw new Au(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                            })).then((t => {
                                switch (o) {
                                    case "arraybuffer":
                                        return t.arrayBuffer();
                                    case "blob":
                                        return t.blob();
                                    case "document":
                                        return t.text().then((t => (new DOMParser).parseFromString(t, a)));
                                    case "json":
                                        return t.json();
                                    default:
                                        if (void 0 === a) return t.text();
                                        {
                                            const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                                i = e && e[1] ? e[1].toLowerCase() : void 0,
                                                n = new TextDecoder(i);
                                            return t.arrayBuffer().then((t => n.decode(t)))
                                        }
                                }
                            })).then((e => {
                                xu.add(t, e);
                                const i = wu[t];
                                delete wu[t];
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    n.onLoad && n.onLoad(e)
                                }
                            })).catch((e => {
                                const i = wu[t];
                                if (void 0 === i) throw this.manager.itemError(t), e;
                                delete wu[t];
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    n.onError && n.onError(e)
                                }
                                this.manager.itemError(t)
                            })).finally((() => {
                                this.manager.itemEnd(t)
                            })), this.manager.itemStart(t)
                        }
                        setResponseType(t) {
                            return this.responseType = t, this
                        }
                        setMimeType(t) {
                            return this.mimeType = t, this
                        }
                    }
                    class Eu extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                            const r = this,
                                s = xu.get(t);
                            if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                                e && e(s), r.manager.itemEnd(t)
                            }), 0), s;
                            const a = Ze("img");

                            function o() {
                                h(), xu.add(t, this), e && e(this), r.manager.itemEnd(t)
                            }

                            function l(e) {
                                h(), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                            }

                            function h() {
                                a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                            }
                            return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                        }
                    }
                    class Cu extends wn {
                        constructor(t, e = 1) {
                            super(), this.isLight = !0, this.type = "Light", this.color = new kn(t), this.intensity = e
                        }
                        dispose() {}
                        copy(t, e) {
                            return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (e.object.target = this.target.uuid), e
                        }
                    }
                    class Ru extends Cu {
                        constructor(t, e, i) {
                            super(t, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(wn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new kn(e)
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.groundColor.copy(t.groundColor), this
                        }
                    }
                    const Pu = new Zi,
                        Iu = new xi,
                        Lu = new xi;
                    class Uu {
                        constructor(t) {
                            this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new We(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Zr, this._frameExtents = new We(1, 1), this._viewportCount = 1, this._viewports = [new mi(0, 0, 1, 1)]
                        }
                        getViewportCount() {
                            return this._viewportCount
                        }
                        getFrustum() {
                            return this._frustum
                        }
                        updateMatrices(t) {
                            const e = this.camera,
                                i = this.matrix;
                            Iu.setFromMatrixPosition(t.matrixWorld), e.position.copy(Iu), Lu.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Lu), e.updateMatrixWorld(), Pu.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Pu), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(Pu)
                        }
                        getViewport(t) {
                            return this._viewports[t]
                        }
                        getFrameExtents() {
                            return this._frameExtents
                        }
                        dispose() {
                            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                        }
                        copy(t) {
                            return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        toJSON() {
                            const t = {};
                            return 1 !== this.intensity && (t.intensity = this.intensity), 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                        }
                    }
                    class Nu extends Uu {
                        constructor() {
                            super(new Fr(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                        }
                        updateMatrices(t) {
                            const e = this.camera,
                                i = 2 * Oe * t.angle * this.focus,
                                n = this.mapSize.width / this.mapSize.height,
                                r = t.distance || e.far;
                            i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                        }
                        copy(t) {
                            return super.copy(t), this.focus = t.focus, this
                        }
                    }
                    class Du extends Cu {
                        constructor(t, e, i = 0, n = Math.PI / 3, r = 0, s = 2) {
                            super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(wn.DEFAULT_UP), this.updateMatrix(), this.target = new wn, this.distance = i, this.angle = n, this.penumbra = r, this.decay = s, this.map = null, this.shadow = new Nu
                        }
                        get power() {
                            return this.intensity * Math.PI
                        }
                        set power(t) {
                            this.intensity = t / Math.PI
                        }
                        dispose() {
                            this.shadow.dispose()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                        }
                    }
                    const Ou = new Zi,
                        Bu = new xi,
                        zu = new xi;
                    class Fu extends Uu {
                        constructor() {
                            super(new Fr(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new We(4, 2), this._viewportCount = 6, this._viewports = [new mi(2, 1, 1, 1), new mi(0, 1, 1, 1), new mi(3, 1, 1, 1), new mi(1, 1, 1, 1), new mi(3, 0, 1, 1), new mi(1, 0, 1, 1)], this._cubeDirections = [new xi(1, 0, 0), new xi(-1, 0, 0), new xi(0, 0, 1), new xi(0, 0, -1), new xi(0, 1, 0), new xi(0, -1, 0)], this._cubeUps = [new xi(0, 1, 0), new xi(0, 1, 0), new xi(0, 1, 0), new xi(0, 1, 0), new xi(0, 0, 1), new xi(0, 0, -1)]
                        }
                        updateMatrices(t, e = 0) {
                            const i = this.camera,
                                n = this.matrix,
                                r = t.distance || i.far;
                            r !== i.far && (i.far = r, i.updateProjectionMatrix()), Bu.setFromMatrixPosition(t.matrixWorld), i.position.copy(Bu), zu.copy(i.position), zu.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(zu), i.updateMatrixWorld(), n.makeTranslation(-Bu.x, -Bu.y, -Bu.z), Ou.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ou)
                        }
                    }
                    class ku extends Cu {
                        constructor(t, e, i = 0, n = 2) {
                            super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new Fu
                        }
                        get power() {
                            return 4 * this.intensity * Math.PI
                        }
                        set power(t) {
                            this.intensity = t / (4 * Math.PI)
                        }
                        dispose() {
                            this.shadow.dispose()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                        }
                    }
                    class Vu extends Uu {
                        constructor() {
                            super(new ds(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                        }
                    }
                    class Hu extends Cu {
                        constructor(t, e) {
                            super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(wn.DEFAULT_UP), this.updateMatrix(), this.target = new wn, this.shadow = new Vu
                        }
                        dispose() {
                            this.shadow.dispose()
                        }
                        copy(t) {
                            return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                        }
                    }
                    class Gu extends Cu {
                        constructor(t, e) {
                            super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
                        }
                    }
                    class Wu extends Cu {
                        constructor(t, e, i = 10, n = 10) {
                            super(t, e), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = n
                        }
                        get power() {
                            return this.intensity * this.width * this.height * Math.PI
                        }
                        set power(t) {
                            this.intensity = t / (this.width * this.height * Math.PI)
                        }
                        copy(t) {
                            return super.copy(t), this.width = t.width, this.height = t.height, this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return e.object.width = this.width, e.object.height = this.height, e
                        }
                    }
                    class ju {
                        constructor() {
                            this.isSphericalHarmonics3 = !0, this.coefficients = [];
                            for (let t = 0; t < 9; t++) this.coefficients.push(new xi)
                        }
                        set(t) {
                            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                            return this
                        }
                        zero() {
                            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                            return this
                        }
                        getAt(t, e) {
                            const i = t.x,
                                n = t.y,
                                r = t.z,
                                s = this.coefficients;
                            return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * n), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * i), e.addScaledVector(s[4], i * n * 1.092548), e.addScaledVector(s[5], n * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], i * r * 1.092548), e.addScaledVector(s[8], .546274 * (i * i - n * n)), e
                        }
                        getIrradianceAt(t, e) {
                            const i = t.x,
                                n = t.y,
                                r = t.z,
                                s = this.coefficients;
                            return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * n), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * i), e.addScaledVector(s[4], .858086 * i * n), e.addScaledVector(s[5], .858086 * n * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * i * r), e.addScaledVector(s[8], .429043 * (i * i - n * n)), e
                        }
                        add(t) {
                            for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                            return this
                        }
                        addScaledSH(t, e) {
                            for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
                            return this
                        }
                        scale(t) {
                            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                            return this
                        }
                        lerp(t, e) {
                            for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                            return this
                        }
                        equals(t) {
                            for (let e = 0; e < 9; e++)
                                if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                            return !0
                        }
                        copy(t) {
                            return this.set(t.coefficients)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        fromArray(t, e = 0) {
                            const i = this.coefficients;
                            for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
                            return this
                        }
                        toArray(t = [], e = 0) {
                            const i = this.coefficients;
                            for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
                            return t
                        }
                        static getBasisAt(t, e) {
                            const i = t.x,
                                n = t.y,
                                r = t.z;
                            e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * r, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * i * r, e[8] = .546274 * (i * i - n * n)
                        }
                    }
                    class Xu extends Cu {
                        constructor(t = new ju, e = 1) {
                            super(void 0, e), this.isLightProbe = !0, this.sh = t
                        }
                        copy(t) {
                            return super.copy(t), this.sh.copy(t.sh), this
                        }
                        fromJSON(t) {
                            return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return e.object.sh = this.sh.toArray(), e
                        }
                    }
                    class qu extends Su {
                        constructor(t) {
                            super(t), this.textures = {}
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = new Tu(r.manager);
                            s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(i) {
                                try {
                                    e(r.parse(JSON.parse(i)))
                                } catch (e) {
                                    n ? n(e) : console.error(e), r.manager.itemError(t)
                                }
                            }), i, n)
                        }
                        parse(t) {
                            const e = this.textures;

                            function i(t) {
                                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                            }
                            const n = qu.createMaterialFromType(t.type);
                            if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && void 0 !== n.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.sheen && (n.sheen = t.sheen), void 0 !== t.sheenColor && (n.sheenColor = (new kn).setHex(t.sheenColor)), void 0 !== t.sheenRoughness && (n.sheenRoughness = t.sheenRoughness), void 0 !== t.emissive && void 0 !== n.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== n.specular && n.specular.setHex(t.specular), void 0 !== t.specularIntensity && (n.specularIntensity = t.specularIntensity), void 0 !== t.specularColor && void 0 !== n.specularColor && n.specularColor.setHex(t.specularColor), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearcoat && (n.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (n.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.dispersion && (n.dispersion = t.dispersion), void 0 !== t.iridescence && (n.iridescence = t.iridescence), void 0 !== t.iridescenceIOR && (n.iridescenceIOR = t.iridescenceIOR), void 0 !== t.iridescenceThicknessRange && (n.iridescenceThicknessRange = t.iridescenceThicknessRange), void 0 !== t.transmission && (n.transmission = t.transmission), void 0 !== t.thickness && (n.thickness = t.thickness), void 0 !== t.attenuationDistance && (n.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationColor && void 0 !== n.attenuationColor && n.attenuationColor.setHex(t.attenuationColor), void 0 !== t.anisotropy && (n.anisotropy = t.anisotropy), void 0 !== t.anisotropyRotation && (n.anisotropyRotation = t.anisotropyRotation), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n.side = t.side), void 0 !== t.shadowSide && (n.shadowSide = t.shadowSide), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.alphaHash && (n.alphaHash = t.alphaHash), void 0 !== t.depthFunc && (n.depthFunc = t.depthFunc), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.blendSrc && (n.blendSrc = t.blendSrc), void 0 !== t.blendDst && (n.blendDst = t.blendDst), void 0 !== t.blendEquation && (n.blendEquation = t.blendEquation), void 0 !== t.blendSrcAlpha && (n.blendSrcAlpha = t.blendSrcAlpha), void 0 !== t.blendDstAlpha && (n.blendDstAlpha = t.blendDstAlpha), void 0 !== t.blendEquationAlpha && (n.blendEquationAlpha = t.blendEquationAlpha), void 0 !== t.blendColor && void 0 !== n.blendColor && n.blendColor.setHex(t.blendColor), void 0 !== t.blendAlpha && (n.blendAlpha = t.blendAlpha), void 0 !== t.stencilWriteMask && (n.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (n.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (n.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (n.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (n.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (n.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (n.stencilZPass = t.stencilZPass), void 0 !== t.stencilWrite && (n.stencilWrite = t.stencilWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), void 0 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.alphaToCoverage && (n.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (n.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.forceSinglePass && (n.forceSinglePass = t.forceSinglePass), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.toneMapped && (n.toneMapped = t.toneMapped), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? n.vertexColors = t.vertexColors > 0 : n.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                                for (const e in t.uniforms) {
                                    const r = t.uniforms[e];
                                    switch (n.uniforms[e] = {}, r.type) {
                                        case "t":
                                            n.uniforms[e].value = i(r.value);
                                            break;
                                        case "c":
                                            n.uniforms[e].value = (new kn).setHex(r.value);
                                            break;
                                        case "v2":
                                            n.uniforms[e].value = (new We).fromArray(r.value);
                                            break;
                                        case "v3":
                                            n.uniforms[e].value = (new xi).fromArray(r.value);
                                            break;
                                        case "v4":
                                            n.uniforms[e].value = (new mi).fromArray(r.value);
                                            break;
                                        case "m3":
                                            n.uniforms[e].value = (new je).fromArray(r.value);
                                            break;
                                        case "m4":
                                            n.uniforms[e].value = (new Zi).fromArray(r.value);
                                            break;
                                        default:
                                            n.uniforms[e].value = r.value
                                    }
                                }
                            if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.glslVersion && (n.glslVersion = t.glslVersion), void 0 !== t.extensions)
                                for (const e in t.extensions) n.extensions[e] = t.extensions[e];
                            if (void 0 !== t.lights && (n.lights = t.lights), void 0 !== t.clipping && (n.clipping = t.clipping), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t.map)), void 0 !== t.matcap && (n.matcap = i(t.matcap)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap)), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                                let e = t.normalScale;
                                !1 === Array.isArray(e) && (e = [e, e]), n.normalScale = (new We).fromArray(e)
                            }
                            return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.specularIntensityMap && (n.specularIntensityMap = i(t.specularIntensityMap)), void 0 !== t.specularColorMap && (n.specularColorMap = i(t.specularColorMap)), void 0 !== t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.envMapRotation && n.envMapRotation.fromArray(t.envMapRotation), void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (n.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)), void 0 !== t.clearcoatMap && (n.clearcoatMap = i(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (n.clearcoatRoughnessMap = i(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (n.clearcoatNormalMap = i(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (n.clearcoatNormalScale = (new We).fromArray(t.clearcoatNormalScale)), void 0 !== t.iridescenceMap && (n.iridescenceMap = i(t.iridescenceMap)), void 0 !== t.iridescenceThicknessMap && (n.iridescenceThicknessMap = i(t.iridescenceThicknessMap)), void 0 !== t.transmissionMap && (n.transmissionMap = i(t.transmissionMap)), void 0 !== t.thicknessMap && (n.thicknessMap = i(t.thicknessMap)), void 0 !== t.anisotropyMap && (n.anisotropyMap = i(t.anisotropyMap)), void 0 !== t.sheenColorMap && (n.sheenColorMap = i(t.sheenColorMap)), void 0 !== t.sheenRoughnessMap && (n.sheenRoughnessMap = i(t.sheenRoughnessMap)), n
                        }
                        setTextures(t) {
                            return this.textures = t, this
                        }
                        static createMaterialFromType(t) {
                            return new {
                                ShadowMaterial: Wc,
                                SpriteMaterial: Xo,
                                RawShaderMaterial: jc,
                                ShaderMaterial: Nr,
                                PointsMaterial: mh,
                                MeshPhysicalMaterial: qc,
                                MeshStandardMaterial: Xc,
                                MeshPhongMaterial: Yc,
                                MeshToonMaterial: Jc,
                                MeshNormalMaterial: Zc,
                                MeshLambertMaterial: Kc,
                                MeshDepthMaterial: bo,
                                MeshDistanceMaterial: So,
                                MeshBasicMaterial: Wn,
                                MeshMatcapMaterial: Qc,
                                LineDashedMaterial: $c,
                                LineBasicMaterial: th,
                                Material: Gn
                            } [t]
                        }
                    }
                    class Yu {
                        static decodeText(t) {
                            if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), "undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                            let e = "";
                            for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                            try {
                                return decodeURIComponent(escape(e))
                            } catch (t) {
                                return e
                            }
                        }
                        static extractUrlBase(t) {
                            const e = t.lastIndexOf("/");
                            return -1 === e ? "./" : t.slice(0, e + 1)
                        }
                        static resolveURL(t, e) {
                            return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                        }
                    }
                    class Ju extends hr {
                        constructor() {
                            super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                        }
                        copy(t) {
                            return super.copy(t), this.instanceCount = t.instanceCount, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                        }
                    }
                    class Zu extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = new Tu(r.manager);
                            s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(i) {
                                try {
                                    e(r.parse(JSON.parse(i)))
                                } catch (e) {
                                    n ? n(e) : console.error(e), r.manager.itemError(t)
                                }
                            }), i, n)
                        }
                        parse(t) {
                            const e = {},
                                i = {};

                            function n(t, n) {
                                if (void 0 !== e[n]) return e[n];
                                const r = t.interleavedBuffers[n],
                                    s = function(t, e) {
                                        if (void 0 !== i[e]) return i[e];
                                        const n = t.arrayBuffers[e],
                                            r = new Uint32Array(n).buffer;
                                        return i[e] = r, r
                                    }(t, r.buffer),
                                    a = Je(r.type, s),
                                    o = new Go(a, r.stride);
                                return o.uuid = r.uuid, e[n] = o, o
                            }
                            const r = t.isInstancedBufferGeometry ? new Ju : new hr,
                                s = t.data.index;
                            if (void 0 !== s) {
                                const t = Je(s.type, s.array);
                                r.setIndex(new Qn(t, 1))
                            }
                            const a = t.data.attributes;
                            for (const e in a) {
                                const i = a[e];
                                let s;
                                if (i.isInterleavedBufferAttribute) {
                                    const e = n(t.data, i.data);
                                    s = new jo(e, i.itemSize, i.offset, i.normalized)
                                } else {
                                    const t = Je(i.type, i.array);
                                    s = new(i.isInstancedBufferAttribute ? Tl : Qn)(t, i.itemSize, i.normalized)
                                }
                                void 0 !== i.name && (s.name = i.name), void 0 !== i.usage && s.setUsage(i.usage), r.setAttribute(e, s)
                            }
                            const o = t.data.morphAttributes;
                            if (o)
                                for (const e in o) {
                                    const i = o[e],
                                        s = [];
                                    for (let e = 0, r = i.length; e < r; e++) {
                                        const r = i[e];
                                        let a;
                                        if (r.isInterleavedBufferAttribute) {
                                            const e = n(t.data, r.data);
                                            a = new jo(e, r.itemSize, r.offset, r.normalized)
                                        } else {
                                            const t = Je(r.type, r.array);
                                            a = new Qn(t, r.itemSize, r.normalized)
                                        }
                                        void 0 !== r.name && (a.name = r.name), s.push(a)
                                    }
                                    r.morphAttributes[e] = s
                                }
                            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                            const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                            if (void 0 !== l)
                                for (let t = 0, e = l.length; t !== e; ++t) {
                                    const e = l[t];
                                    r.addGroup(e.start, e.count, e.materialIndex)
                                }
                            const h = t.data.boundingSphere;
                            if (void 0 !== h) {
                                const t = new xi;
                                void 0 !== h.center && t.fromArray(h.center), r.boundingSphere = new Vi(t, h.radius)
                            }
                            return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                        }
                    }
                    const Ku = {
                            UVMapping: k,
                            CubeReflectionMapping: V,
                            CubeRefractionMapping: H,
                            EquirectangularReflectionMapping: G,
                            EquirectangularRefractionMapping: W,
                            CubeUVReflectionMapping: j
                        },
                        Qu = {
                            RepeatWrapping: X,
                            ClampToEdgeWrapping: q,
                            MirroredRepeatWrapping: Y
                        },
                        $u = {
                            NearestFilter: J,
                            NearestMipmapNearestFilter: Z,
                            NearestMipmapLinearFilter: K,
                            LinearFilter: Q,
                            LinearMipmapNearestFilter: $,
                            LinearMipmapLinearFilter: tt
                        };
                    let td;
                    class ed {
                        static getContext() {
                            return void 0 === td && (td = new(window.AudioContext || window.webkitAudioContext)), td
                        }
                        static setContext(t) {
                            td = t
                        }
                    }
                    const id = new Zi,
                        nd = new Zi,
                        rd = new Zi;
                    class sd {
                        constructor(t = !0) {
                            this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                        }
                        start() {
                            this.startTime = ad(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                        }
                        stop() {
                            this.getElapsedTime(), this.running = !1, this.autoStart = !1
                        }
                        getElapsedTime() {
                            return this.getDelta(), this.elapsedTime
                        }
                        getDelta() {
                            let t = 0;
                            if (this.autoStart && !this.running) return this.start(), 0;
                            if (this.running) {
                                const e = ad();
                                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                            }
                            return t
                        }
                    }

                    function ad() {
                        return ("undefined" == typeof performance ? Date : performance).now()
                    }
                    const od = new xi,
                        ld = new yi,
                        hd = new xi,
                        cd = new xi;
                    class ud extends wn {
                        constructor(t) {
                            super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                        }
                        getOutput() {
                            return this.gain
                        }
                        setNodeSource(t) {
                            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                        }
                        setMediaElementSource(t) {
                            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                        }
                        setMediaStreamSource(t) {
                            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                        }
                        setBuffer(t) {
                            return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                        }
                        play(t = 0) {
                            if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                            if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                            this._startedAt = this.context.currentTime + t;
                            const e = this.context.createBufferSource();
                            return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                        pause() {
                            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                        stop() {
                            if (!1 !== this.hasPlaybackControl) return this._progress = 0, null !== this.source && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                        connect() {
                            if (this.filters.length > 0) {
                                this.source.connect(this.filters[0]);
                                for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                                this.filters[this.filters.length - 1].connect(this.getOutput())
                            } else this.source.connect(this.getOutput());
                            return this._connected = !0, this
                        }
                        disconnect() {
                            if (!1 !== this._connected) {
                                if (this.filters.length > 0) {
                                    this.source.disconnect(this.filters[0]);
                                    for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                                } else this.source.disconnect(this.getOutput());
                                return this._connected = !1, this
                            }
                        }
                        getFilters() {
                            return this.filters
                        }
                        setFilters(t) {
                            return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                        }
                        setDetune(t) {
                            return this.detune = t, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                        }
                        getDetune() {
                            return this.detune
                        }
                        getFilter() {
                            return this.getFilters()[0]
                        }
                        setFilter(t) {
                            return this.setFilters(t ? [t] : [])
                        }
                        setPlaybackRate(t) {
                            if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                        getPlaybackRate() {
                            return this.playbackRate
                        }
                        onEnded() {
                            this.isPlaying = !1
                        }
                        getLoop() {
                            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                        }
                        setLoop(t) {
                            if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                        setLoopStart(t) {
                            return this.loopStart = t, this
                        }
                        setLoopEnd(t) {
                            return this.loopEnd = t, this
                        }
                        getVolume() {
                            return this.gain.gain.value
                        }
                        setVolume(t) {
                            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                        }
                    }
                    const dd = new xi,
                        pd = new yi,
                        md = new xi,
                        fd = new xi;
                    class gd {
                        constructor(t, e, i) {
                            let n, r, s;
                            switch (this.binding = t, this.valueSize = i, e) {
                                case "quaternion":
                                    n = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                                    break;
                                case "string":
                                case "bool":
                                    n = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                                    break;
                                default:
                                    n = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
                            }
                            this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                        }
                        accumulate(t, e) {
                            const i = this.buffer,
                                n = this.valueSize,
                                r = t * n + n;
                            let s = this.cumulativeWeight;
                            if (0 === s) {
                                for (let t = 0; t !== n; ++t) i[r + t] = i[t];
                                s = e
                            } else {
                                s += e;
                                const t = e / s;
                                this._mixBufferRegion(i, r, 0, t, n)
                            }
                            this.cumulativeWeight = s
                        }
                        accumulateAdditive(t) {
                            const e = this.buffer,
                                i = this.valueSize,
                                n = i * this._addIndex;
                            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t
                        }
                        apply(t) {
                            const e = this.valueSize,
                                i = this.buffer,
                                n = t * e + e,
                                r = this.cumulativeWeight,
                                s = this.cumulativeWeightAdditive,
                                a = this.binding;
                            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                                const t = e * this._origIndex;
                                this._mixBufferRegion(i, n, t, 1 - r, e)
                            }
                            s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
                            for (let t = e, r = e + e; t !== r; ++t)
                                if (i[t] !== i[t + e]) {
                                    a.setValue(i, n);
                                    break
                                }
                        }
                        saveOriginalState() {
                            const t = this.binding,
                                e = this.buffer,
                                i = this.valueSize,
                                n = i * this._origIndex;
                            t.getValue(e, n);
                            for (let t = i, r = n; t !== r; ++t) e[t] = e[n + t % i];
                            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                        }
                        restoreOriginalState() {
                            const t = 3 * this.valueSize;
                            this.binding.setValue(this.buffer, t)
                        }
                        _setAdditiveIdentityNumeric() {
                            const t = this._addIndex * this.valueSize,
                                e = t + this.valueSize;
                            for (let i = t; i < e; i++) this.buffer[i] = 0
                        }
                        _setAdditiveIdentityQuaternion() {
                            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                        }
                        _setAdditiveIdentityOther() {
                            const t = this._origIndex * this.valueSize,
                                e = this._addIndex * this.valueSize;
                            for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
                        }
                        _select(t, e, i, n, r) {
                            if (n >= .5)
                                for (let n = 0; n !== r; ++n) t[e + n] = t[i + n]
                        }
                        _slerp(t, e, i, n) {
                            yi.slerpFlat(t, e, t, e, t, i, n)
                        }
                        _slerpAdditive(t, e, i, n, r) {
                            const s = this._workIndex * r;
                            yi.multiplyQuaternionsFlat(t, s, t, e, t, i), yi.slerpFlat(t, e, t, e, t, s, n)
                        }
                        _lerp(t, e, i, n, r) {
                            const s = 1 - n;
                            for (let a = 0; a !== r; ++a) {
                                const r = e + a;
                                t[r] = t[r] * s + t[i + a] * n
                            }
                        }
                        _lerpAdditive(t, e, i, n, r) {
                            for (let s = 0; s !== r; ++s) {
                                const r = e + s;
                                t[r] = t[r] + t[i + s] * n
                            }
                        }
                    }
                    const vd = "\\[\\]\\.:\\/",
                        _d = new RegExp("[" + vd + "]", "g"),
                        yd = "[^" + vd + "]",
                        xd = "[^" + vd.replace("\\.", "") + "]",
                        Md = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", yd) + /(WCOD+)?/.source.replace("WCOD", xd) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", yd) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", yd) + "$"),
                        bd = ["material", "materials", "bones", "map"];
                    class Sd {
                        constructor(t, e, i) {
                            this.path = e, this.parsedPath = i || Sd.parseTrackName(e), this.node = Sd.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                        static create(t, e, i) {
                            return t && t.isAnimationObjectGroup ? new Sd.Composite(t, e, i) : new Sd(t, e, i)
                        }
                        static sanitizeNodeName(t) {
                            return t.replace(/\s/g, "_").replace(_d, "")
                        }
                        static parseTrackName(t) {
                            const e = Md.exec(t);
                            if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                            const i = {
                                    nodeName: e[2],
                                    objectName: e[3],
                                    objectIndex: e[4],
                                    propertyName: e[5],
                                    propertyIndex: e[6]
                                },
                                n = i.nodeName && i.nodeName.lastIndexOf(".");
                            if (void 0 !== n && -1 !== n) {
                                const t = i.nodeName.substring(n + 1); - 1 !== bd.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = t)
                            }
                            if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                            return i
                        }
                        static findNode(t, e) {
                            if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                            if (t.skeleton) {
                                const i = t.skeleton.getBoneByName(e);
                                if (void 0 !== i) return i
                            }
                            if (t.children) {
                                const i = function(t) {
                                        for (let n = 0; n < t.length; n++) {
                                            const r = t[n];
                                            if (r.name === e || r.uuid === e) return r;
                                            const s = i(r.children);
                                            if (s) return s
                                        }
                                        return null
                                    },
                                    n = i(t.children);
                                if (n) return n
                            }
                            return null
                        }
                        _getValue_unavailable() {}
                        _setValue_unavailable() {}
                        _getValue_direct(t, e) {
                            t[e] = this.targetObject[this.propertyName]
                        }
                        _getValue_array(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
                        }
                        _getValue_arrayElement(t, e) {
                            t[e] = this.resolvedProperty[this.propertyIndex]
                        }
                        _getValue_toArray(t, e) {
                            this.resolvedProperty.toArray(t, e)
                        }
                        _setValue_direct(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }
                        _setValue_direct_setNeedsUpdate(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }
                        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_array(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                        }
                        _setValue_array_setNeedsUpdate(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }
                        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_arrayElement(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }
                        _setValue_arrayElement_setNeedsUpdate(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }
                        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_fromArray(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }
                        _setValue_fromArray_setNeedsUpdate(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }
                        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _getValue_unbound(t, e) {
                            this.bind(), this.getValue(t, e)
                        }
                        _setValue_unbound(t, e) {
                            this.bind(), this.setValue(t, e)
                        }
                        bind() {
                            let t = this.node;
                            const e = this.parsedPath,
                                i = e.objectName,
                                n = e.propertyName;
                            let r = e.propertyIndex;
                            if (t || (t = Sd.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                            if (i) {
                                let n = e.objectIndex;
                                switch (i) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (let e = 0; e < t.length; e++)
                                            if (t[e].name === n) {
                                                n = e;
                                                break
                                            } break;
                                    case "map":
                                        if ("map" in t) {
                                            t = t.map;
                                            break
                                        }
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                        t = t.material.map;
                                        break;
                                    default:
                                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[i]
                                }
                                if (void 0 !== n) {
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[n]
                                }
                            }
                            const s = t[n];
                            if (void 0 === s) {
                                const i = e.nodeName;
                                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
                            }
                            let a = this.Versioning.None;
                            this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                            let o = this.BindingType.Direct;
                            if (void 0 !== r) {
                                if ("morphTargetInfluences" === n) {
                                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                                }
                                o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                            this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                        }
                        unbind() {
                            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                    }
                    Sd.Composite = class {
                        constructor(t, e, i) {
                            const n = i || Sd.parseTrackName(e);
                            this._targetGroup = t, this._bindings = t.subscribe_(e, n)
                        }
                        getValue(t, e) {
                            this.bind();
                            const i = this._targetGroup.nCachedObjects_,
                                n = this._bindings[i];
                            void 0 !== n && n.getValue(t, e)
                        }
                        setValue(t, e) {
                            const i = this._bindings;
                            for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
                        }
                        bind() {
                            const t = this._bindings;
                            for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                        }
                        unbind() {
                            const t = this._bindings;
                            for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                        }
                    }, Sd.prototype.BindingType = {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    }, Sd.prototype.Versioning = {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    }, Sd.prototype.GetterByBindingType = [Sd.prototype._getValue_direct, Sd.prototype._getValue_array, Sd.prototype._getValue_arrayElement, Sd.prototype._getValue_toArray], Sd.prototype.SetterByBindingTypeAndVersioning = [
                        [Sd.prototype._setValue_direct, Sd.prototype._setValue_direct_setNeedsUpdate, Sd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                        [Sd.prototype._setValue_array, Sd.prototype._setValue_array_setNeedsUpdate, Sd.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                        [Sd.prototype._setValue_arrayElement, Sd.prototype._setValue_arrayElement_setNeedsUpdate, Sd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                        [Sd.prototype._setValue_fromArray, Sd.prototype._setValue_fromArray_setNeedsUpdate, Sd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                    ];
                    class wd {
                        constructor(t, e, i = null, n = e.blendMode) {
                            this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
                            const r = e.tracks,
                                s = r.length,
                                a = new Array(s),
                                o = {
                                    endingStart: ae,
                                    endingEnd: ae
                                };
                            for (let t = 0; t !== s; ++t) {
                                const e = r[t].createInterpolant(null);
                                a[t] = e, e.settings = o
                            }
                            this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                        }
                        play() {
                            return this._mixer._activateAction(this), this
                        }
                        stop() {
                            return this._mixer._deactivateAction(this), this.reset()
                        }
                        reset() {
                            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                        }
                        isRunning() {
                            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                        }
                        isScheduled() {
                            return this._mixer._isActiveAction(this)
                        }
                        startAt(t) {
                            return this._startTime = t, this
                        }
                        setLoop(t, e) {
                            return this.loop = t, this.repetitions = e, this
                        }
                        setEffectiveWeight(t) {
                            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                        }
                        getEffectiveWeight() {
                            return this._effectiveWeight
                        }
                        fadeIn(t) {
                            return this._scheduleFading(t, 0, 1)
                        }
                        fadeOut(t) {
                            return this._scheduleFading(t, 1, 0)
                        }
                        crossFadeFrom(t, e, i) {
                            if (t.fadeOut(e), this.fadeIn(e), i) {
                                const i = this._clip.duration,
                                    n = t._clip.duration,
                                    r = n / i,
                                    s = i / n;
                                t.warp(1, r, e), this.warp(s, 1, e)
                            }
                            return this
                        }
                        crossFadeTo(t, e, i) {
                            return t.crossFadeFrom(this, e, i)
                        }
                        stopFading() {
                            const t = this._weightInterpolant;
                            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                        }
                        setEffectiveTimeScale(t) {
                            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                        }
                        getEffectiveTimeScale() {
                            return this._effectiveTimeScale
                        }
                        setDuration(t) {
                            return this.timeScale = this._clip.duration / t, this.stopWarping()
                        }
                        syncWith(t) {
                            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                        }
                        halt(t) {
                            return this.warp(this._effectiveTimeScale, 0, t)
                        }
                        warp(t, e, i) {
                            const n = this._mixer,
                                r = n.time,
                                s = this.timeScale;
                            let a = this._timeScaleInterpolant;
                            null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
                            const o = a.parameterPositions,
                                l = a.sampleValues;
                            return o[0] = r, o[1] = r + i, l[0] = t / s, l[1] = e / s, this
                        }
                        stopWarping() {
                            const t = this._timeScaleInterpolant;
                            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                        }
                        getMixer() {
                            return this._mixer
                        }
                        getClip() {
                            return this._clip
                        }
                        getRoot() {
                            return this._localRoot || this._mixer._root
                        }
                        _update(t, e, i, n) {
                            if (!this.enabled) return void this._updateWeight(t);
                            const r = this._startTime;
                            if (null !== r) {
                                const n = (t - r) * i;
                                n < 0 || 0 === i ? e = 0 : (this._startTime = null, e = i * n)
                            }
                            e *= this._updateTimeScale(t);
                            const s = this._updateTime(e),
                                a = this._updateWeight(t);
                            if (a > 0) {
                                const t = this._interpolants,
                                    e = this._propertyBindings;
                                if (this.blendMode === he)
                                    for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(s), e[i].accumulateAdditive(a);
                                else
                                    for (let i = 0, r = t.length; i !== r; ++i) t[i].evaluate(s), e[i].accumulate(n, a)
                            }
                        }
                        _updateWeight(t) {
                            let e = 0;
                            if (this.enabled) {
                                e = this.weight;
                                const i = this._weightInterpolant;
                                if (null !== i) {
                                    const n = i.evaluate(t)[0];
                                    e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                                }
                            }
                            return this._effectiveWeight = e, e
                        }
                        _updateTimeScale(t) {
                            let e = 0;
                            if (!this.paused) {
                                e = this.timeScale;
                                const i = this._timeScaleInterpolant;
                                null !== i && (e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                            }
                            return this._effectiveTimeScale = e, e
                        }
                        _updateTime(t) {
                            const e = this._clip.duration,
                                i = this.loop;
                            let n = this.time + t,
                                r = this._loopCount;
                            const s = 2202 === i;
                            if (0 === t) return -1 === r || !s || 1 & ~r ? n : e - n;
                            if (2200 === i) {
                                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                                t: {
                                    if (n >= e) n = e;
                                    else {
                                        if (!(n < 0)) {
                                            this.time = n;
                                            break t
                                        }
                                        n = 0
                                    }
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    this.time = n,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t < 0 ? -1 : 1
                                    })
                                }
                            } else {
                                if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), n >= e || n < 0) {
                                    const i = Math.floor(n / e);
                                    n -= e * i, r += Math.abs(i);
                                    const a = this.repetitions - r;
                                    if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t > 0 ? 1 : -1
                                    });
                                    else {
                                        if (1 === a) {
                                            const e = t < 0;
                                            this._setEndings(e, !e, s)
                                        } else this._setEndings(!1, !1, s);
                                        this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                                            type: "loop",
                                            action: this,
                                            loopDelta: i
                                        })
                                    }
                                } else this.time = n;
                                if (s && !(1 & ~r)) return e - n
                            }
                            return n
                        }
                        _setEndings(t, e, i) {
                            const n = this._interpolantSettings;
                            i ? (n.endingStart = oe, n.endingEnd = oe) : (n.endingStart = t ? this.zeroSlopeAtStart ? oe : ae : le, n.endingEnd = e ? this.zeroSlopeAtEnd ? oe : ae : le)
                        }
                        _scheduleFading(t, e, i) {
                            const n = this._mixer,
                                r = n.time;
                            let s = this._weightInterpolant;
                            null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
                            const a = s.parameterPositions,
                                o = s.sampleValues;
                            return a[0] = r, o[0] = e, a[1] = r + t, o[1] = i, this
                        }
                    }
                    const Ad = new Float32Array(1);
                    class Td {
                        constructor(t) {
                            this.value = t
                        }
                        clone() {
                            return new Td(void 0 === this.value.clone ? this.value : this.value.clone())
                        }
                    }
                    let Ed = 0;
                    const Cd = new Zi;

                    function Rd(t, e) {
                        return t.distance - e.distance
                    }

                    function Pd(t, e, i, n) {
                        let r = !0;
                        if (t.layers.test(e.layers) && !1 === t.raycast(e, i) && (r = !1), !0 === r && !0 === n) {
                            const n = t.children;
                            for (let t = 0, r = n.length; t < r; t++) Pd(n[t], e, i, !0)
                        }
                    }
                    class Id {
                        constructor(t, e, i, n) {
                            Id.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], void 0 !== t && this.set(t, e, i, n)
                        }
                        identity() {
                            return this.set(1, 0, 0, 1), this
                        }
                        fromArray(t, e = 0) {
                            for (let i = 0; i < 4; i++) this.elements[i] = t[i + e];
                            return this
                        }
                        set(t, e, i, n) {
                            const r = this.elements;
                            return r[0] = t, r[2] = e, r[1] = i, r[3] = n, this
                        }
                    }
                    const Ld = new We,
                        Ud = new xi,
                        Nd = new xi,
                        Dd = new xi,
                        Od = new xi,
                        Bd = new Zi,
                        zd = new Zi;

                    function Fd(t) {
                        const e = [];
                        !0 === t.isBone && e.push(t);
                        for (let i = 0; i < t.children.length; i++) e.push.apply(e, Fd(t.children[i]));
                        return e
                    }
                    const kd = new xi,
                        Vd = new kn,
                        Hd = new kn,
                        Gd = new xi,
                        Wd = new xi,
                        jd = new xi,
                        Xd = new xi,
                        qd = new Dr;

                    function Yd(t, e, i, n, r, s, a) {
                        Xd.set(r, s, a).unproject(n);
                        const o = e[t];
                        if (void 0 !== o) {
                            const t = i.getAttribute("position");
                            for (let e = 0, i = o.length; e < i; e++) t.setXYZ(o[e], Xd.x, Xd.y, Xd.z)
                        }
                    }
                    const Jd = new Si,
                        Zd = new xi;
                    let Kd, Qd;
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                        detail: {
                            revision: i
                        }
                    })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i), e.ACESFilmicToneMapping = N, e.AddEquation = h, e.AddOperation = R, e.AdditiveAnimationBlendMode = he, e.AdditiveBlending = 2, e.AgXToneMapping = O, e.AlphaFormat = pt, e.AlwaysCompare = 519, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = Gu, e.AnimationAction = wd, e.AnimationClip = _u, e.AnimationLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = new Tu(this.manager);
                            s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(i) {
                                try {
                                    e(r.parse(JSON.parse(i)))
                                } catch (e) {
                                    n ? n(e) : console.error(e), r.manager.itemError(t)
                                }
                            }), i, n)
                        }
                        parse(t) {
                            const e = [];
                            for (let i = 0; i < t.length; i++) {
                                const n = _u.parse(t[i]);
                                e.push(n)
                            }
                            return e
                        }
                    }, e.AnimationMixer = class extends Le {
                        constructor(t) {
                            super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                        }
                        _bindAction(t, e) {
                            const i = t._localRoot || this._root,
                                n = t._clip.tracks,
                                r = n.length,
                                s = t._propertyBindings,
                                a = t._interpolants,
                                o = i.uuid,
                                l = this._bindingsByRootAndName;
                            let h = l[o];
                            void 0 === h && (h = {}, l[o] = h);
                            for (let t = 0; t !== r; ++t) {
                                const r = n[t],
                                    l = r.name;
                                let c = h[l];
                                if (void 0 !== c) ++c.referenceCount, s[t] = c;
                                else {
                                    if (c = s[t], void 0 !== c) {
                                        null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, o, l));
                                        continue
                                    }
                                    const n = e && e._propertyBindings[t].binding.parsedPath;
                                    c = new gd(Sd.create(i, l, n), r.ValueTypeName, r.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, o, l), s[t] = c
                                }
                                a[t].resultBuffer = c.buffer
                            }
                        }
                        _activateAction(t) {
                            if (!this._isActiveAction(t)) {
                                if (null === t._cacheIndex) {
                                    const e = (t._localRoot || this._root).uuid,
                                        i = t._clip.uuid,
                                        n = this._actionsByClip[i];
                                    this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                                }
                                const e = t._propertyBindings;
                                for (let t = 0, i = e.length; t !== i; ++t) {
                                    const i = e[t];
                                    0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState())
                                }
                                this._lendAction(t)
                            }
                        }
                        _deactivateAction(t) {
                            if (this._isActiveAction(t)) {
                                const e = t._propertyBindings;
                                for (let t = 0, i = e.length; t !== i; ++t) {
                                    const i = e[t];
                                    0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                                }
                                this._takeBackAction(t)
                            }
                        }
                        _initMemoryManager() {
                            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                            const t = this;
                            this.stats = {
                                actions: {
                                    get total() {
                                        return t._actions.length
                                    },
                                    get inUse() {
                                        return t._nActiveActions
                                    }
                                },
                                bindings: {
                                    get total() {
                                        return t._bindings.length
                                    },
                                    get inUse() {
                                        return t._nActiveBindings
                                    }
                                },
                                controlInterpolants: {
                                    get total() {
                                        return t._controlInterpolants.length
                                    },
                                    get inUse() {
                                        return t._nActiveControlInterpolants
                                    }
                                }
                            }
                        }
                        _isActiveAction(t) {
                            const e = t._cacheIndex;
                            return null !== e && e < this._nActiveActions
                        }
                        _addInactiveAction(t, e, i) {
                            const n = this._actions,
                                r = this._actionsByClip;
                            let s = r[e];
                            if (void 0 === s) s = {
                                knownActions: [t],
                                actionByRoot: {}
                            }, t._byClipCacheIndex = 0, r[e] = s;
                            else {
                                const e = s.knownActions;
                                t._byClipCacheIndex = e.length, e.push(t)
                            }
                            t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t
                        }
                        _removeInactiveAction(t) {
                            const e = this._actions,
                                i = e[e.length - 1],
                                n = t._cacheIndex;
                            i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                            const r = t._clip.uuid,
                                s = this._actionsByClip,
                                a = s[r],
                                o = a.knownActions,
                                l = o[o.length - 1],
                                h = t._byClipCacheIndex;
                            l._byClipCacheIndex = h, o[h] = l, o.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t)
                        }
                        _removeInactiveBindingsForAction(t) {
                            const e = t._propertyBindings;
                            for (let t = 0, i = e.length; t !== i; ++t) {
                                const i = e[t];
                                0 == --i.referenceCount && this._removeInactiveBinding(i)
                            }
                        }
                        _lendAction(t) {
                            const e = this._actions,
                                i = t._cacheIndex,
                                n = this._nActiveActions++,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _takeBackAction(t) {
                            const e = this._actions,
                                i = t._cacheIndex,
                                n = --this._nActiveActions,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _addInactiveBinding(t, e, i) {
                            const n = this._bindingsByRootAndName,
                                r = this._bindings;
                            let s = n[e];
                            void 0 === s && (s = {}, n[e] = s), s[i] = t, t._cacheIndex = r.length, r.push(t)
                        }
                        _removeInactiveBinding(t) {
                            const e = this._bindings,
                                i = t.binding,
                                n = i.rootNode.uuid,
                                r = i.path,
                                s = this._bindingsByRootAndName,
                                a = s[n],
                                o = e[e.length - 1],
                                l = t._cacheIndex;
                            o._cacheIndex = l, e[l] = o, e.pop(), delete a[r], 0 === Object.keys(a).length && delete s[n]
                        }
                        _lendBinding(t) {
                            const e = this._bindings,
                                i = t._cacheIndex,
                                n = this._nActiveBindings++,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _takeBackBinding(t) {
                            const e = this._bindings,
                                i = t._cacheIndex,
                                n = --this._nActiveBindings,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _lendControlInterpolant() {
                            const t = this._controlInterpolants,
                                e = this._nActiveControlInterpolants++;
                            let i = t[e];
                            return void 0 === i && (i = new lu(new Float32Array(2), new Float32Array(2), 1, Ad), i.__cacheIndex = e, t[e] = i), i
                        }
                        _takeBackControlInterpolant(t) {
                            const e = this._controlInterpolants,
                                i = t.__cacheIndex,
                                n = --this._nActiveControlInterpolants,
                                r = e[n];
                            t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
                        }
                        clipAction(t, e, i) {
                            const n = e || this._root,
                                r = n.uuid;
                            let s = "string" == typeof t ? _u.findByName(n, t) : t;
                            const a = null !== s ? s.uuid : t,
                                o = this._actionsByClip[a];
                            let l = null;
                            if (void 0 === i && (i = null !== s ? s.blendMode : 2500), void 0 !== o) {
                                const t = o.actionByRoot[r];
                                if (void 0 !== t && t.blendMode === i) return t;
                                l = o.knownActions[0], null === s && (s = l._clip)
                            }
                            if (null === s) return null;
                            const h = new wd(this, s, e, i);
                            return this._bindAction(h, l), this._addInactiveAction(h, a, r), h
                        }
                        existingAction(t, e) {
                            const i = e || this._root,
                                n = i.uuid,
                                r = "string" == typeof t ? _u.findByName(i, t) : t,
                                s = r ? r.uuid : t,
                                a = this._actionsByClip[s];
                            return void 0 !== a && a.actionByRoot[n] || null
                        }
                        stopAllAction() {
                            const t = this._actions;
                            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                            return this
                        }
                        update(t) {
                            t *= this.timeScale;
                            const e = this._actions,
                                i = this._nActiveActions,
                                n = this.time += t,
                                r = Math.sign(t),
                                s = this._accuIndex ^= 1;
                            for (let a = 0; a !== i; ++a) e[a]._update(n, t, r, s);
                            const a = this._bindings,
                                o = this._nActiveBindings;
                            for (let t = 0; t !== o; ++t) a[t].apply(s);
                            return this
                        }
                        setTime(t) {
                            this.time = 0;
                            for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                            return this.update(t)
                        }
                        getRoot() {
                            return this._root
                        }
                        uncacheClip(t) {
                            const e = this._actions,
                                i = t.uuid,
                                n = this._actionsByClip,
                                r = n[i];
                            if (void 0 !== r) {
                                const t = r.knownActions;
                                for (let i = 0, n = t.length; i !== n; ++i) {
                                    const n = t[i];
                                    this._deactivateAction(n);
                                    const r = n._cacheIndex,
                                        s = e[e.length - 1];
                                    n._cacheIndex = null, n._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(n)
                                }
                                delete n[i]
                            }
                        }
                        uncacheRoot(t) {
                            const e = t.uuid,
                                i = this._actionsByClip;
                            for (const t in i) {
                                const n = i[t].actionByRoot[e];
                                void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                            }
                            const n = this._bindingsByRootAndName[e];
                            if (void 0 !== n)
                                for (const t in n) {
                                    const e = n[t];
                                    e.restoreOriginalState(), this._removeInactiveBinding(e)
                                }
                        }
                        uncacheAction(t, e) {
                            const i = this.existingAction(t, e);
                            null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                        }
                    }, e.AnimationObjectGroup = class {
                        constructor() {
                            this.isAnimationObjectGroup = !0, this.uuid = Be(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                            const t = {};
                            this._indicesByUUID = t;
                            for (let e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
                            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                            const e = this;
                            this.stats = {
                                objects: {
                                    get total() {
                                        return e._objects.length
                                    },
                                    get inUse() {
                                        return this.total - e.nCachedObjects_
                                    }
                                },
                                get bindingsPerObject() {
                                    return e._bindings.length
                                }
                            }
                        }
                        add() {
                            const t = this._objects,
                                e = this._indicesByUUID,
                                i = this._paths,
                                n = this._parsedPaths,
                                r = this._bindings,
                                s = r.length;
                            let a, o = t.length,
                                l = this.nCachedObjects_;
                            for (let h = 0, c = arguments.length; h !== c; ++h) {
                                const c = arguments[h],
                                    u = c.uuid;
                                let d = e[u];
                                if (void 0 === d) {
                                    d = o++, e[u] = d, t.push(c);
                                    for (let t = 0, e = s; t !== e; ++t) r[t].push(new Sd(c, i[t], n[t]))
                                } else if (d < l) {
                                    a = t[d];
                                    const o = --l,
                                        h = t[o];
                                    e[h.uuid] = d, t[d] = h, e[u] = o, t[o] = c;
                                    for (let t = 0, e = s; t !== e; ++t) {
                                        const e = r[t],
                                            s = e[o];
                                        let a = e[d];
                                        e[d] = s, void 0 === a && (a = new Sd(c, i[t], n[t])), e[o] = a
                                    }
                                } else t[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                            }
                            this.nCachedObjects_ = l
                        }
                        remove() {
                            const t = this._objects,
                                e = this._indicesByUUID,
                                i = this._bindings,
                                n = i.length;
                            let r = this.nCachedObjects_;
                            for (let s = 0, a = arguments.length; s !== a; ++s) {
                                const a = arguments[s],
                                    o = a.uuid,
                                    l = e[o];
                                if (void 0 !== l && l >= r) {
                                    const s = r++,
                                        h = t[s];
                                    e[h.uuid] = l, t[l] = h, e[o] = s, t[s] = a;
                                    for (let t = 0, e = n; t !== e; ++t) {
                                        const e = i[t],
                                            n = e[s],
                                            r = e[l];
                                        e[l] = n, e[s] = r
                                    }
                                }
                            }
                            this.nCachedObjects_ = r
                        }
                        uncache() {
                            const t = this._objects,
                                e = this._indicesByUUID,
                                i = this._bindings,
                                n = i.length;
                            let r = this.nCachedObjects_,
                                s = t.length;
                            for (let a = 0, o = arguments.length; a !== o; ++a) {
                                const o = arguments[a].uuid,
                                    l = e[o];
                                if (void 0 !== l)
                                    if (delete e[o], l < r) {
                                        const a = --r,
                                            o = t[a],
                                            h = --s,
                                            c = t[h];
                                        e[o.uuid] = l, t[l] = o, e[c.uuid] = a, t[a] = c, t.pop();
                                        for (let t = 0, e = n; t !== e; ++t) {
                                            const e = i[t],
                                                n = e[a],
                                                r = e[h];
                                            e[l] = n, e[a] = r, e.pop()
                                        }
                                    } else {
                                        const r = --s,
                                            a = t[r];
                                        r > 0 && (e[a.uuid] = l), t[l] = a, t.pop();
                                        for (let t = 0, e = n; t !== e; ++t) {
                                            const e = i[t];
                                            e[l] = e[r], e.pop()
                                        }
                                    }
                            }
                            this.nCachedObjects_ = r
                        }
                        subscribe_(t, e) {
                            const i = this._bindingsIndicesByPath;
                            let n = i[t];
                            const r = this._bindings;
                            if (void 0 !== n) return r[n];
                            const s = this._paths,
                                a = this._parsedPaths,
                                o = this._objects,
                                l = o.length,
                                h = this.nCachedObjects_,
                                c = new Array(l);
                            n = r.length, i[t] = n, s.push(t), a.push(e), r.push(c);
                            for (let i = h, n = o.length; i !== n; ++i) {
                                const n = o[i];
                                c[i] = new Sd(n, t, e)
                            }
                            return c
                        }
                        unsubscribe_(t) {
                            const e = this._bindingsIndicesByPath,
                                i = e[t];
                            if (void 0 !== i) {
                                const n = this._paths,
                                    r = this._parsedPaths,
                                    s = this._bindings,
                                    a = s.length - 1,
                                    o = s[a];
                                e[t[a]] = i, s[i] = o, s.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                            }
                        }
                    }, e.AnimationUtils = su, e.ArcCurve = wh, e.ArrayCamera = Po, e.ArrowHelper = class extends wn {
                        constructor(t = new xi(0, 0, 1), e = new xi(0, 0, 0), i = 1, n = 16776960, r = .2 * i, s = .2 * r) {
                            super(), this.type = "ArrowHelper", void 0 === Kd && (Kd = new hr, Kd.setAttribute("position", new er([0, 0, 0, 0, 1, 0], 3)), Qd = new qh(0, .5, 1, 5, 1), Qd.translate(0, -.5, 0)), this.position.copy(e), this.line = new lh(Kd, new th({
                                color: n,
                                toneMapped: !1
                            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Er(Qd, new Wn({
                                color: n,
                                toneMapped: !1
                            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, s)
                        }
                        setDirection(t) {
                            if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
                            else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                            else {
                                Zd.set(t.z, 0, -t.x).normalize();
                                const e = Math.acos(t.y);
                                this.quaternion.setFromAxisAngle(Zd, e)
                            }
                        }
                        setLength(t, e = .2 * t, i = .2 * e) {
                            this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
                        }
                        setColor(t) {
                            this.line.material.color.set(t), this.cone.material.color.set(t)
                        }
                        copy(t) {
                            return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                        }
                        dispose() {
                            this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
                        }
                    }, e.AttachedBindMode = z, e.Audio = ud, e.AudioAnalyser = class {
                        constructor(t, e = 2048) {
                            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                        }
                        getFrequencyData() {
                            return this.analyser.getByteFrequencyData(this.data), this.data
                        }
                        getAverageFrequency() {
                            let t = 0;
                            const e = this.getFrequencyData();
                            for (let i = 0; i < e.length; i++) t += e[i];
                            return t / e.length
                        }
                    }, e.AudioContext = ed, e.AudioListener = class extends wn {
                        constructor() {
                            super(), this.type = "AudioListener", this.context = ed.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new sd
                        }
                        getInput() {
                            return this.gain
                        }
                        removeFilter() {
                            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                        }
                        getFilter() {
                            return this.filter
                        }
                        setFilter(t) {
                            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                        }
                        getMasterVolume() {
                            return this.gain.gain.value
                        }
                        setMasterVolume(t) {
                            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                        }
                        updateMatrixWorld(t) {
                            super.updateMatrixWorld(t);
                            const e = this.context.listener,
                                i = this.up;
                            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(od, ld, hd), cd.set(0, 0, -1).applyQuaternion(ld), e.positionX) {
                                const t = this.context.currentTime + this.timeDelta;
                                e.positionX.linearRampToValueAtTime(od.x, t), e.positionY.linearRampToValueAtTime(od.y, t), e.positionZ.linearRampToValueAtTime(od.z, t), e.forwardX.linearRampToValueAtTime(cd.x, t), e.forwardY.linearRampToValueAtTime(cd.y, t), e.forwardZ.linearRampToValueAtTime(cd.z, t), e.upX.linearRampToValueAtTime(i.x, t), e.upY.linearRampToValueAtTime(i.y, t), e.upZ.linearRampToValueAtTime(i.z, t)
                            } else e.setPosition(od.x, od.y, od.z), e.setOrientation(cd.x, cd.y, cd.z, i.x, i.y, i.z)
                        }
                    }, e.AudioLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = new Tu(this.manager);

                            function a(e) {
                                n ? n(e) : console.error(e), r.manager.itemError(t)
                            }
                            s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(t) {
                                try {
                                    const i = t.slice(0);
                                    ed.getContext().decodeAudioData(i, (function(t) {
                                        e(t)
                                    })).catch(a)
                                } catch (t) {
                                    a(t)
                                }
                            }), i, n)
                        }
                    }, e.AxesHelper = class extends dh {
                        constructor(t = 1) {
                            const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                                i = new hr;
                            i.setAttribute("position", new er(e, 3)), i.setAttribute("color", new er([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(i, new th({
                                vertexColors: !0,
                                toneMapped: !1
                            })), this.type = "AxesHelper"
                        }
                        setColors(t, e, i) {
                            const n = new kn,
                                r = this.geometry.attributes.color.array;
                            return n.set(t), n.toArray(r, 0), n.toArray(r, 3), n.set(e), n.toArray(r, 6), n.toArray(r, 9), n.set(i), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BatchedMesh = $l, e.Bone = Ml, e.BooleanKeyframeTrack = uu, e.Box2 = class {
                        constructor(t = new We(1 / 0, 1 / 0), e = new We(-1 / 0, -1 / 0)) {
                            this.isBox2 = !0, this.min = t, this.max = e
                        }
                        set(t, e) {
                            return this.min.copy(t), this.max.copy(e), this
                        }
                        setFromPoints(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                            return this
                        }
                        setFromCenterAndSize(t, e) {
                            const i = Ld.copy(e).multiplyScalar(.5);
                            return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.min.copy(t.min), this.max.copy(t.max), this
                        }
                        makeEmpty() {
                            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                        }
                        isEmpty() {
                            return this.max.x < this.min.x || this.max.y < this.min.y
                        }
                        getCenter(t) {
                            return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                        }
                        getSize(t) {
                            return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                        }
                        expandByPoint(t) {
                            return this.min.min(t), this.max.max(t), this
                        }
                        expandByVector(t) {
                            return this.min.sub(t), this.max.add(t), this
                        }
                        expandByScalar(t) {
                            return this.min.addScalar(-t), this.max.addScalar(t), this
                        }
                        containsPoint(t) {
                            return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y
                        }
                        containsBox(t) {
                            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                        }
                        getParameter(t, e) {
                            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                        }
                        intersectsBox(t) {
                            return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y
                        }
                        clampPoint(t, e) {
                            return e.copy(t).clamp(this.min, this.max)
                        }
                        distanceToPoint(t) {
                            return this.clampPoint(t, Ld).distanceTo(t)
                        }
                        intersect(t) {
                            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                        }
                        union(t) {
                            return this.min.min(t.min), this.max.max(t.max), this
                        }
                        translate(t) {
                            return this.min.add(t), this.max.add(t), this
                        }
                        equals(t) {
                            return t.min.equals(this.min) && t.max.equals(this.max)
                        }
                    }, e.Box3 = Si, e.Box3Helper = class extends dh {
                        constructor(t, e = 16776960) {
                            const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                                n = new hr;
                            n.setIndex(new Qn(i, 1)), n.setAttribute("position", new er([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(n, new th({
                                color: e,
                                toneMapped: !1
                            })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                        }
                        updateMatrixWorld(t) {
                            const e = this.box;
                            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.BoxGeometry = Rr, e.BoxHelper = class extends dh {
                        constructor(t, e = 16776960) {
                            const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                                n = new Float32Array(24),
                                r = new hr;
                            r.setIndex(new Qn(i, 1)), r.setAttribute("position", new Qn(n, 3)), super(r, new th({
                                color: e,
                                toneMapped: !1
                            })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                        }
                        update(t) {
                            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Jd.setFromObject(this.object), Jd.isEmpty()) return;
                            const e = Jd.min,
                                i = Jd.max,
                                n = this.geometry.attributes.position,
                                r = n.array;
                            r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = e.x, r[4] = i.y, r[5] = i.z, r[6] = e.x, r[7] = e.y, r[8] = i.z, r[9] = i.x, r[10] = e.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = e.z, r[15] = e.x, r[16] = i.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = i.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
                        }
                        setFromObject(t) {
                            return this.object = t, this.update(), this
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.object = t.object, this
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.BufferAttribute = Qn, e.BufferGeometry = hr, e.BufferGeometryLoader = Zu, e.ByteType = it, e.Cache = xu, e.Camera = Dr, e.CameraHelper = class extends dh {
                        constructor(t) {
                            const e = new hr,
                                i = new th({
                                    color: 16777215,
                                    vertexColors: !0,
                                    toneMapped: !1
                                }),
                                n = [],
                                r = [],
                                s = {};

                            function a(t, e) {
                                o(t), o(e)
                            }

                            function o(t) {
                                n.push(0, 0, 0), r.push(0, 0, 0), void 0 === s[t] && (s[t] = []), s[t].push(n.length / 3 - 1)
                            }
                            a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), e.setAttribute("position", new er(n, 3)), e.setAttribute("color", new er(r, 3)), super(e, i), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
                            const l = new kn(16755200),
                                h = new kn(16711680),
                                c = new kn(43775),
                                u = new kn(16777215),
                                d = new kn(3355443);
                            this.setColors(l, h, c, u, d)
                        }
                        setColors(t, e, i, n, r) {
                            const s = this.geometry.getAttribute("color");
                            s.setXYZ(0, t.r, t.g, t.b), s.setXYZ(1, t.r, t.g, t.b), s.setXYZ(2, t.r, t.g, t.b), s.setXYZ(3, t.r, t.g, t.b), s.setXYZ(4, t.r, t.g, t.b), s.setXYZ(5, t.r, t.g, t.b), s.setXYZ(6, t.r, t.g, t.b), s.setXYZ(7, t.r, t.g, t.b), s.setXYZ(8, t.r, t.g, t.b), s.setXYZ(9, t.r, t.g, t.b), s.setXYZ(10, t.r, t.g, t.b), s.setXYZ(11, t.r, t.g, t.b), s.setXYZ(12, t.r, t.g, t.b), s.setXYZ(13, t.r, t.g, t.b), s.setXYZ(14, t.r, t.g, t.b), s.setXYZ(15, t.r, t.g, t.b), s.setXYZ(16, t.r, t.g, t.b), s.setXYZ(17, t.r, t.g, t.b), s.setXYZ(18, t.r, t.g, t.b), s.setXYZ(19, t.r, t.g, t.b), s.setXYZ(20, t.r, t.g, t.b), s.setXYZ(21, t.r, t.g, t.b), s.setXYZ(22, t.r, t.g, t.b), s.setXYZ(23, t.r, t.g, t.b), s.setXYZ(24, e.r, e.g, e.b), s.setXYZ(25, e.r, e.g, e.b), s.setXYZ(26, e.r, e.g, e.b), s.setXYZ(27, e.r, e.g, e.b), s.setXYZ(28, e.r, e.g, e.b), s.setXYZ(29, e.r, e.g, e.b), s.setXYZ(30, e.r, e.g, e.b), s.setXYZ(31, e.r, e.g, e.b), s.setXYZ(32, i.r, i.g, i.b), s.setXYZ(33, i.r, i.g, i.b), s.setXYZ(34, i.r, i.g, i.b), s.setXYZ(35, i.r, i.g, i.b), s.setXYZ(36, i.r, i.g, i.b), s.setXYZ(37, i.r, i.g, i.b), s.setXYZ(38, n.r, n.g, n.b), s.setXYZ(39, n.r, n.g, n.b), s.setXYZ(40, r.r, r.g, r.b), s.setXYZ(41, r.r, r.g, r.b), s.setXYZ(42, r.r, r.g, r.b), s.setXYZ(43, r.r, r.g, r.b), s.setXYZ(44, r.r, r.g, r.b), s.setXYZ(45, r.r, r.g, r.b), s.setXYZ(46, r.r, r.g, r.b), s.setXYZ(47, r.r, r.g, r.b), s.setXYZ(48, r.r, r.g, r.b), s.setXYZ(49, r.r, r.g, r.b), s.needsUpdate = !0
                        }
                        update() {
                            const t = this.geometry,
                                e = this.pointMap;
                            qd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Yd("c", e, t, qd, 0, 0, -1), Yd("t", e, t, qd, 0, 0, 1), Yd("n1", e, t, qd, -1, -1, -1), Yd("n2", e, t, qd, 1, -1, -1), Yd("n3", e, t, qd, -1, 1, -1), Yd("n4", e, t, qd, 1, 1, -1), Yd("f1", e, t, qd, -1, -1, 1), Yd("f2", e, t, qd, 1, -1, 1), Yd("f3", e, t, qd, -1, 1, 1), Yd("f4", e, t, qd, 1, 1, 1), Yd("u1", e, t, qd, .7, 1.1, -1), Yd("u2", e, t, qd, -.7, 1.1, -1), Yd("u3", e, t, qd, 0, 2, -1), Yd("cf1", e, t, qd, -1, 0, 1), Yd("cf2", e, t, qd, 1, 0, 1), Yd("cf3", e, t, qd, 0, -1, 1), Yd("cf4", e, t, qd, 0, 1, 1), Yd("cn1", e, t, qd, -1, 0, -1), Yd("cn2", e, t, qd, 1, 0, -1), Yd("cn3", e, t, qd, 0, -1, -1), Yd("cn4", e, t, qd, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.CanvasTexture = class extends pi {
                        constructor(t, e, i, n, r, s, a, o, l) {
                            super(t, e, i, n, r, s, a, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0
                        }
                    }, e.CapsuleGeometry = jh, e.CatmullRomCurve3 = Ph, e.CineonToneMapping = U, e.CircleGeometry = Xh, e.ClampToEdgeWrapping = q, e.Clock = sd, e.Color = kn, e.ColorKeyframeTrack = du, e.ColorManagement = ri, e.CompressedArrayTexture = class extends Mh {
                        constructor(t, e, i, n, r, s) {
                            super(t, e, i, r, s), this.isCompressedArrayTexture = !0, this.image.depth = n, this.wrapR = q, this.layerUpdates = new Set
                        }
                        addLayerUpdate(t) {
                            this.layerUpdates.add(t)
                        }
                        clearLayerUpdates() {
                            this.layerUpdates.clear()
                        }
                    }, e.CompressedCubeTexture = class extends Mh {
                        constructor(t, e, i) {
                            super(void 0, t[0].width, t[0].height, e, i, V), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = t
                        }
                    }, e.CompressedTexture = Mh, e.CompressedTextureLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = [],
                                a = new Mh,
                                o = new Tu(this.manager);
                            o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
                            let l = 0;

                            function h(h) {
                                o.load(t[h], (function(t) {
                                    const i = r.parse(t, !0);
                                    s[h] = {
                                        width: i.width,
                                        height: i.height,
                                        format: i.format,
                                        mipmaps: i.mipmaps
                                    }, l += 1, 6 === l && (1 === i.mipmapCount && (a.minFilter = Q), a.image = s, a.format = i.format, a.needsUpdate = !0, e && e(a))
                                }), i, n)
                            }
                            if (Array.isArray(t))
                                for (let e = 0, i = t.length; e < i; ++e) h(e);
                            else o.load(t, (function(t) {
                                const i = r.parse(t, !0);
                                if (i.isCubemap) {
                                    const t = i.mipmaps.length / i.mipmapCount;
                                    for (let e = 0; e < t; e++) {
                                        s[e] = {
                                            mipmaps: []
                                        };
                                        for (let t = 0; t < i.mipmapCount; t++) s[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]), s[e].format = i.format, s[e].width = i.width, s[e].height = i.height
                                    }
                                    a.image = s
                                } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                                1 === i.mipmapCount && (a.minFilter = Q), a.format = i.format, a.needsUpdate = !0, e && e(a)
                            }), i, n);
                            return a
                        }
                    }, e.ConeGeometry = Yh, e.ConstantAlphaFactor = 213, e.ConstantColorFactor = 211, e.Controls = class extends Le {
                        constructor(t, e) {
                            super(), this.object = t, this.domElement = e, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = {
                                LEFT: null,
                                MIDDLE: null,
                                RIGHT: null
                            }, this.touches = {
                                ONE: null,
                                TWO: null
                            }
                        }
                        connect() {}
                        disconnect() {}
                        dispose() {}
                        update() {}
                    }, e.CubeCamera = Vr, e.CubeReflectionMapping = V, e.CubeRefractionMapping = H, e.CubeTexture = Hr, e.CubeTextureLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = new Hr;
                            r.colorSpace = ue;
                            const s = new Eu(this.manager);
                            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                            let a = 0;

                            function o(i) {
                                s.load(t[i], (function(t) {
                                    r.images[i] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                                }), void 0, n)
                            }
                            for (let e = 0; e < t.length; ++e) o(e);
                            return r
                        }
                    }, e.CubeUVReflectionMapping = j, e.CubicBezierCurve = Nh, e.CubicBezierCurve3 = Dh, e.CubicInterpolant = ou, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = bh, e.CurvePath = Hh, e.CustomBlending = 5, e.CustomToneMapping = D, e.CylinderGeometry = qh, e.Cylindrical = class {
                        constructor(t = 1, e = 0, i = 0) {
                            return this.radius = t, this.theta = e, this.y = i, this
                        }
                        set(t, e, i) {
                            return this.radius = t, this.theta = e, this.y = i, this
                        }
                        copy(t) {
                            return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                        }
                        setFromVector3(t) {
                            return this.setFromCartesianCoords(t.x, t.y, t.z)
                        }
                        setFromCartesianCoords(t, e, i) {
                            return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }, e.Data3DTexture = _i, e.DataArrayTexture = vi, e.DataTexture = bl, e.DataTextureLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = new bl,
                                a = new Tu(this.manager);
                            return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, (function(t) {
                                let i;
                                try {
                                    i = r.parse(t)
                                } catch (t) {
                                    if (void 0 === n) return void console.error(t);
                                    n(t)
                                }
                                void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width, s.image.height = i.height, s.image.data = i.data), s.wrapS = void 0 !== i.wrapS ? i.wrapS : q, s.wrapT = void 0 !== i.wrapT ? i.wrapT : q, s.magFilter = void 0 !== i.magFilter ? i.magFilter : Q, s.minFilter = void 0 !== i.minFilter ? i.minFilter : Q, s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.colorSpace && (s.colorSpace = i.colorSpace), void 0 !== i.flipY && (s.flipY = i.flipY), void 0 !== i.format && (s.format = i.format), void 0 !== i.type && (s.type = i.type), void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps, s.minFilter = tt), 1 === i.mipmapCount && (s.minFilter = Q), void 0 !== i.generateMipmaps && (s.generateMipmaps = i.generateMipmaps), s.needsUpdate = !0, e && e(s, i)
                            }), i, n), s
                        }
                    }, e.DataUtils = Jn, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = bu, e.DepthFormat = _t, e.DepthStencilFormat = yt, e.DepthTexture = Ds, e.DetachedBindMode = F, e.DirectionalLight = Hu, e.DirectionalLightHelper = class extends wn {
                        constructor(t, e, i) {
                            super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", void 0 === e && (e = 1);
                            let n = new hr;
                            n.setAttribute("position", new er([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                            const r = new th({
                                fog: !1,
                                toneMapped: !1
                            });
                            this.lightPlane = new lh(n, r), this.add(this.lightPlane), n = new hr, n.setAttribute("position", new er([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new lh(n, r), this.add(this.targetLine), this.update()
                        }
                        dispose() {
                            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                        }
                        update() {
                            this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Gd.setFromMatrixPosition(this.light.matrixWorld), Wd.setFromMatrixPosition(this.light.target.matrixWorld), jd.subVectors(Wd, Gd), this.lightPlane.lookAt(Wd), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Wd), this.targetLine.scale.z = jd.length()
                        }
                    }, e.DiscreteInterpolant = hu, e.DisplayP3ColorSpace = pe, e.DodecahedronGeometry = Zh, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = 35048, e.DynamicReadUsage = 35049, e.EdgesGeometry = ec, e.EllipseCurve = Sh, e.EqualCompare = 514, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = G, e.EquirectangularRefractionMapping = W, e.Euler = on, e.EventDispatcher = Le, e.ExtrudeGeometry = Pc, e.FileLoader = Tu, e.Float16BufferAttribute = class extends Qn {
                        constructor(t, e, i) {
                            super(new Uint16Array(t), e, i), this.isFloat16BufferAttribute = !0
                        }
                        getX(t) {
                            let e = Yn(this.array[t * this.itemSize]);
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setX(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize] = qn(e), this
                        }
                        getY(t) {
                            let e = Yn(this.array[t * this.itemSize + 1]);
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setY(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize + 1] = qn(e), this
                        }
                        getZ(t) {
                            let e = Yn(this.array[t * this.itemSize + 2]);
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setZ(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize + 2] = qn(e), this
                        }
                        getW(t) {
                            let e = Yn(this.array[t * this.itemSize + 3]);
                            return this.normalized && (e = Ve(e, this.array)), e
                        }
                        setW(t, e) {
                            return this.normalized && (e = He(e, this.array)), this.array[t * this.itemSize + 3] = qn(e), this
                        }
                        setXY(t, e, i) {
                            return t *= this.itemSize, this.normalized && (e = He(e, this.array), i = He(i, this.array)), this.array[t + 0] = qn(e), this.array[t + 1] = qn(i), this
                        }
                        setXYZ(t, e, i, n) {
                            return t *= this.itemSize, this.normalized && (e = He(e, this.array), i = He(i, this.array), n = He(n, this.array)), this.array[t + 0] = qn(e), this.array[t + 1] = qn(i), this.array[t + 2] = qn(n), this
                        }
                        setXYZW(t, e, i, n, r) {
                            return t *= this.itemSize, this.normalized && (e = He(e, this.array), i = He(i, this.array), n = He(n, this.array), r = He(r, this.array)), this.array[t + 0] = qn(e), this.array[t + 1] = qn(i), this.array[t + 2] = qn(n), this.array[t + 3] = qn(r), this
                        }
                    }, e.Float32BufferAttribute = er, e.FloatType = ot, e.Fog = Vo, e.FogExp2 = ko, e.FramebufferTexture = class extends pi {
                        constructor(t, e) {
                            super({
                                width: t,
                                height: e
                            }), this.isFramebufferTexture = !0, this.magFilter = J, this.minFilter = J, this.generateMipmaps = !1, this.needsUpdate = !0
                        }
                    }, e.FrontSide = 0, e.Frustum = Zr, e.GLBufferAttribute = class {
                        constructor(t, e, i, n, r) {
                            this.isGLBufferAttribute = !0, this.name = "", this.buffer = t, this.type = e, this.itemSize = i, this.elementSize = n, this.count = r, this.version = 0
                        }
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        setBuffer(t) {
                            return this.buffer = t, this
                        }
                        setType(t, e) {
                            return this.type = t, this.elementSize = e, this
                        }
                        setItemSize(t) {
                            return this.itemSize = t, this
                        }
                        setCount(t) {
                            return this.count = t, this
                        }
                    }, e.GLSL1 = "100", e.GLSL3 = Re, e.GreaterCompare = 516, e.GreaterDepth = 6, e.GreaterEqualCompare = 518, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = class extends dh {
                        constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
                            i = new kn(i), n = new kn(n);
                            const r = e / 2,
                                s = t / e,
                                a = t / 2,
                                o = [],
                                l = [];
                            for (let t = 0, h = 0, c = -a; t <= e; t++, c += s) {
                                o.push(-a, 0, c, a, 0, c), o.push(c, 0, -a, c, 0, a);
                                const e = t === r ? i : n;
                                e.toArray(l, h), h += 3, e.toArray(l, h), h += 3, e.toArray(l, h), h += 3, e.toArray(l, h), h += 3
                            }
                            const h = new hr;
                            h.setAttribute("position", new er(o, 3)), h.setAttribute("color", new er(l, 3)), super(h, new th({
                                vertexColors: !0,
                                toneMapped: !1
                            })), this.type = "GridHelper"
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.Group = Io, e.HalfFloatType = lt, e.HemisphereLight = Ru, e.HemisphereLightHelper = class extends wn {
                        constructor(t, e, i) {
                            super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper";
                            const n = new Uc(e);
                            n.rotateY(.5 * Math.PI), this.material = new Wn({
                                wireframe: !0,
                                fog: !1,
                                toneMapped: !1
                            }), void 0 === this.color && (this.material.vertexColors = !0);
                            const r = n.getAttribute("position"),
                                s = new Float32Array(3 * r.count);
                            n.setAttribute("color", new Qn(s, 3)), this.add(new Er(n, this.material)), this.update()
                        }
                        dispose() {
                            this.children[0].geometry.dispose(), this.children[0].material.dispose()
                        }
                        update() {
                            const t = this.children[0];
                            if (void 0 !== this.color) this.material.color.set(this.color);
                            else {
                                const e = t.geometry.getAttribute("color");
                                Vd.copy(this.light.color), Hd.copy(this.light.groundColor);
                                for (let t = 0, i = e.count; t < i; t++) {
                                    const n = t < i / 2 ? Vd : Hd;
                                    e.setXYZ(t, n.r, n.g, n.b)
                                }
                                e.needsUpdate = !0
                            }
                            this.light.updateWorldMatrix(!0, !1), t.lookAt(kd.setFromMatrixPosition(this.light.matrixWorld).negate())
                        }
                    }, e.IcosahedronGeometry = Lc, e.ImageBitmapLoader = class extends Su {
                        constructor(t) {
                            super(t), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                                premultiplyAlpha: "none"
                            }
                        }
                        setOptions(t) {
                            return this.options = t, this
                        }
                        load(t, e, i, n) {
                            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                            const r = this,
                                s = xu.get(t);
                            if (void 0 !== s) return r.manager.itemStart(t), s.then ? void s.then((i => {
                                e && e(i), r.manager.itemEnd(t)
                            })).catch((t => {
                                n && n(t)
                            })) : (setTimeout((function() {
                                e && e(s), r.manager.itemEnd(t)
                            }), 0), s);
                            const a = {};
                            a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader;
                            const o = fetch(t, a).then((function(t) {
                                return t.blob()
                            })).then((function(t) {
                                return createImageBitmap(t, Object.assign(r.options, {
                                    colorSpaceConversion: "none"
                                }))
                            })).then((function(i) {
                                return xu.add(t, i), e && e(i), r.manager.itemEnd(t), i
                            })).catch((function(e) {
                                n && n(e), xu.remove(t), r.manager.itemError(t), r.manager.itemEnd(t)
                            }));
                            xu.add(t, o), r.manager.itemStart(t)
                        }
                    }, e.ImageLoader = Eu, e.ImageUtils = li, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = Tl, e.InstancedBufferGeometry = Ju, e.InstancedInterleavedBuffer = class extends Go {
                        constructor(t, e, i = 1) {
                            super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i
                        }
                        copy(t) {
                            return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                        }
                        clone(t) {
                            const e = super.clone(t);
                            return e.meshPerAttribute = this.meshPerAttribute, e
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                        }
                    }, e.InstancedMesh = Nl, e.Int16BufferAttribute = class extends Qn {
                        constructor(t, e, i) {
                            super(new Int16Array(t), e, i)
                        }
                    }, e.Int32BufferAttribute = class extends Qn {
                        constructor(t, e, i) {
                            super(new Int32Array(t), e, i)
                        }
                    }, e.Int8BufferAttribute = class extends Qn {
                        constructor(t, e, i) {
                            super(new Int8Array(t), e, i)
                        }
                    }, e.IntType = st, e.InterleavedBuffer = Go, e.InterleavedBufferAttribute = jo, e.Interpolant = au, e.InterpolateDiscrete = ne, e.InterpolateLinear = re, e.InterpolateSmooth = se, e.InvertStencilOp = 5386, e.KeepStencilOp = ye, e.KeyframeTrack = cu, e.LOD = cl, e.LatheGeometry = Wh, e.Layers = ln, e.LessCompare = 513, e.LessDepth = 2, e.LessEqualCompare = 515, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = Cu, e.LightProbe = Xu, e.Line = lh, e.Line3 = class {
                        constructor(t = new xi, e = new xi) {
                            this.start = t, this.end = e
                        }
                        set(t, e) {
                            return this.start.copy(t), this.end.copy(e), this
                        }
                        copy(t) {
                            return this.start.copy(t.start), this.end.copy(t.end), this
                        }
                        getCenter(t) {
                            return t.addVectors(this.start, this.end).multiplyScalar(.5)
                        }
                        delta(t) {
                            return t.subVectors(this.end, this.start)
                        }
                        distanceSq() {
                            return this.start.distanceToSquared(this.end)
                        }
                        distance() {
                            return this.start.distanceTo(this.end)
                        }
                        at(t, e) {
                            return this.delta(e).multiplyScalar(t).add(this.start)
                        }
                        closestPointToPointParameter(t, e) {
                            Ud.subVectors(t, this.start), Nd.subVectors(this.end, this.start);
                            const i = Nd.dot(Nd);
                            let n = Nd.dot(Ud) / i;
                            return e && (n = ze(n, 0, 1)), n
                        }
                        closestPointToPoint(t, e, i) {
                            const n = this.closestPointToPointParameter(t, e);
                            return this.delta(i).multiplyScalar(n).add(this.start)
                        }
                        applyMatrix4(t) {
                            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                        }
                        equals(t) {
                            return t.start.equals(this.start) && t.end.equals(this.end)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }, e.LineBasicMaterial = th, e.LineCurve = Oh, e.LineCurve3 = Bh, e.LineDashedMaterial = $c, e.LineLoop = ph, e.LineSegments = dh, e.LinearDisplayP3ColorSpace = me, e.LinearFilter = Q, e.LinearInterpolant = lu, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = tt, e.LinearMipmapNearestFilter = $, e.LinearSRGBColorSpace = de, e.LinearToneMapping = I, e.LinearTransfer = fe, e.Loader = Su, e.LoaderUtils = Yu, e.LoadingManager = Mu, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = vt, e.LuminanceFormat = gt, e.MOUSE = {
                        LEFT: 0,
                        MIDDLE: 1,
                        RIGHT: 2,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2
                    }, e.Material = Gn, e.MaterialLoader = qu, e.MathUtils = Ge, e.Matrix2 = Id, e.Matrix3 = je, e.Matrix4 = Zi, e.MaxEquation = 104, e.Mesh = Er, e.MeshBasicMaterial = Wn, e.MeshDepthMaterial = bo, e.MeshDistanceMaterial = So, e.MeshLambertMaterial = Kc, e.MeshMatcapMaterial = Qc, e.MeshNormalMaterial = Zc, e.MeshPhongMaterial = Yc, e.MeshPhysicalMaterial = qc, e.MeshStandardMaterial = Xc, e.MeshToonMaterial = Jc, e.MinEquation = 103, e.MirroredRepeatWrapping = Y, e.MixOperation = C, e.MultiplyBlending = 4, e.MultiplyOperation = E, e.NearestFilter = J, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = K, e.NearestMipmapNearestFilter = Z, e.NeutralToneMapping = B, e.NeverCompare = 512, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColorSpace = ce, e.NoToneMapping = P, e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualCompare = 517, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = pu, e.Object3D = wn, e.ObjectLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = "" === this.path ? Yu.extractUrlBase(t) : this.path;
                            this.resourcePath = this.resourcePath || s;
                            const a = new Tu(this.manager);
                            a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(i) {
                                let s = null;
                                try {
                                    s = JSON.parse(i)
                                } catch (e) {
                                    return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                                }
                                const a = s.metadata;
                                if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) return void 0 !== n && n(new Error("THREE.ObjectLoader: Can't load " + t)), void console.error("THREE.ObjectLoader: Can't load " + t);
                                r.parse(s, e)
                            }), i, n)
                        }
                        async loadAsync(t, e) {
                            const i = "" === this.path ? Yu.extractUrlBase(t) : this.path;
                            this.resourcePath = this.resourcePath || i;
                            const n = new Tu(this.manager);
                            n.setPath(this.path), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials);
                            const r = await n.loadAsync(t, e),
                                s = JSON.parse(r),
                                a = s.metadata;
                            if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t);
                            return await this.parseAsync(s)
                        }
                        parse(t, e) {
                            const i = this.parseAnimations(t.animations),
                                n = this.parseShapes(t.shapes),
                                r = this.parseGeometries(t.geometries, n),
                                s = this.parseImages(t.images, (function() {
                                    void 0 !== e && e(l)
                                })),
                                a = this.parseTextures(t.textures, s),
                                o = this.parseMaterials(t.materials, a),
                                l = this.parseObject(t.object, r, o, a, i),
                                h = this.parseSkeletons(t.skeletons, l);
                            if (this.bindSkeletons(l, h), this.bindLightTargets(l), void 0 !== e) {
                                let t = !1;
                                for (const e in s)
                                    if (s[e].data instanceof HTMLImageElement) {
                                        t = !0;
                                        break
                                    }! 1 === t && e(l)
                            }
                            return l
                        }
                        async parseAsync(t) {
                            const e = this.parseAnimations(t.animations),
                                i = this.parseShapes(t.shapes),
                                n = this.parseGeometries(t.geometries, i),
                                r = await this.parseImagesAsync(t.images),
                                s = this.parseTextures(t.textures, r),
                                a = this.parseMaterials(t.materials, s),
                                o = this.parseObject(t.object, n, a, s, e),
                                l = this.parseSkeletons(t.skeletons, o);
                            return this.bindSkeletons(o, l), this.bindLightTargets(o), o
                        }
                        parseShapes(t) {
                            const e = {};
                            if (void 0 !== t)
                                for (let i = 0, n = t.length; i < n; i++) {
                                    const n = (new ic).fromJSON(t[i]);
                                    e[n.uuid] = n
                                }
                            return e
                        }
                        parseSkeletons(t, e) {
                            const i = {},
                                n = {};
                            if (e.traverse((function(t) {
                                    t.isBone && (n[t.uuid] = t)
                                })), void 0 !== t)
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = (new Al).fromJSON(t[e], n);
                                    i[r.uuid] = r
                                }
                            return i
                        }
                        parseGeometries(t, e) {
                            const i = {};
                            if (void 0 !== t) {
                                const n = new Zu;
                                for (let r = 0, s = t.length; r < s; r++) {
                                    let s;
                                    const a = t[r];
                                    switch (a.type) {
                                        case "BufferGeometry":
                                        case "InstancedBufferGeometry":
                                            s = n.parse(a);
                                            break;
                                        default:
                                            a.type in Gc ? s = Gc[a.type].fromJSON(a, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
                                    }
                                    s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.userData && (s.userData = a.userData), i[a.uuid] = s
                                }
                            }
                            return i
                        }
                        parseMaterials(t, e) {
                            const i = {},
                                n = {};
                            if (void 0 !== t) {
                                const r = new qu;
                                r.setTextures(e);
                                for (let e = 0, s = t.length; e < s; e++) {
                                    const s = t[e];
                                    void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)), n[s.uuid] = i[s.uuid]
                                }
                            }
                            return n
                        }
                        parseAnimations(t) {
                            const e = {};
                            if (void 0 !== t)
                                for (let i = 0; i < t.length; i++) {
                                    const n = t[i],
                                        r = _u.parse(n);
                                    e[r.uuid] = r
                                }
                            return e
                        }
                        parseImages(t, e) {
                            const i = this,
                                n = {};
                            let r;

                            function s(t) {
                                if ("string" == typeof t) {
                                    const e = t;
                                    return function(t) {
                                        return i.manager.itemStart(t), r.load(t, (function() {
                                            i.manager.itemEnd(t)
                                        }), void 0, (function() {
                                            i.manager.itemError(t), i.manager.itemEnd(t)
                                        }))
                                    }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : i.resourcePath + e)
                                }
                                return t.data ? {
                                    data: Je(t.type, t.data),
                                    width: t.width,
                                    height: t.height
                                } : null
                            }
                            if (void 0 !== t && t.length > 0) {
                                const i = new Mu(e);
                                r = new Eu(i), r.setCrossOrigin(this.crossOrigin);
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e],
                                        r = i.url;
                                    if (Array.isArray(r)) {
                                        const t = [];
                                        for (let e = 0, i = r.length; e < i; e++) {
                                            const i = s(r[e]);
                                            null !== i && (i instanceof HTMLImageElement ? t.push(i) : t.push(new bl(i.data, i.width, i.height)))
                                        }
                                        n[i.uuid] = new ci(t)
                                    } else {
                                        const t = s(i.url);
                                        n[i.uuid] = new ci(t)
                                    }
                                }
                            }
                            return n
                        }
                        async parseImagesAsync(t) {
                            const e = this,
                                i = {};
                            let n;
                            async function r(t) {
                                if ("string" == typeof t) {
                                    const i = t,
                                        r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i) ? i : e.resourcePath + i;
                                    return await n.loadAsync(r)
                                }
                                return t.data ? {
                                    data: Je(t.type, t.data),
                                    width: t.width,
                                    height: t.height
                                } : null
                            }
                            if (void 0 !== t && t.length > 0) {
                                n = new Eu(this.manager), n.setCrossOrigin(this.crossOrigin);
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e],
                                        s = n.url;
                                    if (Array.isArray(s)) {
                                        const t = [];
                                        for (let e = 0, i = s.length; e < i; e++) {
                                            const i = s[e],
                                                n = await r(i);
                                            null !== n && (n instanceof HTMLImageElement ? t.push(n) : t.push(new bl(n.data, n.width, n.height)))
                                        }
                                        i[n.uuid] = new ci(t)
                                    } else {
                                        const t = await r(n.url);
                                        i[n.uuid] = new ci(t)
                                    }
                                }
                            }
                            return i
                        }
                        parseTextures(t, e) {
                            function i(t, e) {
                                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                            }
                            const n = {};
                            if (void 0 !== t)
                                for (let r = 0, s = t.length; r < s; r++) {
                                    const s = t[r];
                                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                                    const a = e[s.image],
                                        o = a.data;
                                    let l;
                                    Array.isArray(o) ? (l = new Hr, 6 === o.length && (l.needsUpdate = !0)) : (l = o && o.data ? new bl : new pi, o && (l.needsUpdate = !0)), l.source = a, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = i(s.mapping, Ku)), void 0 !== s.channel && (l.channel = s.channel), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.center && l.center.fromArray(s.center), void 0 !== s.rotation && (l.rotation = s.rotation), void 0 !== s.wrap && (l.wrapS = i(s.wrap[0], Qu), l.wrapT = i(s.wrap[1], Qu)), void 0 !== s.format && (l.format = s.format), void 0 !== s.internalFormat && (l.internalFormat = s.internalFormat), void 0 !== s.type && (l.type = s.type), void 0 !== s.colorSpace && (l.colorSpace = s.colorSpace), void 0 !== s.minFilter && (l.minFilter = i(s.minFilter, $u)), void 0 !== s.magFilter && (l.magFilter = i(s.magFilter, $u)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), void 0 !== s.generateMipmaps && (l.generateMipmaps = s.generateMipmaps), void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment), void 0 !== s.compareFunction && (l.compareFunction = s.compareFunction), void 0 !== s.userData && (l.userData = s.userData), n[s.uuid] = l
                                }
                            return n
                        }
                        parseObject(t, e, i, n, r) {
                            let s, a, o;

                            function l(t) {
                                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                            }

                            function h(t) {
                                if (void 0 !== t) {
                                    if (Array.isArray(t)) {
                                        const e = [];
                                        for (let n = 0, r = t.length; n < r; n++) {
                                            const r = t[n];
                                            void 0 === i[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(i[r])
                                        }
                                        return e
                                    }
                                    return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                                }
                            }

                            function c(t) {
                                return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined texture", t), n[t]
                            }
                            switch (t.type) {
                                case "Scene":
                                    s = new Ho, void 0 !== t.background && (Number.isInteger(t.background) ? s.background = new kn(t.background) : s.background = c(t.background)), void 0 !== t.environment && (s.environment = c(t.environment)), void 0 !== t.fog && ("Fog" === t.fog.type ? s.fog = new Vo(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (s.fog = new ko(t.fog.color, t.fog.density)), "" !== t.fog.name && (s.fog.name = t.fog.name)), void 0 !== t.backgroundBlurriness && (s.backgroundBlurriness = t.backgroundBlurriness), void 0 !== t.backgroundIntensity && (s.backgroundIntensity = t.backgroundIntensity), void 0 !== t.backgroundRotation && s.backgroundRotation.fromArray(t.backgroundRotation), void 0 !== t.environmentIntensity && (s.environmentIntensity = t.environmentIntensity), void 0 !== t.environmentRotation && s.environmentRotation.fromArray(t.environmentRotation);
                                    break;
                                case "PerspectiveCamera":
                                    s = new Fr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (s.focus = t.focus), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (s.filmOffset = t.filmOffset), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                    break;
                                case "OrthographicCamera":
                                    s = new ds(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (s.zoom = t.zoom), void 0 !== t.view && (s.view = Object.assign({}, t.view));
                                    break;
                                case "AmbientLight":
                                    s = new Gu(t.color, t.intensity);
                                    break;
                                case "DirectionalLight":
                                    s = new Hu(t.color, t.intensity), s.target = t.target || "";
                                    break;
                                case "PointLight":
                                    s = new ku(t.color, t.intensity, t.distance, t.decay);
                                    break;
                                case "RectAreaLight":
                                    s = new Wu(t.color, t.intensity, t.width, t.height);
                                    break;
                                case "SpotLight":
                                    s = new Du(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay), s.target = t.target || "";
                                    break;
                                case "HemisphereLight":
                                    s = new Ru(t.color, t.groundColor, t.intensity);
                                    break;
                                case "LightProbe":
                                    s = (new Xu).fromJSON(t);
                                    break;
                                case "SkinnedMesh":
                                    a = l(t.geometry), o = h(t.material), s = new xl(a, o), void 0 !== t.bindMode && (s.bindMode = t.bindMode), void 0 !== t.bindMatrix && s.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (s.skeleton = t.skeleton);
                                    break;
                                case "Mesh":
                                    a = l(t.geometry), o = h(t.material), s = new Er(a, o);
                                    break;
                                case "InstancedMesh":
                                    a = l(t.geometry), o = h(t.material);
                                    const e = t.count,
                                        i = t.instanceMatrix,
                                        n = t.instanceColor;
                                    s = new Nl(a, o, e), s.instanceMatrix = new Tl(new Float32Array(i.array), 16), void 0 !== n && (s.instanceColor = new Tl(new Float32Array(n.array), n.itemSize));
                                    break;
                                case "BatchedMesh":
                                    a = l(t.geometry), o = h(t.material), s = new $l(t.maxInstanceCount, t.maxVertexCount, t.maxIndexCount, o), s.geometry = a, s.perObjectFrustumCulled = t.perObjectFrustumCulled, s.sortObjects = t.sortObjects, s._drawRanges = t.drawRanges, s._reservedRanges = t.reservedRanges, s._visibility = t.visibility, s._active = t.active, s._bounds = t.bounds.map((t => {
                                        const e = new Si;
                                        e.min.fromArray(t.boxMin), e.max.fromArray(t.boxMax);
                                        const i = new Vi;
                                        return i.radius = t.sphereRadius, i.center.fromArray(t.sphereCenter), {
                                            boxInitialized: t.boxInitialized,
                                            box: e,
                                            sphereInitialized: t.sphereInitialized,
                                            sphere: i
                                        }
                                    })), s._maxInstanceCount = t.maxInstanceCount, s._maxVertexCount = t.maxVertexCount, s._maxIndexCount = t.maxIndexCount, s._geometryInitialized = t.geometryInitialized, s._geometryCount = t.geometryCount, s._matricesTexture = c(t.matricesTexture.uuid), void 0 !== t.colorsTexture && (s._colorsTexture = c(t.colorsTexture.uuid));
                                    break;
                                case "LOD":
                                    s = new cl;
                                    break;
                                case "Line":
                                    s = new lh(l(t.geometry), h(t.material));
                                    break;
                                case "LineLoop":
                                    s = new ph(l(t.geometry), h(t.material));
                                    break;
                                case "LineSegments":
                                    s = new dh(l(t.geometry), h(t.material));
                                    break;
                                case "PointCloud":
                                case "Points":
                                    s = new yh(l(t.geometry), h(t.material));
                                    break;
                                case "Sprite":
                                    s = new al(h(t.material));
                                    break;
                                case "Group":
                                    s = new Io;
                                    break;
                                case "Bone":
                                    s = new Ml;
                                    break;
                                default:
                                    s = new wn
                            }
                            if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (s.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.quaternion && s.quaternion.fromArray(t.quaternion), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.up && s.up.fromArray(t.up), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.intensity && (s.shadow.intensity = t.shadow.intensity), void 0 !== t.shadow.bias && (s.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (s.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (s.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && s.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (s.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.frustumCulled && (s.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.layers && (s.layers.mask = t.layers), void 0 !== t.children) {
                                const a = t.children;
                                for (let t = 0; t < a.length; t++) s.add(this.parseObject(a[t], e, i, n, r))
                            }
                            if (void 0 !== t.animations) {
                                const e = t.animations;
                                for (let t = 0; t < e.length; t++) {
                                    const i = e[t];
                                    s.animations.push(r[i])
                                }
                            }
                            if ("LOD" === t.type) {
                                void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate);
                                const e = t.levels;
                                for (let t = 0; t < e.length; t++) {
                                    const i = e[t],
                                        n = s.getObjectByProperty("uuid", i.object);
                                    void 0 !== n && s.addLevel(n, i.distance, i.hysteresis)
                                }
                            }
                            return s
                        }
                        bindSkeletons(t, e) {
                            0 !== Object.keys(e).length && t.traverse((function(t) {
                                if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                                    const i = e[t.skeleton];
                                    void 0 === i ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(i, t.bindMatrix)
                                }
                            }))
                        }
                        bindLightTargets(t) {
                            t.traverse((function(e) {
                                if (e.isDirectionalLight || e.isSpotLight) {
                                    const i = e.target,
                                        n = t.getObjectByProperty("uuid", i);
                                    e.target = void 0 !== n ? n : new wn
                                }
                            }))
                        }
                    }, e.ObjectSpaceNormalMap = 1, e.OctahedronGeometry = Uc, e.OneFactor = 201, e.OneMinusConstantAlphaFactor = 214, e.OneMinusConstantColorFactor = 212, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = v, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = ds, e.P3Primaries = _e, e.PCFShadowMap = n, e.PCFSoftShadowMap = r, e.PMREMGenerator = Ss, e.Path = Gh, e.PerspectiveCamera = Fr, e.Plane = qr, e.PlaneGeometry = $r, e.PlaneHelper = class extends lh {
                        constructor(t, e = 1, i = 16776960) {
                            const n = i,
                                r = new hr;
                            r.setAttribute("position", new er([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new th({
                                color: n,
                                toneMapped: !1
                            })), this.type = "PlaneHelper", this.plane = t, this.size = e;
                            const s = new hr;
                            s.setAttribute("position", new er([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s.computeBoundingSphere(), this.add(new Er(s, new Wn({
                                color: n,
                                opacity: .2,
                                transparent: !0,
                                depthWrite: !1,
                                toneMapped: !1
                            })))
                        }
                        updateMatrixWorld(t) {
                            this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(t)
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
                        }
                    }, e.PointLight = ku, e.PointLightHelper = class extends Er {
                        constructor(t, e, i) {
                            super(new Oc(e, 4, 2), new Wn({
                                wireframe: !0,
                                fog: !1,
                                toneMapped: !1
                            })), this.light = t, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                        update() {
                            this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                        }
                    }, e.Points = yh, e.PointsMaterial = mh, e.PolarGridHelper = class extends dh {
                        constructor(t = 10, e = 16, i = 8, n = 64, r = 4473924, s = 8947848) {
                            r = new kn(r), s = new kn(s);
                            const a = [],
                                o = [];
                            if (e > 1)
                                for (let i = 0; i < e; i++) {
                                    const n = i / e * (2 * Math.PI),
                                        l = Math.sin(n) * t,
                                        h = Math.cos(n) * t;
                                    a.push(0, 0, 0), a.push(l, 0, h);
                                    const c = 1 & i ? r : s;
                                    o.push(c.r, c.g, c.b), o.push(c.r, c.g, c.b)
                                }
                            for (let e = 0; e < i; e++) {
                                const l = 1 & e ? r : s,
                                    h = t - t / i * e;
                                for (let t = 0; t < n; t++) {
                                    let e = t / n * (2 * Math.PI),
                                        i = Math.sin(e) * h,
                                        r = Math.cos(e) * h;
                                    a.push(i, 0, r), o.push(l.r, l.g, l.b), e = (t + 1) / n * (2 * Math.PI), i = Math.sin(e) * h, r = Math.cos(e) * h, a.push(i, 0, r), o.push(l.r, l.g, l.b)
                                }
                            }
                            const l = new hr;
                            l.setAttribute("position", new er(a, 3)), l.setAttribute("color", new er(o, 3)), super(l, new th({
                                vertexColors: !0,
                                toneMapped: !1
                            })), this.type = "PolarGridHelper"
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.PolyhedronGeometry = Jh, e.PositionalAudio = class extends ud {
                        constructor(t) {
                            super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                        }
                        connect() {
                            super.connect(), this.panner.connect(this.gain)
                        }
                        disconnect() {
                            super.disconnect(), this.panner.disconnect(this.gain)
                        }
                        getOutput() {
                            return this.panner
                        }
                        getRefDistance() {
                            return this.panner.refDistance
                        }
                        setRefDistance(t) {
                            return this.panner.refDistance = t, this
                        }
                        getRolloffFactor() {
                            return this.panner.rolloffFactor
                        }
                        setRolloffFactor(t) {
                            return this.panner.rolloffFactor = t, this
                        }
                        getDistanceModel() {
                            return this.panner.distanceModel
                        }
                        setDistanceModel(t) {
                            return this.panner.distanceModel = t, this
                        }
                        getMaxDistance() {
                            return this.panner.maxDistance
                        }
                        setMaxDistance(t) {
                            return this.panner.maxDistance = t, this
                        }
                        setDirectionalCone(t, e, i) {
                            return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
                        }
                        updateMatrixWorld(t) {
                            if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                            this.matrixWorld.decompose(dd, pd, md), fd.set(0, 0, 1).applyQuaternion(pd);
                            const e = this.panner;
                            if (e.positionX) {
                                const t = this.context.currentTime + this.listener.timeDelta;
                                e.positionX.linearRampToValueAtTime(dd.x, t), e.positionY.linearRampToValueAtTime(dd.y, t), e.positionZ.linearRampToValueAtTime(dd.z, t), e.orientationX.linearRampToValueAtTime(fd.x, t), e.orientationY.linearRampToValueAtTime(fd.y, t), e.orientationZ.linearRampToValueAtTime(fd.z, t)
                            } else e.setPosition(dd.x, dd.y, dd.z), e.setOrientation(fd.x, fd.y, fd.z)
                        }
                    }, e.PropertyBinding = Sd, e.PropertyMixer = gd, e.QuadraticBezierCurve = zh, e.QuadraticBezierCurve3 = Fh, e.Quaternion = yi, e.QuaternionKeyframeTrack = fu, e.QuaternionLinearInterpolant = mu, e.RED_GREEN_RGTC2_Format = ee, e.RED_RGTC1_Format = $t, e.REVISION = i, e.RGBADepthPacking = 3201, e.RGBAFormat = ft, e.RGBAIntegerFormat = wt, e.RGBA_ASTC_10x10_Format = qt, e.RGBA_ASTC_10x5_Format = Wt, e.RGBA_ASTC_10x6_Format = jt, e.RGBA_ASTC_10x8_Format = Xt, e.RGBA_ASTC_12x10_Format = Yt, e.RGBA_ASTC_12x12_Format = Jt, e.RGBA_ASTC_4x4_Format = Ot, e.RGBA_ASTC_5x4_Format = Bt, e.RGBA_ASTC_5x5_Format = zt, e.RGBA_ASTC_6x5_Format = Ft, e.RGBA_ASTC_6x6_Format = kt, e.RGBA_ASTC_8x5_Format = Vt, e.RGBA_ASTC_8x6_Format = Ht, e.RGBA_ASTC_8x8_Format = Gt, e.RGBA_BPTC_Format = Zt, e.RGBA_ETC2_EAC_Format = Dt, e.RGBA_PVRTC_2BPPV1_Format = Lt, e.RGBA_PVRTC_4BPPV1_Format = It, e.RGBA_S3TC_DXT1_Format = Tt, e.RGBA_S3TC_DXT3_Format = Et, e.RGBA_S3TC_DXT5_Format = Ct, e.RGBDepthPacking = 3202, e.RGBFormat = mt, e.RGBIntegerFormat = 1032, e.RGB_BPTC_SIGNED_Format = Kt, e.RGB_BPTC_UNSIGNED_Format = Qt, e.RGB_ETC1_Format = Ut, e.RGB_ETC2_Format = Nt, e.RGB_PVRTC_2BPPV1_Format = Pt, e.RGB_PVRTC_4BPPV1_Format = Rt, e.RGB_S3TC_DXT1_Format = At, e.RGDepthPacking = 3203, e.RGFormat = bt, e.RGIntegerFormat = St, e.RawShaderMaterial = jc, e.Ray = Ji, e.Raycaster = class {
                        constructor(t, e, i = 0, n = 1 / 0) {
                            this.ray = new Ji(t, e), this.near = i, this.far = n, this.camera = null, this.layers = new ln, this.params = {
                                Mesh: {},
                                Line: {
                                    threshold: 1
                                },
                                LOD: {},
                                Points: {
                                    threshold: 1
                                },
                                Sprite: {}
                            }
                        }
                        set(t, e) {
                            this.ray.set(t, e)
                        }
                        setFromCamera(t, e) {
                            e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                        }
                        setFromXRController(t) {
                            return Cd.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Cd), this
                        }
                        intersectObject(t, e = !0, i = []) {
                            return Pd(t, this, i, e), i.sort(Rd), i
                        }
                        intersectObjects(t, e = !0, i = []) {
                            for (let n = 0, r = t.length; n < r; n++) Pd(t[n], this, i, e);
                            return i.sort(Rd), i
                        }
                    }, e.Rec709Primaries = ve, e.RectAreaLight = Wu, e.RedFormat = xt, e.RedIntegerFormat = Mt, e.ReinhardToneMapping = L, e.RenderTarget = fi, e.RepeatWrapping = X, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingGeometry = Nc, e.SIGNED_RED_GREEN_RGTC2_Format = ie, e.SIGNED_RED_RGTC1_Format = te, e.SRGBColorSpace = ue, e.SRGBTransfer = ge, e.Scene = Ho, e.ShaderChunk = ts, e.ShaderLib = is, e.ShaderMaterial = Nr, e.ShadowMaterial = Wc, e.Shape = ic, e.ShapeGeometry = Dc, e.ShapePath = class {
                        constructor() {
                            this.type = "ShapePath", this.color = new kn, this.subPaths = [], this.currentPath = null
                        }
                        moveTo(t, e) {
                            return this.currentPath = new Gh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                        }
                        lineTo(t, e) {
                            return this.currentPath.lineTo(t, e), this
                        }
                        quadraticCurveTo(t, e, i, n) {
                            return this.currentPath.quadraticCurveTo(t, e, i, n), this
                        }
                        bezierCurveTo(t, e, i, n, r, s) {
                            return this.currentPath.bezierCurveTo(t, e, i, n, r, s), this
                        }
                        splineThru(t) {
                            return this.currentPath.splineThru(t), this
                        }
                        toShapes(t) {
                            function e(t, e) {
                                const i = e.length;
                                let n = !1;
                                for (let r = i - 1, s = 0; s < i; r = s++) {
                                    let i = e[r],
                                        a = e[s],
                                        o = a.x - i.x,
                                        l = a.y - i.y;
                                    if (Math.abs(l) > Number.EPSILON) {
                                        if (l < 0 && (i = e[s], o = -o, a = e[r], l = -l), t.y < i.y || t.y > a.y) continue;
                                        if (t.y === i.y) {
                                            if (t.x === i.x) return !0
                                        } else {
                                            const e = l * (t.x - i.x) - o * (t.y - i.y);
                                            if (0 === e) return !0;
                                            if (e < 0) continue;
                                            n = !n
                                        }
                                    } else {
                                        if (t.y !== i.y) continue;
                                        if (a.x <= t.x && t.x <= i.x || i.x <= t.x && t.x <= a.x) return !0
                                    }
                                }
                                return n
                            }
                            const i = Ec.isClockWise,
                                n = this.subPaths;
                            if (0 === n.length) return [];
                            let r, s, a;
                            const o = [];
                            if (1 === n.length) return s = n[0], a = new ic, a.curves = s.curves, o.push(a), o;
                            let l = !i(n[0].getPoints());
                            l = t ? !l : l;
                            const h = [],
                                c = [];
                            let u, d, p = [],
                                m = 0;
                            c[m] = void 0, p[m] = [];
                            for (let e = 0, a = n.length; e < a; e++) s = n[e], u = s.getPoints(), r = i(u), r = t ? !r : r, r ? (!l && c[m] && m++, c[m] = {
                                s: new ic,
                                p: u
                            }, c[m].s.curves = s.curves, l && m++, p[m] = []) : p[m].push({
                                h: s,
                                p: u[0]
                            });
                            if (!c[0]) return function(t) {
                                const e = [];
                                for (let i = 0, n = t.length; i < n; i++) {
                                    const n = t[i],
                                        r = new ic;
                                    r.curves = n.curves, e.push(r)
                                }
                                return e
                            }(n);
                            if (c.length > 1) {
                                let t = !1,
                                    i = 0;
                                for (let t = 0, e = c.length; t < e; t++) h[t] = [];
                                for (let n = 0, r = c.length; n < r; n++) {
                                    const r = p[n];
                                    for (let s = 0; s < r.length; s++) {
                                        const a = r[s];
                                        let o = !0;
                                        for (let r = 0; r < c.length; r++) e(a.p, c[r].p) && (n !== r && i++, o ? (o = !1, h[r].push(a)) : t = !0);
                                        o && h[n].push(a)
                                    }
                                }
                                i > 0 && !1 === t && (p = h)
                            }
                            for (let t = 0, e = c.length; t < e; t++) {
                                a = c[t].s, o.push(a), d = p[t];
                                for (let t = 0, e = d.length; t < e; t++) a.holes.push(d[t].h)
                            }
                            return o
                        }
                    }, e.ShapeUtils = Ec, e.ShortType = nt, e.Skeleton = Al, e.SkeletonHelper = class extends dh {
                        constructor(t) {
                            const e = Fd(t),
                                i = new hr,
                                n = [],
                                r = [],
                                s = new kn(0, 0, 1),
                                a = new kn(0, 1, 0);
                            for (let t = 0; t < e.length; t++) {
                                const i = e[t];
                                i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                            }
                            i.setAttribute("position", new er(n, 3)), i.setAttribute("color", new er(r, 3)), super(i, new th({
                                vertexColors: !0,
                                depthTest: !1,
                                depthWrite: !1,
                                toneMapped: !1,
                                transparent: !0
                            })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                        }
                        updateMatrixWorld(t) {
                            const e = this.bones,
                                i = this.geometry,
                                n = i.getAttribute("position");
                            zd.copy(this.root.matrixWorld).invert();
                            for (let t = 0, i = 0; t < e.length; t++) {
                                const r = e[t];
                                r.parent && r.parent.isBone && (Bd.multiplyMatrices(zd, r.matrixWorld), Od.setFromMatrixPosition(Bd), n.setXYZ(i, Od.x, Od.y, Od.z), Bd.multiplyMatrices(zd, r.parent.matrixWorld), Od.setFromMatrixPosition(Bd), n.setXYZ(i + 1, Od.x, Od.y, Od.z), i += 2)
                            }
                            i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                        }
                        dispose() {
                            this.geometry.dispose(), this.material.dispose()
                        }
                    }, e.SkinnedMesh = xl, e.Source = ci, e.Sphere = Vi, e.SphereGeometry = Oc, e.Spherical = class {
                        constructor(t = 1, e = 0, i = 0) {
                            return this.radius = t, this.phi = e, this.theta = i, this
                        }
                        set(t, e, i) {
                            return this.radius = t, this.phi = e, this.theta = i, this
                        }
                        copy(t) {
                            return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                        }
                        makeSafe() {
                            const t = 1e-6;
                            return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                        }
                        setFromVector3(t) {
                            return this.setFromCartesianCoords(t.x, t.y, t.z)
                        }
                        setFromCartesianCoords(t, e, i) {
                            return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(ze(e / this.radius, -1, 1))), this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }, e.SphericalHarmonics3 = ju, e.SplineCurve = kh, e.SpotLight = Du, e.SpotLightHelper = class extends wn {
                        constructor(t, e) {
                            super(), this.light = t, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper";
                            const i = new hr,
                                n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                            for (let t = 0, e = 1, i = 32; t < i; t++, e++) {
                                const r = t / i * Math.PI * 2,
                                    s = e / i * Math.PI * 2;
                                n.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
                            }
                            i.setAttribute("position", new er(n, 3));
                            const r = new th({
                                fog: !1,
                                toneMapped: !1
                            });
                            this.cone = new dh(i, r), this.add(this.cone), this.update()
                        }
                        dispose() {
                            this.cone.geometry.dispose(), this.cone.material.dispose()
                        }
                        update() {
                            this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
                            const t = this.light.distance ? this.light.distance : 1e3,
                                e = t * Math.tan(this.light.angle);
                            this.cone.scale.set(e, e, t), Dd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Dd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                        }
                    }, e.Sprite = al, e.SpriteMaterial = Xo, e.SrcAlphaFactor = g, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = Ce, e.StaticReadUsage = 35045, e.StereoCamera = class {
                        constructor() {
                            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Fr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Fr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                                focus: null,
                                fov: null,
                                aspect: null,
                                near: null,
                                far: null,
                                zoom: null,
                                eyeSep: null
                            }
                        }
                        update(t) {
                            const e = this._cache;
                            if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                                e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep, rd.copy(t.projectionMatrix);
                                const i = e.eyeSep / 2,
                                    n = i * e.near / e.focus,
                                    r = e.near * Math.tan(De * e.fov * .5) / e.zoom;
                                let s, a;
                                nd.elements[12] = -i, id.elements[12] = i, s = -r * e.aspect + n, a = r * e.aspect + n, rd.elements[0] = 2 * e.near / (a - s), rd.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(rd), s = -r * e.aspect - n, a = r * e.aspect - n, rd.elements[0] = 2 * e.near / (a - s), rd.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(rd)
                            }
                            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(nd), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(id)
                        }
                    }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = gu, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = {
                        ROTATE: 0,
                        PAN: 1,
                        DOLLY_PAN: 2,
                        DOLLY_ROTATE: 3
                    }, e.TangentSpaceNormalMap = 0, e.TetrahedronGeometry = Bc, e.Texture = pi, e.TextureLoader = class extends Su {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = new pi,
                                s = new Eu(this.manager);
                            return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                                r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                            }), i, n), r
                        }
                    }, e.TextureUtils = Eo, e.TorusGeometry = zc, e.TorusKnotGeometry = Fc, e.Triangle = Dn, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeGeometry = kc, e.UVMapping = k, e.Uint16BufferAttribute = $n, e.Uint32BufferAttribute = tr, e.Uint8BufferAttribute = class extends Qn {
                        constructor(t, e, i) {
                            super(new Uint8Array(t), e, i)
                        }
                    }, e.Uint8ClampedBufferAttribute = class extends Qn {
                        constructor(t, e, i) {
                            super(new Uint8ClampedArray(t), e, i)
                        }
                    }, e.Uniform = Td, e.UniformsGroup = class extends Le {
                        constructor() {
                            super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                                value: Ed++
                            }), this.name = "", this.usage = Ce, this.uniforms = []
                        }
                        add(t) {
                            return this.uniforms.push(t), this
                        }
                        remove(t) {
                            const e = this.uniforms.indexOf(t);
                            return -1 !== e && this.uniforms.splice(e, 1), this
                        }
                        setName(t) {
                            return this.name = t, this
                        }
                        setUsage(t) {
                            return this.usage = t, this
                        }
                        dispose() {
                            return this.dispatchEvent({
                                type: "dispose"
                            }), this
                        }
                        copy(t) {
                            this.name = t.name, this.usage = t.usage;
                            const e = t.uniforms;
                            this.uniforms.length = 0;
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = Array.isArray(e[t]) ? e[t] : [e[t]];
                                for (let t = 0; t < i.length; t++) this.uniforms.push(i[t].clone())
                            }
                            return this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }, e.UniformsLib = es, e.UniformsUtils = Ur, e.UnsignedByteType = et, e.UnsignedInt248Type = ut, e.UnsignedInt5999Type = dt, e.UnsignedIntType = at, e.UnsignedShort4444Type = ht, e.UnsignedShort5551Type = ct, e.UnsignedShortType = rt, e.VSMShadowMap = s, e.Vector2 = We, e.Vector3 = xi, e.Vector4 = mi, e.VectorKeyframeTrack = vu, e.VideoTexture = class extends pi {
                        constructor(t, e, i, n, r, s, a, o, l) {
                            super(t, e, i, n, r, s, a, o, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : Q, this.magFilter = void 0 !== r ? r : Q, this.generateMipmaps = !1;
                            const h = this;
                            "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                                h.needsUpdate = !0, t.requestVideoFrameCallback(e)
                            }))
                        }
                        clone() {
                            return new this.constructor(this.image).copy(this)
                        }
                        update() {
                            const t = this.image;
                            !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                        }
                    }, e.WebGL3DRenderTarget = class extends gi {
                        constructor(t = 1, e = 1, i = 1, n = {}) {
                            super(t, e, n), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new _i(null, t, e, i), this.texture.isRenderTargetTexture = !0
                        }
                    }, e.WebGLArrayRenderTarget = class extends gi {
                        constructor(t = 1, e = 1, i = 1, n = {}) {
                            super(t, e, n), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new vi(null, t, e, i), this.texture.isRenderTargetTexture = !0
                        }
                    }, e.WebGLCoordinateSystem = Pe, e.WebGLCubeRenderTarget = Gr, e.WebGLMultipleRenderTargets = class extends gi {
                        constructor(t = 1, e = 1, i = 1, n = {}) {
                            console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(t, e, {
                                ...n,
                                count: i
                            }), this.isWebGLMultipleRenderTargets = !0
                        }
                        get texture() {
                            return this.textures
                        }
                    }, e.WebGLRenderTarget = gi, e.WebGLRenderer = class {
                        constructor(t = {}) {
                            const {
                                canvas: e = Ke(),
                                context: n = null,
                                depth: r = !0,
                                stencil: s = !1,
                                alpha: a = !1,
                                antialias: o = !1,
                                premultipliedAlpha: l = !0,
                                preserveDrawingBuffer: h = !1,
                                powerPreference: c = "default",
                                failIfMajorPerformanceCaveat: u = !1
                            } = t;
                            let d;
                            if (this.isWebGLRenderer = !0, null !== n) {
                                if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                                d = n.getContextAttributes().alpha
                            } else d = a;
                            const p = new Uint32Array(4),
                                m = new Int32Array(4);
                            let f = null,
                                g = null;
                            const v = [],
                                _ = [];
                            this.domElement = e, this.debug = {
                                checkShaderErrors: !0,
                                onShaderError: null
                            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = ue, this.toneMapping = P, this.toneMappingExposure = 1;
                            const y = this;
                            let x = !1,
                                M = 0,
                                b = 0,
                                S = null,
                                w = -1,
                                A = null;
                            const T = new mi,
                                E = new mi;
                            let C = null;
                            const R = new kn(0);
                            let I = 0,
                                L = e.width,
                                U = e.height,
                                N = 1,
                                D = null,
                                O = null;
                            const B = new mi(0, 0, L, U),
                                z = new mi(0, 0, L, U);
                            let F = !1;
                            const k = new Zr;
                            let V = !1,
                                H = !1;
                            const G = new Zi,
                                W = new xi,
                                j = new mi,
                                X = {
                                    background: null,
                                    fog: null,
                                    environment: null,
                                    overrideMaterial: null,
                                    isScene: !0
                                };
                            let q = !1;

                            function Y() {
                                return null === S ? N : 1
                            }
                            let J, Z, K, Q, $, it, nt, st, ot, dt, pt, mt, ft, gt, vt, _t, yt, xt, bt, At, Tt, Et, Ct, Rt, Pt = n;

                            function It(t, i) {
                                return e.getContext(t, i)
                            }
                            try {
                                const t = {
                                    alpha: !0,
                                    depth: r,
                                    stencil: s,
                                    antialias: o,
                                    premultipliedAlpha: l,
                                    preserveDrawingBuffer: h,
                                    powerPreference: c,
                                    failIfMajorPerformanceCaveat: u
                                };
                                if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${i}`), e.addEventListener("webglcontextlost", Nt, !1), e.addEventListener("webglcontextrestored", Dt, !1), e.addEventListener("webglcontextcreationerror", Ot, !1), null === Pt) {
                                    const e = "webgl2";
                                    if (Pt = It(e, t), null === Pt) throw It(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                                }
                            } catch (t) {
                                throw console.error("THREE.WebGLRenderer: " + t.message), t
                            }

                            function Lt() {
                                J = new Rs(Pt), J.init(), Et = new Ro(Pt, J), Z = new hs(Pt, J, t, Et), K = new Ao(Pt), Q = new Ls(Pt), $ = new co, it = new Co(Pt, J, K, $, Z, Et, Q), nt = new us(y), st = new Cs(y), ot = new Qr(Pt), Ct = new os(Pt, ot), dt = new Ps(Pt, ot, Q, Ct), pt = new Ns(Pt, dt, ot, Q), bt = new Us(Pt, Z, it), _t = new cs($), mt = new ho(y, nt, st, J, Z, Ct, _t), ft = new zo(y, $), gt = new fo, vt = new Mo(J), xt = new as(y, nt, st, K, pt, d, l), yt = new wo(y, pt, Z), Rt = new Fo(Pt, Q, Z, K), At = new ls(Pt, J, Q), Tt = new Is(Pt, J, Q), Q.programs = mt.programs, y.capabilities = Z, y.extensions = J, y.properties = $, y.renderLists = gt, y.shadowMap = yt, y.state = K, y.info = Q
                            }
                            Lt();
                            const Ut = new Do(y, Pt);

                            function Nt(t) {
                                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
                            }

                            function Dt() {
                                console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
                                const t = Q.autoReset,
                                    e = yt.enabled,
                                    i = yt.autoUpdate,
                                    n = yt.needsUpdate,
                                    r = yt.type;
                                Lt(), Q.autoReset = t, yt.enabled = e, yt.autoUpdate = i, yt.needsUpdate = n, yt.type = r
                            }

                            function Ot(t) {
                                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
                            }

                            function Bt(t) {
                                const e = t.target;
                                e.removeEventListener("dispose", Bt),
                                    function(t) {
                                        (function(t) {
                                            const e = $.get(t).programs;
                                            void 0 !== e && (e.forEach((function(t) {
                                                mt.releaseProgram(t)
                                            })), t.isShaderMaterial && mt.releaseShaderCache(t))
                                        })(t), $.remove(t)
                                    }(e)
                            }

                            function zt(t, e, i) {
                                !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = 1, t.needsUpdate = !0, Yt(t, e, i), t.side = 0, t.needsUpdate = !0, Yt(t, e, i), t.side = 2) : Yt(t, e, i)
                            }
                            this.xr = Ut, this.getContext = function() {
                                return Pt
                            }, this.getContextAttributes = function() {
                                return Pt.getContextAttributes()
                            }, this.forceContextLoss = function() {
                                const t = J.get("WEBGL_lose_context");
                                t && t.loseContext()
                            }, this.forceContextRestore = function() {
                                const t = J.get("WEBGL_lose_context");
                                t && t.restoreContext()
                            }, this.getPixelRatio = function() {
                                return N
                            }, this.setPixelRatio = function(t) {
                                void 0 !== t && (N = t, this.setSize(L, U, !1))
                            }, this.getSize = function(t) {
                                return t.set(L, U)
                            }, this.setSize = function(t, i, n = !0) {
                                Ut.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = t, U = i, e.width = Math.floor(t * N), e.height = Math.floor(i * N), !0 === n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i))
                            }, this.getDrawingBufferSize = function(t) {
                                return t.set(L * N, U * N).floor()
                            }, this.setDrawingBufferSize = function(t, i, n) {
                                L = t, U = i, N = n, e.width = Math.floor(t * n), e.height = Math.floor(i * n), this.setViewport(0, 0, t, i)
                            }, this.getCurrentViewport = function(t) {
                                return t.copy(T)
                            }, this.getViewport = function(t) {
                                return t.copy(B)
                            }, this.setViewport = function(t, e, i, n) {
                                t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, i, n), K.viewport(T.copy(B).multiplyScalar(N).round())
                            }, this.getScissor = function(t) {
                                return t.copy(z)
                            }, this.setScissor = function(t, e, i, n) {
                                t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, i, n), K.scissor(E.copy(z).multiplyScalar(N).round())
                            }, this.getScissorTest = function() {
                                return F
                            }, this.setScissorTest = function(t) {
                                K.setScissorTest(F = t)
                            }, this.setOpaqueSort = function(t) {
                                D = t
                            }, this.setTransparentSort = function(t) {
                                O = t
                            }, this.getClearColor = function(t) {
                                return t.copy(xt.getClearColor())
                            }, this.setClearColor = function() {
                                xt.setClearColor.apply(xt, arguments)
                            }, this.getClearAlpha = function() {
                                return xt.getClearAlpha()
                            }, this.setClearAlpha = function() {
                                xt.setClearAlpha.apply(xt, arguments)
                            }, this.clear = function(t = !0, e = !0, i = !0) {
                                let n = 0;
                                if (t) {
                                    let t = !1;
                                    if (null !== S) {
                                        const e = S.texture.format;
                                        t = e === wt || e === St || e === Mt
                                    }
                                    if (t) {
                                        const t = S.texture.type,
                                            e = t === et || t === at || t === rt || t === ut || t === ht || t === ct,
                                            i = xt.getClearColor(),
                                            n = xt.getClearAlpha(),
                                            r = i.r,
                                            s = i.g,
                                            a = i.b;
                                        e ? (p[0] = r, p[1] = s, p[2] = a, p[3] = n, Pt.clearBufferuiv(Pt.COLOR, 0, p)) : (m[0] = r, m[1] = s, m[2] = a, m[3] = n, Pt.clearBufferiv(Pt.COLOR, 0, m))
                                    } else n |= Pt.COLOR_BUFFER_BIT
                                }
                                e && (n |= Pt.DEPTH_BUFFER_BIT), i && (n |= Pt.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Pt.clear(n)
                            }, this.clearColor = function() {
                                this.clear(!0, !1, !1)
                            }, this.clearDepth = function() {
                                this.clear(!1, !0, !1)
                            }, this.clearStencil = function() {
                                this.clear(!1, !1, !0)
                            }, this.dispose = function() {
                                e.removeEventListener("webglcontextlost", Nt, !1), e.removeEventListener("webglcontextrestored", Dt, !1), e.removeEventListener("webglcontextcreationerror", Ot, !1), gt.dispose(), vt.dispose(), $.dispose(), nt.dispose(), st.dispose(), pt.dispose(), Ct.dispose(), Rt.dispose(), mt.dispose(), Ut.dispose(), Ut.removeEventListener("sessionstart", kt), Ut.removeEventListener("sessionend", Vt), Ht.stop()
                            }, this.renderBufferDirect = function(t, e, i, n, r, s) {
                                null === e && (e = X);
                                const a = r.isMesh && r.matrixWorld.determinant() < 0,
                                    o = function(t, e, i, n, r) {
                                        !0 !== e.isScene && (e = X), it.resetTextureUnits();
                                        const s = e.fog,
                                            a = n.isMeshStandardMaterial ? e.environment : null,
                                            o = null === S ? y.outputColorSpace : !0 === S.isXRRenderTarget ? S.texture.colorSpace : de,
                                            l = (n.isMeshStandardMaterial ? st : nt).get(n.envMap || a),
                                            h = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize,
                                            c = !!i.attributes.tangent && (!!n.normalMap || n.anisotropy > 0),
                                            u = !!i.morphAttributes.position,
                                            d = !!i.morphAttributes.normal,
                                            p = !!i.morphAttributes.color;
                                        let m = P;
                                        n.toneMapped && (null !== S && !0 !== S.isXRRenderTarget || (m = y.toneMapping));
                                        const f = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color,
                                            v = void 0 !== f ? f.length : 0,
                                            _ = $.get(n),
                                            x = g.state.lights;
                                        if (!0 === V && (!0 === H || t !== A)) {
                                            const e = t === A && n.id === w;
                                            _t.setState(n, t, e)
                                        }
                                        let M = !1;
                                        n.version === _.__version ? _.needsLights && _.lightsStateVersion !== x.state.version || _.outputColorSpace !== o || r.isBatchedMesh && !1 === _.batching ? M = !0 : r.isBatchedMesh || !0 !== _.batching ? r.isBatchedMesh && !0 === _.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === _.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === _.instancing ? M = !0 : r.isInstancedMesh || !0 !== _.instancing ? r.isSkinnedMesh && !1 === _.skinning ? M = !0 : r.isSkinnedMesh || !0 !== _.skinning ? r.isInstancedMesh && !0 === _.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === _.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === _.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === _.instancingMorph && null !== r.morphTexture || _.envMap !== l || !0 === n.fog && _.fog !== s ? M = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === _t.numPlanes && _.numIntersection === _t.numIntersection ? (_.vertexAlphas !== h || _.vertexTangents !== c || _.morphTargets !== u || _.morphNormals !== d || _.morphColors !== p || _.toneMapping !== m || _.morphTargetsCount !== v) && (M = !0) : M = !0 : M = !0 : M = !0 : M = !0 : (M = !0, _.__version = n.version);
                                        let b = _.currentProgram;
                                        !0 === M && (b = Yt(n, e, r));
                                        let T = !1,
                                            E = !1,
                                            C = !1;
                                        const R = b.getUniforms(),
                                            I = _.uniforms;
                                        if (K.useProgram(b.program) && (T = !0, E = !0, C = !0), n.id !== w && (w = n.id, E = !0), T || A !== t) {
                                            R.setValue(Pt, "projectionMatrix", t.projectionMatrix), R.setValue(Pt, "viewMatrix", t.matrixWorldInverse);
                                            const e = R.map.cameraPosition;
                                            void 0 !== e && e.setValue(Pt, W.setFromMatrixPosition(t.matrixWorld)), Z.logarithmicDepthBuffer && R.setValue(Pt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && R.setValue(Pt, "isOrthographic", !0 === t.isOrthographicCamera), A !== t && (A = t, E = !0, C = !0)
                                        }
                                        if (r.isSkinnedMesh) {
                                            R.setOptional(Pt, r, "bindMatrix"), R.setOptional(Pt, r, "bindMatrixInverse");
                                            const t = r.skeleton;
                                            t && (null === t.boneTexture && t.computeBoneTexture(), R.setValue(Pt, "boneTexture", t.boneTexture, it))
                                        }
                                        r.isBatchedMesh && (R.setOptional(Pt, r, "batchingTexture"), R.setValue(Pt, "batchingTexture", r._matricesTexture, it), R.setOptional(Pt, r, "batchingIdTexture"), R.setValue(Pt, "batchingIdTexture", r._indirectTexture, it), R.setOptional(Pt, r, "batchingColorTexture"), null !== r._colorsTexture && R.setValue(Pt, "batchingColorTexture", r._colorsTexture, it));
                                        const L = i.morphAttributes;
                                        var D, O;
                                        if (void 0 === L.position && void 0 === L.normal && void 0 === L.color || bt.update(r, i, b), (E || _.receiveShadow !== r.receiveShadow) && (_.receiveShadow = r.receiveShadow, R.setValue(Pt, "receiveShadow", r.receiveShadow)), n.isMeshGouraudMaterial && null !== n.envMap && (I.envMap.value = l, I.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), n.isMeshStandardMaterial && null === n.envMap && null !== e.environment && (I.envMapIntensity.value = e.environmentIntensity), E && (R.setValue(Pt, "toneMappingExposure", y.toneMappingExposure), _.needsLights && (O = C, (D = I).ambientLightColor.needsUpdate = O, D.lightProbe.needsUpdate = O, D.directionalLights.needsUpdate = O, D.directionalLightShadows.needsUpdate = O, D.pointLights.needsUpdate = O, D.pointLightShadows.needsUpdate = O, D.spotLights.needsUpdate = O, D.spotLightShadows.needsUpdate = O, D.rectAreaLights.needsUpdate = O, D.hemisphereLights.needsUpdate = O), s && !0 === n.fog && ft.refreshFogUniforms(I, s), ft.refreshMaterialUniforms(I, n, N, U, g.state.transmissionRenderTarget[t.id]), ka.upload(Pt, Jt(_), I, it)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ka.upload(Pt, Jt(_), I, it), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && R.setValue(Pt, "center", r.center), R.setValue(Pt, "modelViewMatrix", r.modelViewMatrix), R.setValue(Pt, "normalMatrix", r.normalMatrix), R.setValue(Pt, "modelMatrix", r.matrixWorld), n.isShaderMaterial || n.isRawShaderMaterial) {
                                            const t = n.uniformsGroups;
                                            for (let e = 0, i = t.length; e < i; e++) {
                                                const i = t[e];
                                                Rt.update(i, b), Rt.bind(i, b)
                                            }
                                        }
                                        return b
                                    }(t, e, i, n, r);
                                K.setMaterial(n, a);
                                let l = i.index,
                                    h = 1;
                                if (!0 === n.wireframe) {
                                    if (l = dt.getWireframeAttribute(i), void 0 === l) return;
                                    h = 2
                                }
                                const c = i.drawRange,
                                    u = i.attributes.position;
                                let d = c.start * h,
                                    p = (c.start + c.count) * h;
                                null !== s && (d = Math.max(d, s.start * h), p = Math.min(p, (s.start + s.count) * h)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count));
                                const m = p - d;
                                if (m < 0 || m === 1 / 0) return;
                                let f;
                                Ct.setup(r, n, o, i, l);
                                let v = At;
                                if (null !== l && (f = ot.get(l), v = Tt, v.setIndex(f)), r.isMesh) !0 === n.wireframe ? (K.setLineWidth(n.wireframeLinewidth * Y()), v.setMode(Pt.LINES)) : v.setMode(Pt.TRIANGLES);
                                else if (r.isLine) {
                                    let t = n.linewidth;
                                    void 0 === t && (t = 1), K.setLineWidth(t * Y()), r.isLineSegments ? v.setMode(Pt.LINES) : r.isLineLoop ? v.setMode(Pt.LINE_LOOP) : v.setMode(Pt.LINE_STRIP)
                                } else r.isPoints ? v.setMode(Pt.POINTS) : r.isSprite && v.setMode(Pt.TRIANGLES);
                                if (r.isBatchedMesh)
                                    if (null !== r._multiDrawInstances) v.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                                    else if (J.get("WEBGL_multi_draw")) v.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                                else {
                                    const t = r._multiDrawStarts,
                                        e = r._multiDrawCounts,
                                        i = r._multiDrawCount,
                                        s = l ? ot.get(l).bytesPerElement : 1,
                                        a = $.get(n).currentProgram.getUniforms();
                                    for (let n = 0; n < i; n++) a.setValue(Pt, "_gl_DrawID", n), v.render(t[n] / s, e[n])
                                } else if (r.isInstancedMesh) v.renderInstances(d, m, r.count);
                                else if (i.isInstancedBufferGeometry) {
                                    const t = void 0 !== i._maxInstanceCount ? i._maxInstanceCount : 1 / 0,
                                        e = Math.min(i.instanceCount, t);
                                    v.renderInstances(d, m, e)
                                } else v.render(d, m)
                            }, this.compile = function(t, e, i = null) {
                                null === i && (i = t), g = vt.get(i), g.init(e), _.push(g), i.traverseVisible((function(t) {
                                    t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t))
                                })), t !== i && t.traverseVisible((function(t) {
                                    t.isLight && t.layers.test(e.layers) && (g.pushLight(t), t.castShadow && g.pushShadow(t))
                                })), g.setupLights();
                                const n = new Set;
                                return t.traverse((function(t) {
                                    const e = t.material;
                                    if (e)
                                        if (Array.isArray(e))
                                            for (let r = 0; r < e.length; r++) {
                                                const s = e[r];
                                                zt(s, i, t), n.add(s)
                                            } else zt(e, i, t), n.add(e)
                                })), _.pop(), g = null, n
                            }, this.compileAsync = function(t, e, i = null) {
                                const n = this.compile(t, e, i);
                                return new Promise((e => {
                                    function i() {
                                        n.forEach((function(t) {
                                            $.get(t).currentProgram.isReady() && n.delete(t)
                                        })), 0 !== n.size ? setTimeout(i, 10) : e(t)
                                    }
                                    null !== J.get("KHR_parallel_shader_compile") ? i() : setTimeout(i, 10)
                                }))
                            };
                            let Ft = null;

                            function kt() {
                                Ht.stop()
                            }

                            function Vt() {
                                Ht.start()
                            }
                            const Ht = new Kr;

                            function Gt(t, e, i, n) {
                                if (!1 === t.visible) return;
                                if (t.layers.test(e.layers))
                                    if (t.isGroup) i = t.renderOrder;
                                    else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                                else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t);
                                else if (t.isSprite) {
                                    if (!t.frustumCulled || k.intersectsSprite(t)) {
                                        n && j.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
                                        const e = pt.update(t),
                                            r = t.material;
                                        r.visible && f.push(t, e, r, i, j.z, null)
                                    }
                                } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || k.intersectsObject(t))) {
                                    const e = pt.update(t),
                                        r = t.material;
                                    if (n && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(), j.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(), j.copy(e.boundingSphere.center)), j.applyMatrix4(t.matrixWorld).applyMatrix4(G)), Array.isArray(r)) {
                                        const n = e.groups;
                                        for (let s = 0, a = n.length; s < a; s++) {
                                            const a = n[s],
                                                o = r[a.materialIndex];
                                            o && o.visible && f.push(t, e, o, i, j.z, a)
                                        }
                                    } else r.visible && f.push(t, e, r, i, j.z, null)
                                }
                                const r = t.children;
                                for (let t = 0, s = r.length; t < s; t++) Gt(r[t], e, i, n)
                            }

                            function Wt(t, e, i, n) {
                                const r = t.opaque,
                                    s = t.transmissive,
                                    a = t.transparent;
                                g.setupLightsView(i), !0 === V && _t.setGlobalState(y.clippingPlanes, i), n && K.viewport(T.copy(n)), r.length > 0 && Xt(r, e, i), s.length > 0 && Xt(s, e, i), a.length > 0 && Xt(a, e, i), K.buffers.depth.setTest(!0), K.buffers.depth.setMask(!0), K.buffers.color.setMask(!0), K.setPolygonOffset(!1)
                            }

                            function jt(t, e, i, n) {
                                if (null !== (!0 === i.isScene ? i.overrideMaterial : null)) return;
                                void 0 === g.state.transmissionRenderTarget[n.id] && (g.state.transmissionRenderTarget[n.id] = new gi(1, 1, {
                                    generateMipmaps: !0,
                                    type: J.has("EXT_color_buffer_half_float") || J.has("EXT_color_buffer_float") ? lt : et,
                                    minFilter: tt,
                                    samples: 4,
                                    stencilBuffer: s,
                                    resolveDepthBuffer: !1,
                                    resolveStencilBuffer: !1,
                                    colorSpace: ri.workingColorSpace
                                }));
                                const r = g.state.transmissionRenderTarget[n.id],
                                    a = n.viewport || T;
                                r.setSize(a.z, a.w);
                                const o = y.getRenderTarget();
                                y.setRenderTarget(r), y.getClearColor(R), I = y.getClearAlpha(), I < 1 && y.setClearColor(16777215, .5), y.clear(), q && xt.render(i);
                                const l = y.toneMapping;
                                y.toneMapping = P;
                                const h = n.viewport;
                                if (void 0 !== n.viewport && (n.viewport = void 0), g.setupLightsView(n), !0 === V && _t.setGlobalState(y.clippingPlanes, n), Xt(t, i, n), it.updateMultisampleRenderTarget(r), it.updateRenderTargetMipmap(r), !1 === J.has("WEBGL_multisampled_render_to_texture")) {
                                    let t = !1;
                                    for (let r = 0, s = e.length; r < s; r++) {
                                        const s = e[r],
                                            a = s.object,
                                            o = s.geometry,
                                            l = s.material,
                                            h = s.group;
                                        if (2 === l.side && a.layers.test(n.layers)) {
                                            const e = l.side;
                                            l.side = 1, l.needsUpdate = !0, qt(a, i, n, o, l, h), l.side = e, l.needsUpdate = !0, t = !0
                                        }
                                    }!0 === t && (it.updateMultisampleRenderTarget(r), it.updateRenderTargetMipmap(r))
                                }
                                y.setRenderTarget(o), y.setClearColor(R, I), void 0 !== h && (n.viewport = h), y.toneMapping = l
                            }

                            function Xt(t, e, i) {
                                const n = !0 === e.isScene ? e.overrideMaterial : null;
                                for (let r = 0, s = t.length; r < s; r++) {
                                    const s = t[r],
                                        a = s.object,
                                        o = s.geometry,
                                        l = null === n ? s.material : n,
                                        h = s.group;
                                    a.layers.test(i.layers) && qt(a, e, i, o, l, h)
                                }
                            }

                            function qt(t, e, i, n, r, s) {
                                t.onBeforeRender(y, e, i, n, r, s), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(y, e, i, n, t, s), !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1, r.needsUpdate = !0, y.renderBufferDirect(i, e, n, r, t, s), r.side = 0, r.needsUpdate = !0, y.renderBufferDirect(i, e, n, r, t, s), r.side = 2) : y.renderBufferDirect(i, e, n, r, t, s), t.onAfterRender(y, e, i, n, r, s)
                            }

                            function Yt(t, e, i) {
                                !0 !== e.isScene && (e = X);
                                const n = $.get(t),
                                    r = g.state.lights,
                                    s = g.state.shadowsArray,
                                    a = r.state.version,
                                    o = mt.getParameters(t, r.state, s, e, i),
                                    l = mt.getProgramCacheKey(o);
                                let h = n.programs;
                                n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (t.isMeshStandardMaterial ? st : nt).get(t.envMap || n.environment), n.envMapRotation = null !== n.environment && null === t.envMap ? e.environmentRotation : t.envMapRotation, void 0 === h && (t.addEventListener("dispose", Bt), h = new Map, n.programs = h);
                                let c = h.get(l);
                                if (void 0 !== c) {
                                    if (n.currentProgram === c && n.lightsStateVersion === a) return Zt(t, o), c
                                } else o.uniforms = mt.getUniforms(t), t.onBeforeCompile(o, y), c = mt.acquireProgram(o, l), h.set(l, c), n.uniforms = o.uniforms;
                                const u = n.uniforms;
                                return (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = _t.uniform), Zt(t, o), n.needsLights = function(t) {
                                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                                }(t), n.lightsStateVersion = a, n.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix), n.currentProgram = c, n.uniformsList = null, c
                            }

                            function Jt(t) {
                                if (null === t.uniformsList) {
                                    const e = t.currentProgram.getUniforms();
                                    t.uniformsList = ka.seqWithValue(e.seq, t.uniforms)
                                }
                                return t.uniformsList
                            }

                            function Zt(t, e) {
                                const i = $.get(t);
                                i.outputColorSpace = e.outputColorSpace, i.batching = e.batching, i.batchingColor = e.batchingColor, i.instancing = e.instancing, i.instancingColor = e.instancingColor, i.instancingMorph = e.instancingMorph, i.skinning = e.skinning, i.morphTargets = e.morphTargets, i.morphNormals = e.morphNormals, i.morphColors = e.morphColors, i.morphTargetsCount = e.morphTargetsCount, i.numClippingPlanes = e.numClippingPlanes, i.numIntersection = e.numClipIntersection, i.vertexAlphas = e.vertexAlphas, i.vertexTangents = e.vertexTangents, i.toneMapping = e.toneMapping
                            }
                            Ht.setAnimationLoop((function(t) {
                                Ft && Ft(t)
                            })), "undefined" != typeof self && Ht.setContext(self), this.setAnimationLoop = function(t) {
                                Ft = t, Ut.setAnimationLoop(t), null === t ? Ht.stop() : Ht.start()
                            }, Ut.addEventListener("sessionstart", kt), Ut.addEventListener("sessionend", Vt), this.render = function(t, e) {
                                if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                if (!0 === x) return;
                                if (!0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === Ut.enabled && !0 === Ut.isPresenting && (!0 === Ut.cameraAutoUpdate && Ut.updateCamera(e), e = Ut.getCamera()), !0 === t.isScene && t.onBeforeRender(y, t, e, S), g = vt.get(t, _.length), g.init(e), _.push(g), G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), k.setFromProjectionMatrix(G), H = this.localClippingEnabled, V = _t.init(this.clippingPlanes, H), f = gt.get(t, v.length), f.init(), v.push(f), !0 === Ut.enabled && !0 === Ut.isPresenting) {
                                    const t = y.xr.getDepthSensingMesh();
                                    null !== t && Gt(t, e, -1 / 0, y.sortObjects)
                                }
                                Gt(t, e, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(D, O), q = !1 === Ut.enabled || !1 === Ut.isPresenting || !1 === Ut.hasDepthSensing(), q && xt.addToRenderList(f, t), this.info.render.frame++, !0 === V && _t.beginShadows();
                                const i = g.state.shadowsArray;
                                yt.render(i, t, e), !0 === V && _t.endShadows(), !0 === this.info.autoReset && this.info.reset();
                                const n = f.opaque,
                                    r = f.transmissive;
                                if (g.setupLights(), e.isArrayCamera) {
                                    const i = e.cameras;
                                    if (r.length > 0)
                                        for (let e = 0, s = i.length; e < s; e++) jt(n, r, t, i[e]);
                                    q && xt.render(t);
                                    for (let e = 0, n = i.length; e < n; e++) {
                                        const n = i[e];
                                        Wt(f, t, n, n.viewport)
                                    }
                                } else r.length > 0 && jt(n, r, t, e), q && xt.render(t), Wt(f, t, e);
                                null !== S && (it.updateMultisampleRenderTarget(S), it.updateRenderTargetMipmap(S)), !0 === t.isScene && t.onAfterRender(y, t, e), Ct.resetDefaultState(), w = -1, A = null, _.pop(), _.length > 0 ? (g = _[_.length - 1], !0 === V && _t.setGlobalState(y.clippingPlanes, g.state.camera)) : g = null, v.pop(), f = v.length > 0 ? v[v.length - 1] : null
                            }, this.getActiveCubeFace = function() {
                                return M
                            }, this.getActiveMipmapLevel = function() {
                                return b
                            }, this.getRenderTarget = function() {
                                return S
                            }, this.setRenderTargetTextures = function(t, e, i) {
                                $.get(t.texture).__webglTexture = e, $.get(t.depthTexture).__webglTexture = i;
                                const n = $.get(t);
                                n.__hasExternalTextures = !0, n.__autoAllocateDepthBuffer = void 0 === i, n.__autoAllocateDepthBuffer || !0 === J.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n.__useRenderToTexture = !1)
                            }, this.setRenderTargetFramebuffer = function(t, e) {
                                const i = $.get(t);
                                i.__webglFramebuffer = e, i.__useDefaultFramebuffer = void 0 === e
                            }, this.setRenderTarget = function(t, e = 0, i = 0) {
                                S = t, M = e, b = i;
                                let n = !0,
                                    r = null,
                                    s = !1,
                                    a = !1;
                                if (t) {
                                    const o = $.get(t);
                                    if (void 0 !== o.__useDefaultFramebuffer) K.bindFramebuffer(Pt.FRAMEBUFFER, null), n = !1;
                                    else if (void 0 === o.__webglFramebuffer) it.setupRenderTarget(t);
                                    else if (o.__hasExternalTextures) it.rebindTextures(t, $.get(t.texture).__webglTexture, $.get(t.depthTexture).__webglTexture);
                                    else if (t.depthBuffer) {
                                        const e = t.depthTexture;
                                        if (o.__boundDepthTexture !== e) {
                                            if (null !== e && $.has(e) && (t.width !== e.image.width || t.height !== e.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                            it.setupDepthRenderbuffer(t)
                                        }
                                    }
                                    const l = t.texture;
                                    (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                                    const h = $.get(t).__webglFramebuffer;
                                    t.isWebGLCubeRenderTarget ? (r = Array.isArray(h[e]) ? h[e][i] : h[e], s = !0) : r = t.samples > 0 && !1 === it.useMultisampledRTT(t) ? $.get(t).__webglMultisampledFramebuffer : Array.isArray(h) ? h[i] : h, T.copy(t.viewport), E.copy(t.scissor), C = t.scissorTest
                                } else T.copy(B).multiplyScalar(N).floor(), E.copy(z).multiplyScalar(N).floor(), C = F;
                                if (K.bindFramebuffer(Pt.FRAMEBUFFER, r) && n && K.drawBuffers(t, r), K.viewport(T), K.scissor(E), K.setScissorTest(C), s) {
                                    const n = $.get(t.texture);
                                    Pt.framebufferTexture2D(Pt.FRAMEBUFFER, Pt.COLOR_ATTACHMENT0, Pt.TEXTURE_CUBE_MAP_POSITIVE_X + e, n.__webglTexture, i)
                                } else if (a) {
                                    const n = $.get(t.texture),
                                        r = e || 0;
                                    Pt.framebufferTextureLayer(Pt.FRAMEBUFFER, Pt.COLOR_ATTACHMENT0, n.__webglTexture, i || 0, r)
                                }
                                w = -1
                            }, this.readRenderTargetPixels = function(t, e, i, n, r, s, a) {
                                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                let o = $.get(t).__webglFramebuffer;
                                if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                                    K.bindFramebuffer(Pt.FRAMEBUFFER, o);
                                    try {
                                        const a = t.texture,
                                            o = a.format,
                                            l = a.type;
                                        if (!Z.textureFormatReadable(o)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                        if (!Z.textureTypeReadable(l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && Pt.readPixels(e, i, n, r, Et.convert(o), Et.convert(l), s)
                                    } finally {
                                        const t = null !== S ? $.get(S).__webglFramebuffer : null;
                                        K.bindFramebuffer(Pt.FRAMEBUFFER, t)
                                    }
                                }
                            }, this.readRenderTargetPixelsAsync = async function(t, e, i, n, r, s, a) {
                                if (!t || !t.isWebGLRenderTarget) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                let o = $.get(t).__webglFramebuffer;
                                if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                                    K.bindFramebuffer(Pt.FRAMEBUFFER, o);
                                    try {
                                        const a = t.texture,
                                            o = a.format,
                                            l = a.type;
                                        if (!Z.textureFormatReadable(o)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                        if (!Z.textureTypeReadable(l)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        if (e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r) {
                                            const t = Pt.createBuffer();
                                            Pt.bindBuffer(Pt.PIXEL_PACK_BUFFER, t), Pt.bufferData(Pt.PIXEL_PACK_BUFFER, s.byteLength, Pt.STREAM_READ), Pt.readPixels(e, i, n, r, Et.convert(o), Et.convert(l), 0), Pt.flush();
                                            const a = Pt.fenceSync(Pt.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                            await

                                            function(t, e) {
                                                return new Promise((function(i, n) {
                                                    setTimeout((function r() {
                                                        switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                                            case t.WAIT_FAILED:
                                                                n();
                                                                break;
                                                            case t.TIMEOUT_EXPIRED:
                                                                setTimeout(r, 4);
                                                                break;
                                                            default:
                                                                i()
                                                        }
                                                    }), 4)
                                                }))
                                            }(Pt, a);
                                            try {
                                                Pt.bindBuffer(Pt.PIXEL_PACK_BUFFER, t), Pt.getBufferSubData(Pt.PIXEL_PACK_BUFFER, 0, s)
                                            } finally {
                                                Pt.deleteBuffer(t), Pt.deleteSync(a)
                                            }
                                            return s
                                        }
                                    } finally {
                                        const t = null !== S ? $.get(S).__webglFramebuffer : null;
                                        K.bindFramebuffer(Pt.FRAMEBUFFER, t)
                                    }
                                }
                            }, this.copyFramebufferToTexture = function(t, e = null, i = 0) {
                                !0 !== t.isTexture && ($e("WebGLRenderer: copyFramebufferToTexture function signature has changed."), e = arguments[0] || null, t = arguments[1]);
                                const n = Math.pow(2, -i),
                                    r = Math.floor(t.image.width * n),
                                    s = Math.floor(t.image.height * n),
                                    a = null !== e ? e.x : 0,
                                    o = null !== e ? e.y : 0;
                                it.setTexture2D(t, 0), Pt.copyTexSubImage2D(Pt.TEXTURE_2D, i, 0, 0, a, o, r, s), K.unbindTexture()
                            }, this.copyTextureToTexture = function(t, e, i = null, n = null, r = 0) {
                                let s, a, o, l, h, c;
                                !0 !== t.isTexture && ($e("WebGLRenderer: copyTextureToTexture function signature has changed."), n = arguments[0] || null, t = arguments[1], e = arguments[2], r = arguments[3] || 0, i = null), null !== i ? (s = i.max.x - i.min.x, a = i.max.y - i.min.y, o = i.min.x, l = i.min.y) : (s = t.image.width, a = t.image.height, o = 0, l = 0), null !== n ? (h = n.x, c = n.y) : (h = 0, c = 0);
                                const u = Et.convert(e.format),
                                    d = Et.convert(e.type);
                                it.setTexture2D(e, 0), Pt.pixelStorei(Pt.UNPACK_FLIP_Y_WEBGL, e.flipY), Pt.pixelStorei(Pt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), Pt.pixelStorei(Pt.UNPACK_ALIGNMENT, e.unpackAlignment);
                                const p = Pt.getParameter(Pt.UNPACK_ROW_LENGTH),
                                    m = Pt.getParameter(Pt.UNPACK_IMAGE_HEIGHT),
                                    f = Pt.getParameter(Pt.UNPACK_SKIP_PIXELS),
                                    g = Pt.getParameter(Pt.UNPACK_SKIP_ROWS),
                                    v = Pt.getParameter(Pt.UNPACK_SKIP_IMAGES),
                                    _ = t.isCompressedTexture ? t.mipmaps[r] : t.image;
                                Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, _.width), Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, _.height), Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, o), Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, l), t.isDataTexture ? Pt.texSubImage2D(Pt.TEXTURE_2D, r, h, c, s, a, u, d, _.data) : t.isCompressedTexture ? Pt.compressedTexSubImage2D(Pt.TEXTURE_2D, r, h, c, _.width, _.height, u, _.data) : Pt.texSubImage2D(Pt.TEXTURE_2D, r, h, c, s, a, u, d, _), Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, p), Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, m), Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, f), Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, g), Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES, v), 0 === r && e.generateMipmaps && Pt.generateMipmap(Pt.TEXTURE_2D), K.unbindTexture()
                            }, this.copyTextureToTexture3D = function(t, e, i = null, n = null, r = 0) {
                                let s, a, o, l, h, c, u, d, p;
                                !0 !== t.isTexture && ($e("WebGLRenderer: copyTextureToTexture3D function signature has changed."), i = arguments[0] || null, n = arguments[1] || null, t = arguments[2], e = arguments[3], r = arguments[4] || 0);
                                const m = t.isCompressedTexture ? t.mipmaps[r] : t.image;
                                null !== i ? (s = i.max.x - i.min.x, a = i.max.y - i.min.y, o = i.max.z - i.min.z, l = i.min.x, h = i.min.y, c = i.min.z) : (s = m.width, a = m.height, o = m.depth, l = 0, h = 0, c = 0), null !== n ? (u = n.x, d = n.y, p = n.z) : (u = 0, d = 0, p = 0);
                                const f = Et.convert(e.format),
                                    g = Et.convert(e.type);
                                let v;
                                if (e.isData3DTexture) it.setTexture3D(e, 0), v = Pt.TEXTURE_3D;
                                else {
                                    if (!e.isDataArrayTexture && !e.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                                    it.setTexture2DArray(e, 0), v = Pt.TEXTURE_2D_ARRAY
                                }
                                Pt.pixelStorei(Pt.UNPACK_FLIP_Y_WEBGL, e.flipY), Pt.pixelStorei(Pt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), Pt.pixelStorei(Pt.UNPACK_ALIGNMENT, e.unpackAlignment);
                                const _ = Pt.getParameter(Pt.UNPACK_ROW_LENGTH),
                                    y = Pt.getParameter(Pt.UNPACK_IMAGE_HEIGHT),
                                    x = Pt.getParameter(Pt.UNPACK_SKIP_PIXELS),
                                    M = Pt.getParameter(Pt.UNPACK_SKIP_ROWS),
                                    b = Pt.getParameter(Pt.UNPACK_SKIP_IMAGES);
                                Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, m.width), Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, m.height), Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, l), Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, h), Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES, c), t.isDataTexture || t.isData3DTexture ? Pt.texSubImage3D(v, r, u, d, p, s, a, o, f, g, m.data) : e.isCompressedArrayTexture ? Pt.compressedTexSubImage3D(v, r, u, d, p, s, a, o, f, m.data) : Pt.texSubImage3D(v, r, u, d, p, s, a, o, f, g, m), Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH, _), Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT, y), Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS, x), Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS, M), Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES, b), 0 === r && e.generateMipmaps && Pt.generateMipmap(v), K.unbindTexture()
                            }, this.initRenderTarget = function(t) {
                                void 0 === $.get(t).__webglFramebuffer && it.setupRenderTarget(t)
                            }, this.initTexture = function(t) {
                                t.isCubeTexture ? it.setTextureCube(t, 0) : t.isData3DTexture ? it.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? it.setTexture2DArray(t, 0) : it.setTexture2D(t, 0), K.unbindTexture()
                            }, this.resetState = function() {
                                M = 0, b = 0, S = null, K.reset(), Ct.reset()
                            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                                detail: this
                            }))
                        }
                        get coordinateSystem() {
                            return Pe
                        }
                        get outputColorSpace() {
                            return this._outputColorSpace
                        }
                        set outputColorSpace(t) {
                            this._outputColorSpace = t;
                            const e = this.getContext();
                            e.drawingBufferColorSpace = t === pe ? "display-p3" : "srgb", e.unpackColorSpace = ri.workingColorSpace === me ? "display-p3" : "srgb"
                        }
                    }, e.WebGLUtils = Ro, e.WebGPUCoordinateSystem = Ie, e.WireframeGeometry = Vc, e.WrapAroundEnding = le, e.ZeroCurvatureEnding = ae, e.ZeroFactor = 200, e.ZeroSlopeEnding = oe, e.ZeroStencilOp = 0, e.createCanvasElement = Ke
                },
                979: (t, e, i) => {
                    "use strict";
                    i.d(e, {
                        $EB: () => s,
                        $Kf: () => pn,
                        $_I: () => v,
                        A$4: () => Fe,
                        B69: () => fe,
                        BKk: () => yi,
                        BRH: () => xr,
                        CVz: () => M,
                        EAD: () => vn,
                        GJx: () => p,
                        Gu$: () => qn,
                        Hit: () => sr,
                        I46: () => dn,
                        IE4: () => _,
                        Iw4: () => Ur,
                        LlO: () => _i,
                        LoY: () => Je,
                        MBL: () => or,
                        N1A: () => Tn,
                        O9p: () => Qt,
                        OuU: () => l,
                        PTz: () => ut,
                        Pq0: () => dt,
                        Q1f: () => Ie,
                        RiT: () => hr,
                        Riy: () => b,
                        THS: () => ze,
                        Tap: () => Mr,
                        V9B: () => De,
                        XrR: () => u,
                        Y9S: () => _r,
                        aHM: () => fr,
                        bCz: () => a,
                        bI3: () => R,
                        caT: () => c,
                        eaF: () => pi,
                        er$: () => P,
                        fCn: () => tn,
                        hB5: () => n,
                        hdd: () => h,
                        hsX: () => r,
                        hxR: () => f,
                        iNn: () => fi,
                        ie2: () => o,
                        k6Q: () => y,
                        kTp: () => x,
                        kn4: () => Ht,
                        lGw: () => Qn,
                        mrM: () => _n,
                        qU7: () => Xn,
                        qtW: () => Ve,
                        r6x: () => br,
                        tz3: () => cr,
                        zkh: () => en
                    });
                    const n = 0,
                        r = 1,
                        s = 2,
                        a = 5,
                        o = 204,
                        l = 205,
                        h = 206,
                        c = 0,
                        u = 2,
                        d = "attached",
                        p = 1e3,
                        m = 1001,
                        f = 1003,
                        g = 1006,
                        v = 1008,
                        _ = 33776,
                        y = 35840,
                        x = 35841,
                        M = 36196,
                        b = 37492,
                        S = 2300,
                        w = 2301,
                        A = 2302,
                        T = 2400,
                        E = 2401,
                        C = 2402,
                        R = 0,
                        P = "srgb",
                        I = "srgb-linear",
                        L = "display-p3",
                        U = "display-p3-linear",
                        N = "linear",
                        D = "srgb",
                        O = "rec709",
                        B = 7680;
                    class z {
                        addEventListener(t, e) {
                            void 0 === this._listeners && (this._listeners = {});
                            const i = this._listeners;
                            void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                        }
                        hasEventListener(t, e) {
                            if (void 0 === this._listeners) return !1;
                            const i = this._listeners;
                            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                        }
                        removeEventListener(t, e) {
                            if (void 0 === this._listeners) return;
                            const i = this._listeners[t];
                            if (void 0 !== i) {
                                const t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
                            }
                        }
                        dispatchEvent(t) {
                            if (void 0 === this._listeners) return;
                            const e = this._listeners[t.type];
                            if (void 0 !== e) {
                                t.target = this;
                                const i = e.slice(0);
                                for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
                                t.target = null
                            }
                        }
                    }
                    const F = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];

                    function k() {
                        const t = 4294967295 * Math.random() | 0,
                            e = 4294967295 * Math.random() | 0,
                            i = 4294967295 * Math.random() | 0,
                            n = 4294967295 * Math.random() | 0;
                        return (F[255 & t] + F[t >> 8 & 255] + F[t >> 16 & 255] + F[t >> 24 & 255] + "-" + F[255 & e] + F[e >> 8 & 255] + "-" + F[e >> 16 & 15 | 64] + F[e >> 24 & 255] + "-" + F[63 & i | 128] + F[i >> 8 & 255] + "-" + F[i >> 16 & 255] + F[i >> 24 & 255] + F[255 & n] + F[n >> 8 & 255] + F[n >> 16 & 255] + F[n >> 24 & 255]).toLowerCase()
                    }

                    function V(t, e, i) {
                        return Math.max(e, Math.min(i, t))
                    }

                    function H(t, e, i) {
                        return (1 - i) * t + i * e
                    }

                    function G(t, e) {
                        switch (e.constructor) {
                            case Float32Array:
                                return t;
                            case Uint32Array:
                                return t / 4294967295;
                            case Uint16Array:
                                return t / 65535;
                            case Uint8Array:
                                return t / 255;
                            case Int32Array:
                                return Math.max(t / 2147483647, -1);
                            case Int16Array:
                                return Math.max(t / 32767, -1);
                            case Int8Array:
                                return Math.max(t / 127, -1);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }

                    function W(t, e) {
                        switch (e.constructor) {
                            case Float32Array:
                                return t;
                            case Uint32Array:
                                return Math.round(4294967295 * t);
                            case Uint16Array:
                                return Math.round(65535 * t);
                            case Uint8Array:
                                return Math.round(255 * t);
                            case Int32Array:
                                return Math.round(2147483647 * t);
                            case Int16Array:
                                return Math.round(32767 * t);
                            case Int8Array:
                                return Math.round(127 * t);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }
                    Math.PI, Math.PI;
                    class j {
                        constructor(t = 0, e = 0) {
                            j.prototype.isVector2 = !0, this.x = t, this.y = e
                        }
                        get width() {
                            return this.x
                        }
                        set width(t) {
                            this.x = t
                        }
                        get height() {
                            return this.y
                        }
                        set height(t) {
                            this.y = t
                        }
                        set(t, e) {
                            return this.x = t, this.y = e, this
                        }
                        setScalar(t) {
                            return this.x = t, this.y = t, this
                        }
                        setX(t) {
                            return this.x = t, this
                        }
                        setY(t) {
                            return this.y = t, this
                        }
                        setComponent(t, e) {
                            switch (t) {
                                case 0:
                                    this.x = e;
                                    break;
                                case 1:
                                    this.y = e;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                            return this
                        }
                        getComponent(t) {
                            switch (t) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x, this.y)
                        }
                        copy(t) {
                            return this.x = t.x, this.y = t.y, this
                        }
                        add(t) {
                            return this.x += t.x, this.y += t.y, this
                        }
                        addScalar(t) {
                            return this.x += t, this.y += t, this
                        }
                        addVectors(t, e) {
                            return this.x = t.x + e.x, this.y = t.y + e.y, this
                        }
                        addScaledVector(t, e) {
                            return this.x += t.x * e, this.y += t.y * e, this
                        }
                        sub(t) {
                            return this.x -= t.x, this.y -= t.y, this
                        }
                        subScalar(t) {
                            return this.x -= t, this.y -= t, this
                        }
                        subVectors(t, e) {
                            return this.x = t.x - e.x, this.y = t.y - e.y, this
                        }
                        multiply(t) {
                            return this.x *= t.x, this.y *= t.y, this
                        }
                        multiplyScalar(t) {
                            return this.x *= t, this.y *= t, this
                        }
                        divide(t) {
                            return this.x /= t.x, this.y /= t.y, this
                        }
                        divideScalar(t) {
                            return this.multiplyScalar(1 / t)
                        }
                        applyMatrix3(t) {
                            const e = this.x,
                                i = this.y,
                                n = t.elements;
                            return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                        }
                        min(t) {
                            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                        }
                        max(t) {
                            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                        }
                        clamp(t, e) {
                            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                        }
                        clampScalar(t, e) {
                            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                        }
                        clampLength(t, e) {
                            const i = this.length();
                            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                        }
                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                        }
                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                        }
                        negate() {
                            return this.x = -this.x, this.y = -this.y, this
                        }
                        dot(t) {
                            return this.x * t.x + this.y * t.y
                        }
                        cross(t) {
                            return this.x * t.y - this.y * t.x
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        angle() {
                            return Math.atan2(-this.y, -this.x) + Math.PI
                        }
                        angleTo(t) {
                            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                            if (0 === e) return Math.PI / 2;
                            const i = this.dot(t) / e;
                            return Math.acos(V(i, -1, 1))
                        }
                        distanceTo(t) {
                            return Math.sqrt(this.distanceToSquared(t))
                        }
                        distanceToSquared(t) {
                            const e = this.x - t.x,
                                i = this.y - t.y;
                            return e * e + i * i
                        }
                        manhattanDistanceTo(t) {
                            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                        }
                        setLength(t) {
                            return this.normalize().multiplyScalar(t)
                        }
                        lerp(t, e) {
                            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                        }
                        lerpVectors(t, e, i) {
                            return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
                        }
                        equals(t) {
                            return t.x === this.x && t.y === this.y
                        }
                        fromArray(t, e = 0) {
                            return this.x = t[e], this.y = t[e + 1], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.x, t[e + 1] = this.y, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.x = t.getX(e), this.y = t.getY(e), this
                        }
                        rotateAround(t, e) {
                            const i = Math.cos(e),
                                n = Math.sin(e),
                                r = this.x - t.x,
                                s = this.y - t.y;
                            return this.x = r * i - s * n + t.x, this.y = r * n + s * i + t.y, this
                        }
                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this
                        }*[Symbol.iterator]() {
                            yield this.x, yield this.y
                        }
                    }
                    class X {
                        constructor(t, e, i, n, r, s, a, o, l) {
                            X.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, i, n, r, s, a, o, l)
                        }
                        set(t, e, i, n, r, s, a, o, l) {
                            const h = this.elements;
                            return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = o, h[6] = i, h[7] = s, h[8] = l, this
                        }
                        identity() {
                            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                        }
                        copy(t) {
                            const e = this.elements,
                                i = t.elements;
                            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                        }
                        extractBasis(t, e, i) {
                            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                        }
                        setFromMatrix4(t) {
                            const e = t.elements;
                            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                        }
                        multiply(t) {
                            return this.multiplyMatrices(this, t)
                        }
                        premultiply(t) {
                            return this.multiplyMatrices(t, this)
                        }
                        multiplyMatrices(t, e) {
                            const i = t.elements,
                                n = e.elements,
                                r = this.elements,
                                s = i[0],
                                a = i[3],
                                o = i[6],
                                l = i[1],
                                h = i[4],
                                c = i[7],
                                u = i[2],
                                d = i[5],
                                p = i[8],
                                m = n[0],
                                f = n[3],
                                g = n[6],
                                v = n[1],
                                _ = n[4],
                                y = n[7],
                                x = n[2],
                                M = n[5],
                                b = n[8];
                            return r[0] = s * m + a * v + o * x, r[3] = s * f + a * _ + o * M, r[6] = s * g + a * y + o * b, r[1] = l * m + h * v + c * x, r[4] = l * f + h * _ + c * M, r[7] = l * g + h * y + c * b, r[2] = u * m + d * v + p * x, r[5] = u * f + d * _ + p * M, r[8] = u * g + d * y + p * b, this
                        }
                        multiplyScalar(t) {
                            const e = this.elements;
                            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                        }
                        determinant() {
                            const t = this.elements,
                                e = t[0],
                                i = t[1],
                                n = t[2],
                                r = t[3],
                                s = t[4],
                                a = t[5],
                                o = t[6],
                                l = t[7],
                                h = t[8];
                            return e * s * h - e * a * l - i * r * h + i * a * o + n * r * l - n * s * o
                        }
                        invert() {
                            const t = this.elements,
                                e = t[0],
                                i = t[1],
                                n = t[2],
                                r = t[3],
                                s = t[4],
                                a = t[5],
                                o = t[6],
                                l = t[7],
                                h = t[8],
                                c = h * s - a * l,
                                u = a * o - h * r,
                                d = l * r - s * o,
                                p = e * c + i * u + n * d;
                            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const m = 1 / p;
                            return t[0] = c * m, t[1] = (n * l - h * i) * m, t[2] = (a * i - n * s) * m, t[3] = u * m, t[4] = (h * e - n * o) * m, t[5] = (n * r - a * e) * m, t[6] = d * m, t[7] = (i * o - l * e) * m, t[8] = (s * e - i * r) * m, this
                        }
                        transpose() {
                            let t;
                            const e = this.elements;
                            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                        }
                        getNormalMatrix(t) {
                            return this.setFromMatrix4(t).invert().transpose()
                        }
                        transposeIntoArray(t) {
                            const e = this.elements;
                            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                        }
                        setUvTransform(t, e, i, n, r, s, a) {
                            const o = Math.cos(r),
                                l = Math.sin(r);
                            return this.set(i * o, i * l, -i * (o * s + l * a) + s + t, -n * l, n * o, -n * (-l * s + o * a) + a + e, 0, 0, 1), this
                        }
                        scale(t, e) {
                            return this.premultiply(q.makeScale(t, e)), this
                        }
                        rotate(t) {
                            return this.premultiply(q.makeRotation(-t)), this
                        }
                        translate(t, e) {
                            return this.premultiply(q.makeTranslation(t, e)), this
                        }
                        makeTranslation(t, e) {
                            return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
                        }
                        makeRotation(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this
                        }
                        makeScale(t, e) {
                            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
                        }
                        equals(t) {
                            const e = this.elements,
                                i = t.elements;
                            for (let t = 0; t < 9; t++)
                                if (e[t] !== i[t]) return !1;
                            return !0
                        }
                        fromArray(t, e = 0) {
                            for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                            return this
                        }
                        toArray(t = [], e = 0) {
                            const i = this.elements;
                            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                        }
                        clone() {
                            return (new this.constructor).fromArray(this.elements)
                        }
                    }
                    const q = new X;

                    function Y(t) {
                        return document.createElementNS("http://www.w3.org/1999/xhtml", t)
                    }
                    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
                    const J = {};
                    const Z = (new X).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
                        K = (new X).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
                        Q = {
                            [I]: {
                                transfer: N,
                                primaries: O,
                                luminanceCoefficients: [.2126, .7152, .0722],
                                toReference: t => t,
                                fromReference: t => t
                            },
                            [P]: {
                                transfer: D,
                                primaries: O,
                                luminanceCoefficients: [.2126, .7152, .0722],
                                toReference: t => t.convertSRGBToLinear(),
                                fromReference: t => t.convertLinearToSRGB()
                            },
                            [U]: {
                                transfer: N,
                                primaries: "p3",
                                luminanceCoefficients: [.2289, .6917, .0793],
                                toReference: t => t.applyMatrix3(K),
                                fromReference: t => t.applyMatrix3(Z)
                            },
                            [L]: {
                                transfer: D,
                                primaries: "p3",
                                luminanceCoefficients: [.2289, .6917, .0793],
                                toReference: t => t.convertSRGBToLinear().applyMatrix3(K),
                                fromReference: t => t.applyMatrix3(Z).convertLinearToSRGB()
                            }
                        },
                        $ = new Set([I, U]),
                        tt = {
                            enabled: !0,
                            _workingColorSpace: I,
                            get workingColorSpace() {
                                return this._workingColorSpace
                            },
                            set workingColorSpace(t) {
                                if (!$.has(t)) throw new Error(`Unsupported working color space, "${t}".`);
                                this._workingColorSpace = t
                            },
                            convert: function(t, e, i) {
                                if (!1 === this.enabled || e === i || !e || !i) return t;
                                const n = Q[e].toReference;
                                return (0, Q[i].fromReference)(n(t))
                            },
                            fromWorkingColorSpace: function(t, e) {
                                return this.convert(t, this._workingColorSpace, e)
                            },
                            toWorkingColorSpace: function(t, e) {
                                return this.convert(t, e, this._workingColorSpace)
                            },
                            getPrimaries: function(t) {
                                return Q[t].primaries
                            },
                            getTransfer: function(t) {
                                return "" === t ? N : Q[t].transfer
                            },
                            getLuminanceCoefficients: function(t, e = this._workingColorSpace) {
                                return t.fromArray(Q[e].luminanceCoefficients)
                            }
                        };

                    function et(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }

                    function it(t) {
                        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                    }
                    let nt;
                    class rt {
                        static getDataURL(t) {
                            if (/^data:/i.test(t.src)) return t.src;
                            if ("undefined" == typeof HTMLCanvasElement) return t.src;
                            let e;
                            if (t instanceof HTMLCanvasElement) e = t;
                            else {
                                void 0 === nt && (nt = Y("canvas")), nt.width = t.width, nt.height = t.height;
                                const i = nt.getContext("2d");
                                t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = nt
                            }
                            return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                        }
                        static sRGBToLinear(t) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const e = Y("canvas");
                                e.width = t.width, e.height = t.height;
                                const i = e.getContext("2d");
                                i.drawImage(t, 0, 0, t.width, t.height);
                                const n = i.getImageData(0, 0, t.width, t.height),
                                    r = n.data;
                                for (let t = 0; t < r.length; t++) r[t] = 255 * et(r[t] / 255);
                                return i.putImageData(n, 0, 0), e
                            }
                            if (t.data) {
                                const e = t.data.slice(0);
                                for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * et(e[t] / 255)) : e[t] = et(e[t]);
                                return {
                                    data: e,
                                    width: t.width,
                                    height: t.height
                                }
                            }
                            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
                        }
                    }
                    let st = 0;
                    class at {
                        constructor(t = null) {
                            this.isSource = !0, Object.defineProperty(this, "id", {
                                value: st++
                            }), this.uuid = k(), this.data = t, this.dataReady = !0, this.version = 0
                        }
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t;
                            if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                            const i = {
                                    uuid: this.uuid,
                                    url: ""
                                },
                                n = this.data;
                            if (null !== n) {
                                let t;
                                if (Array.isArray(n)) {
                                    t = [];
                                    for (let e = 0, i = n.length; e < i; e++) n[e].isDataTexture ? t.push(ot(n[e].image)) : t.push(ot(n[e]))
                                } else t = ot(n);
                                i.url = t
                            }
                            return e || (t.images[this.uuid] = i), i
                        }
                    }

                    function ot(t) {
                        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? rt.getDataURL(t) : t.data ? {
                            data: Array.from(t.data),
                            width: t.width,
                            height: t.height,
                            type: t.data.constructor.name
                        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                    }
                    let lt = 0;
                    class ht extends z {
                        constructor(t = ht.DEFAULT_IMAGE, e = ht.DEFAULT_MAPPING, i = 1001, n = 1001, r = 1006, s = v, a = 1023, o = 1009, l = ht.DEFAULT_ANISOTROPY, h = "") {
                            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                                value: lt++
                            }), this.uuid = k(), this.name = "", this.source = new at(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new j(0, 0), this.repeat = new j(1, 1), this.center = new j(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new X, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
                        }
                        get image() {
                            return this.source.data
                        }
                        set image(t = null) {
                            this.source.data = t
                        }
                        updateMatrix() {
                            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t;
                            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                            const i = {
                                metadata: {
                                    version: 4.6,
                                    type: "Texture",
                                    generator: "Texture.toJSON"
                                },
                                uuid: this.uuid,
                                name: this.name,
                                image: this.source.toJSON(t).uuid,
                                mapping: this.mapping,
                                channel: this.channel,
                                repeat: [this.repeat.x, this.repeat.y],
                                offset: [this.offset.x, this.offset.y],
                                center: [this.center.x, this.center.y],
                                rotation: this.rotation,
                                wrap: [this.wrapS, this.wrapT],
                                format: this.format,
                                internalFormat: this.internalFormat,
                                type: this.type,
                                colorSpace: this.colorSpace,
                                minFilter: this.minFilter,
                                magFilter: this.magFilter,
                                anisotropy: this.anisotropy,
                                flipY: this.flipY,
                                generateMipmaps: this.generateMipmaps,
                                premultiplyAlpha: this.premultiplyAlpha,
                                unpackAlignment: this.unpackAlignment
                            };
                            return Object.keys(this.userData).length > 0 && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                        transformUv(t) {
                            if (300 !== this.mapping) return t;
                            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                                case p:
                                    t.x = t.x - Math.floor(t.x);
                                    break;
                                case m:
                                    t.x = t.x < 0 ? 0 : 1;
                                    break;
                                case 1002:
                                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                            }
                            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                                case p:
                                    t.y = t.y - Math.floor(t.y);
                                    break;
                                case m:
                                    t.y = t.y < 0 ? 0 : 1;
                                    break;
                                case 1002:
                                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                            }
                            return this.flipY && (t.y = 1 - t.y), t
                        }
                        set needsUpdate(t) {
                            !0 === t && (this.version++, this.source.needsUpdate = !0)
                        }
                        set needsPMREMUpdate(t) {
                            !0 === t && this.pmremVersion++
                        }
                    }
                    ht.DEFAULT_IMAGE = null, ht.DEFAULT_MAPPING = 300, ht.DEFAULT_ANISOTROPY = 1;
                    class ct {
                        constructor(t = 0, e = 0, i = 0, n = 1) {
                            ct.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = i, this.w = n
                        }
                        get width() {
                            return this.z
                        }
                        set width(t) {
                            this.z = t
                        }
                        get height() {
                            return this.w
                        }
                        set height(t) {
                            this.w = t
                        }
                        set(t, e, i, n) {
                            return this.x = t, this.y = e, this.z = i, this.w = n, this
                        }
                        setScalar(t) {
                            return this.x = t, this.y = t, this.z = t, this.w = t, this
                        }
                        setX(t) {
                            return this.x = t, this
                        }
                        setY(t) {
                            return this.y = t, this
                        }
                        setZ(t) {
                            return this.z = t, this
                        }
                        setW(t) {
                            return this.w = t, this
                        }
                        setComponent(t, e) {
                            switch (t) {
                                case 0:
                                    this.x = e;
                                    break;
                                case 1:
                                    this.y = e;
                                    break;
                                case 2:
                                    this.z = e;
                                    break;
                                case 3:
                                    this.w = e;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                            return this
                        }
                        getComponent(t) {
                            switch (t) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                case 3:
                                    return this.w;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x, this.y, this.z, this.w)
                        }
                        copy(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                        }
                        add(t) {
                            return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
                        }
                        addScalar(t) {
                            return this.x += t, this.y += t, this.z += t, this.w += t, this
                        }
                        addVectors(t, e) {
                            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                        }
                        addScaledVector(t, e) {
                            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                        }
                        sub(t) {
                            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
                        }
                        subScalar(t) {
                            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                        }
                        subVectors(t, e) {
                            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                        }
                        multiply(t) {
                            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                        }
                        multiplyScalar(t) {
                            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                        }
                        applyMatrix4(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = this.w,
                                s = t.elements;
                            return this.x = s[0] * e + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * e + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * e + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * e + s[7] * i + s[11] * n + s[15] * r, this
                        }
                        divideScalar(t) {
                            return this.multiplyScalar(1 / t)
                        }
                        setAxisAngleFromQuaternion(t) {
                            this.w = 2 * Math.acos(t.w);
                            const e = Math.sqrt(1 - t.w * t.w);
                            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                        }
                        setAxisAngleFromRotationMatrix(t) {
                            let e, i, n, r;
                            const s = .01,
                                a = .1,
                                o = t.elements,
                                l = o[0],
                                h = o[4],
                                c = o[8],
                                u = o[1],
                                d = o[5],
                                p = o[9],
                                m = o[2],
                                f = o[6],
                                g = o[10];
                            if (Math.abs(h - u) < s && Math.abs(c - m) < s && Math.abs(p - f) < s) {
                                if (Math.abs(h + u) < a && Math.abs(c + m) < a && Math.abs(p + f) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                                e = Math.PI;
                                const t = (l + 1) / 2,
                                    o = (d + 1) / 2,
                                    v = (g + 1) / 2,
                                    _ = (h + u) / 4,
                                    y = (c + m) / 4,
                                    x = (p + f) / 4;
                                return t > o && t > v ? t < s ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(t), n = _ / i, r = y / i) : o > v ? o < s ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(o), i = _ / n, r = x / n) : v < s ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(v), i = y / r, n = x / r), this.set(i, n, r, e), this
                            }
                            let v = Math.sqrt((f - p) * (f - p) + (c - m) * (c - m) + (u - h) * (u - h));
                            return Math.abs(v) < .001 && (v = 1), this.x = (f - p) / v, this.y = (c - m) / v, this.z = (u - h) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                        }
                        setFromMatrixPosition(t) {
                            const e = t.elements;
                            return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this
                        }
                        min(t) {
                            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                        }
                        max(t) {
                            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                        }
                        clamp(t, e) {
                            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                        }
                        clampScalar(t, e) {
                            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                        }
                        clampLength(t, e) {
                            const i = this.length();
                            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                        }
                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                        }
                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                        }
                        negate() {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                        }
                        dot(t) {
                            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        setLength(t) {
                            return this.normalize().multiplyScalar(t)
                        }
                        lerp(t, e) {
                            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                        }
                        lerpVectors(t, e, i) {
                            return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
                        }
                        equals(t) {
                            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                        }
                        fromArray(t, e = 0) {
                            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                        }
                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                        }*[Symbol.iterator]() {
                            yield this.x, yield this.y, yield this.z, yield this.w
                        }
                    }
                    class ut {
                        constructor(t = 0, e = 0, i = 0, n = 1) {
                            this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = n
                        }
                        static slerpFlat(t, e, i, n, r, s, a) {
                            let o = i[n + 0],
                                l = i[n + 1],
                                h = i[n + 2],
                                c = i[n + 3];
                            const u = r[s + 0],
                                d = r[s + 1],
                                p = r[s + 2],
                                m = r[s + 3];
                            if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = h, void(t[e + 3] = c);
                            if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = m);
                            if (c !== m || o !== u || l !== d || h !== p) {
                                let t = 1 - a;
                                const e = o * u + l * d + h * p + c * m,
                                    i = e >= 0 ? 1 : -1,
                                    n = 1 - e * e;
                                if (n > Number.EPSILON) {
                                    const r = Math.sqrt(n),
                                        s = Math.atan2(r, e * i);
                                    t = Math.sin(t * s) / r, a = Math.sin(a * s) / r
                                }
                                const r = a * i;
                                if (o = o * t + u * r, l = l * t + d * r, h = h * t + p * r, c = c * t + m * r, t === 1 - a) {
                                    const t = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
                                    o *= t, l *= t, h *= t, c *= t
                                }
                            }
                            t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
                        }
                        static multiplyQuaternionsFlat(t, e, i, n, r, s) {
                            const a = i[n],
                                o = i[n + 1],
                                l = i[n + 2],
                                h = i[n + 3],
                                c = r[s],
                                u = r[s + 1],
                                d = r[s + 2],
                                p = r[s + 3];
                            return t[e] = a * p + h * c + o * d - l * u, t[e + 1] = o * p + h * u + l * c - a * d, t[e + 2] = l * p + h * d + a * u - o * c, t[e + 3] = h * p - a * c - o * u - l * d, t
                        }
                        get x() {
                            return this._x
                        }
                        set x(t) {
                            this._x = t, this._onChangeCallback()
                        }
                        get y() {
                            return this._y
                        }
                        set y(t) {
                            this._y = t, this._onChangeCallback()
                        }
                        get z() {
                            return this._z
                        }
                        set z(t) {
                            this._z = t, this._onChangeCallback()
                        }
                        get w() {
                            return this._w
                        }
                        set w(t) {
                            this._w = t, this._onChangeCallback()
                        }
                        set(t, e, i, n) {
                            return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
                        }
                        clone() {
                            return new this.constructor(this._x, this._y, this._z, this._w)
                        }
                        copy(t) {
                            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                        }
                        setFromEuler(t, e = !0) {
                            const i = t._x,
                                n = t._y,
                                r = t._z,
                                s = t._order,
                                a = Math.cos,
                                o = Math.sin,
                                l = a(i / 2),
                                h = a(n / 2),
                                c = a(r / 2),
                                u = o(i / 2),
                                d = o(n / 2),
                                p = o(r / 2);
                            switch (s) {
                                case "XYZ":
                                    this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                                    break;
                                case "YXZ":
                                    this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                                    break;
                                case "ZXY":
                                    this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                                    break;
                                case "ZYX":
                                    this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                                    break;
                                case "YZX":
                                    this._x = u * h * c + l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c - u * d * p;
                                    break;
                                case "XZY":
                                    this._x = u * h * c - l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c + u * d * p;
                                    break;
                                default:
                                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                            }
                            return !0 === e && this._onChangeCallback(), this
                        }
                        setFromAxisAngle(t, e) {
                            const i = e / 2,
                                n = Math.sin(i);
                            return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                        }
                        setFromRotationMatrix(t) {
                            const e = t.elements,
                                i = e[0],
                                n = e[4],
                                r = e[8],
                                s = e[1],
                                a = e[5],
                                o = e[9],
                                l = e[2],
                                h = e[6],
                                c = e[10],
                                u = i + a + c;
                            if (u > 0) {
                                const t = .5 / Math.sqrt(u + 1);
                                this._w = .25 / t, this._x = (h - o) * t, this._y = (r - l) * t, this._z = (s - n) * t
                            } else if (i > a && i > c) {
                                const t = 2 * Math.sqrt(1 + i - a - c);
                                this._w = (h - o) / t, this._x = .25 * t, this._y = (n + s) / t, this._z = (r + l) / t
                            } else if (a > c) {
                                const t = 2 * Math.sqrt(1 + a - i - c);
                                this._w = (r - l) / t, this._x = (n + s) / t, this._y = .25 * t, this._z = (o + h) / t
                            } else {
                                const t = 2 * Math.sqrt(1 + c - i - a);
                                this._w = (s - n) / t, this._x = (r + l) / t, this._y = (o + h) / t, this._z = .25 * t
                            }
                            return this._onChangeCallback(), this
                        }
                        setFromUnitVectors(t, e) {
                            let i = t.dot(e) + 1;
                            return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize()
                        }
                        angleTo(t) {
                            return 2 * Math.acos(Math.abs(V(this.dot(t), -1, 1)))
                        }
                        rotateTowards(t, e) {
                            const i = this.angleTo(t);
                            if (0 === i) return this;
                            const n = Math.min(1, e / i);
                            return this.slerp(t, n), this
                        }
                        identity() {
                            return this.set(0, 0, 0, 1)
                        }
                        invert() {
                            return this.conjugate()
                        }
                        conjugate() {
                            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                        }
                        dot(t) {
                            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                        }
                        lengthSq() {
                            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                        }
                        length() {
                            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                        }
                        normalize() {
                            let t = this.length();
                            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                        }
                        multiply(t) {
                            return this.multiplyQuaternions(this, t)
                        }
                        premultiply(t) {
                            return this.multiplyQuaternions(t, this)
                        }
                        multiplyQuaternions(t, e) {
                            const i = t._x,
                                n = t._y,
                                r = t._z,
                                s = t._w,
                                a = e._x,
                                o = e._y,
                                l = e._z,
                                h = e._w;
                            return this._x = i * h + s * a + n * l - r * o, this._y = n * h + s * o + r * a - i * l, this._z = r * h + s * l + i * o - n * a, this._w = s * h - i * a - n * o - r * l, this._onChangeCallback(), this
                        }
                        slerp(t, e) {
                            if (0 === e) return this;
                            if (1 === e) return this.copy(t);
                            const i = this._x,
                                n = this._y,
                                r = this._z,
                                s = this._w;
                            let a = s * t._w + i * t._x + n * t._y + r * t._z;
                            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                            const o = 1 - a * a;
                            if (o <= Number.EPSILON) {
                                const t = 1 - e;
                                return this._w = t * s + e * this._w, this._x = t * i + e * this._x, this._y = t * n + e * this._y, this._z = t * r + e * this._z, this.normalize(), this
                            }
                            const l = Math.sqrt(o),
                                h = Math.atan2(l, a),
                                c = Math.sin((1 - e) * h) / l,
                                u = Math.sin(e * h) / l;
                            return this._w = s * c + this._w * u, this._x = i * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this
                        }
                        slerpQuaternions(t, e, i) {
                            return this.copy(t).slerp(e, i)
                        }
                        random() {
                            const t = 2 * Math.PI * Math.random(),
                                e = 2 * Math.PI * Math.random(),
                                i = Math.random(),
                                n = Math.sqrt(1 - i),
                                r = Math.sqrt(i);
                            return this.set(n * Math.sin(t), n * Math.cos(t), r * Math.sin(e), r * Math.cos(e))
                        }
                        equals(t) {
                            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                        }
                        fromArray(t, e = 0) {
                            return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                        }
                        fromBufferAttribute(t, e) {
                            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
                        }
                        toJSON() {
                            return this.toArray()
                        }
                        _onChange(t) {
                            return this._onChangeCallback = t, this
                        }
                        _onChangeCallback() {}*[Symbol.iterator]() {
                            yield this._x, yield this._y, yield this._z, yield this._w
                        }
                    }
                    class dt {
                        constructor(t = 0, e = 0, i = 0) {
                            dt.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i
                        }
                        set(t, e, i) {
                            return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
                        }
                        setScalar(t) {
                            return this.x = t, this.y = t, this.z = t, this
                        }
                        setX(t) {
                            return this.x = t, this
                        }
                        setY(t) {
                            return this.y = t, this
                        }
                        setZ(t) {
                            return this.z = t, this
                        }
                        setComponent(t, e) {
                            switch (t) {
                                case 0:
                                    this.x = e;
                                    break;
                                case 1:
                                    this.y = e;
                                    break;
                                case 2:
                                    this.z = e;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                            return this
                        }
                        getComponent(t) {
                            switch (t) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                default:
                                    throw new Error("index is out of range: " + t)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x, this.y, this.z)
                        }
                        copy(t) {
                            return this.x = t.x, this.y = t.y, this.z = t.z, this
                        }
                        add(t) {
                            return this.x += t.x, this.y += t.y, this.z += t.z, this
                        }
                        addScalar(t) {
                            return this.x += t, this.y += t, this.z += t, this
                        }
                        addVectors(t, e) {
                            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                        }
                        addScaledVector(t, e) {
                            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                        }
                        sub(t) {
                            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
                        }
                        subScalar(t) {
                            return this.x -= t, this.y -= t, this.z -= t, this
                        }
                        subVectors(t, e) {
                            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                        }
                        multiply(t) {
                            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
                        }
                        multiplyScalar(t) {
                            return this.x *= t, this.y *= t, this.z *= t, this
                        }
                        multiplyVectors(t, e) {
                            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                        }
                        applyEuler(t) {
                            return this.applyQuaternion(mt.setFromEuler(t))
                        }
                        applyAxisAngle(t, e) {
                            return this.applyQuaternion(mt.setFromAxisAngle(t, e))
                        }
                        applyMatrix3(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.elements;
                            return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                        }
                        applyNormalMatrix(t) {
                            return this.applyMatrix3(t).normalize()
                        }
                        applyMatrix4(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.elements,
                                s = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                            return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * s, this
                        }
                        applyQuaternion(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.x,
                                s = t.y,
                                a = t.z,
                                o = t.w,
                                l = 2 * (s * n - a * i),
                                h = 2 * (a * e - r * n),
                                c = 2 * (r * i - s * e);
                            return this.x = e + o * l + s * c - a * h, this.y = i + o * h + a * l - r * c, this.z = n + o * c + r * h - s * l, this
                        }
                        project(t) {
                            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                        }
                        unproject(t) {
                            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                        }
                        transformDirection(t) {
                            const e = this.x,
                                i = this.y,
                                n = this.z,
                                r = t.elements;
                            return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                        }
                        divide(t) {
                            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                        }
                        divideScalar(t) {
                            return this.multiplyScalar(1 / t)
                        }
                        min(t) {
                            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                        }
                        max(t) {
                            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                        }
                        clamp(t, e) {
                            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                        }
                        clampScalar(t, e) {
                            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                        }
                        clampLength(t, e) {
                            const i = this.length();
                            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                        }
                        floor() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                        }
                        round() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                        }
                        negate() {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                        }
                        dot(t) {
                            return this.x * t.x + this.y * t.y + this.z * t.z
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        setLength(t) {
                            return this.normalize().multiplyScalar(t)
                        }
                        lerp(t, e) {
                            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                        }
                        lerpVectors(t, e, i) {
                            return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
                        }
                        cross(t) {
                            return this.crossVectors(this, t)
                        }
                        crossVectors(t, e) {
                            const i = t.x,
                                n = t.y,
                                r = t.z,
                                s = e.x,
                                a = e.y,
                                o = e.z;
                            return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
                        }
                        projectOnVector(t) {
                            const e = t.lengthSq();
                            if (0 === e) return this.set(0, 0, 0);
                            const i = t.dot(this) / e;
                            return this.copy(t).multiplyScalar(i)
                        }
                        projectOnPlane(t) {
                            return pt.copy(this).projectOnVector(t), this.sub(pt)
                        }
                        reflect(t) {
                            return this.sub(pt.copy(t).multiplyScalar(2 * this.dot(t)))
                        }
                        angleTo(t) {
                            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                            if (0 === e) return Math.PI / 2;
                            const i = this.dot(t) / e;
                            return Math.acos(V(i, -1, 1))
                        }
                        distanceTo(t) {
                            return Math.sqrt(this.distanceToSquared(t))
                        }
                        distanceToSquared(t) {
                            const e = this.x - t.x,
                                i = this.y - t.y,
                                n = this.z - t.z;
                            return e * e + i * i + n * n
                        }
                        manhattanDistanceTo(t) {
                            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                        }
                        setFromSpherical(t) {
                            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                        }
                        setFromSphericalCoords(t, e, i) {
                            const n = Math.sin(e) * t;
                            return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                        }
                        setFromCylindrical(t) {
                            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                        }
                        setFromCylindricalCoords(t, e, i) {
                            return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                        }
                        setFromMatrixPosition(t) {
                            const e = t.elements;
                            return this.x = e[12], this.y = e[13], this.z = e[14], this
                        }
                        setFromMatrixScale(t) {
                            const e = this.setFromMatrixColumn(t, 0).length(),
                                i = this.setFromMatrixColumn(t, 1).length(),
                                n = this.setFromMatrixColumn(t, 2).length();
                            return this.x = e, this.y = i, this.z = n, this
                        }
                        setFromMatrixColumn(t, e) {
                            return this.fromArray(t.elements, 4 * e)
                        }
                        setFromMatrix3Column(t, e) {
                            return this.fromArray(t.elements, 3 * e)
                        }
                        setFromEuler(t) {
                            return this.x = t._x, this.y = t._y, this.z = t._z, this
                        }
                        setFromColor(t) {
                            return this.x = t.r, this.y = t.g, this.z = t.b, this
                        }
                        equals(t) {
                            return t.x === this.x && t.y === this.y && t.z === this.z
                        }
                        fromArray(t, e = 0) {
                            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                        }
                        random() {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                        }
                        randomDirection() {
                            const t = Math.random() * Math.PI * 2,
                                e = 2 * Math.random() - 1,
                                i = Math.sqrt(1 - e * e);
                            return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this
                        }*[Symbol.iterator]() {
                            yield this.x, yield this.y, yield this.z
                        }
                    }
                    const pt = new dt,
                        mt = new ut;
                    class ft {
                        constructor(t = new dt(1 / 0, 1 / 0, 1 / 0), e = new dt(-1 / 0, -1 / 0, -1 / 0)) {
                            this.isBox3 = !0, this.min = t, this.max = e
                        }
                        set(t, e) {
                            return this.min.copy(t), this.max.copy(e), this
                        }
                        setFromArray(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.length; e < i; e += 3) this.expandByPoint(vt.fromArray(t, e));
                            return this
                        }
                        setFromBufferAttribute(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.count; e < i; e++) this.expandByPoint(vt.fromBufferAttribute(t, e));
                            return this
                        }
                        setFromPoints(t) {
                            this.makeEmpty();
                            for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                            return this
                        }
                        setFromCenterAndSize(t, e) {
                            const i = vt.copy(e).multiplyScalar(.5);
                            return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                        }
                        setFromObject(t, e = !1) {
                            return this.makeEmpty(), this.expandByObject(t, e)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.min.copy(t.min), this.max.copy(t.max), this
                        }
                        makeEmpty() {
                            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                        }
                        isEmpty() {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                        }
                        getCenter(t) {
                            return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                        }
                        getSize(t) {
                            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                        }
                        expandByPoint(t) {
                            return this.min.min(t), this.max.max(t), this
                        }
                        expandByVector(t) {
                            return this.min.sub(t), this.max.add(t), this
                        }
                        expandByScalar(t) {
                            return this.min.addScalar(-t), this.max.addScalar(t), this
                        }
                        expandByObject(t, e = !1) {
                            t.updateWorldMatrix(!1, !1);
                            const i = t.geometry;
                            if (void 0 !== i) {
                                const n = i.getAttribute("position");
                                if (!0 === e && void 0 !== n && !0 !== t.isInstancedMesh)
                                    for (let e = 0, i = n.count; e < i; e++) !0 === t.isMesh ? t.getVertexPosition(e, vt) : vt.fromBufferAttribute(n, e), vt.applyMatrix4(t.matrixWorld), this.expandByPoint(vt);
                                else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), _t.copy(t.boundingBox)) : (null === i.boundingBox && i.computeBoundingBox(), _t.copy(i.boundingBox)), _t.applyMatrix4(t.matrixWorld), this.union(_t)
                            }
                            const n = t.children;
                            for (let t = 0, i = n.length; t < i; t++) this.expandByObject(n[t], e);
                            return this
                        }
                        containsPoint(t) {
                            return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z
                        }
                        containsBox(t) {
                            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                        }
                        getParameter(t, e) {
                            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                        }
                        intersectsBox(t) {
                            return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z
                        }
                        intersectsSphere(t) {
                            return this.clampPoint(t.center, vt), vt.distanceToSquared(t.center) <= t.radius * t.radius
                        }
                        intersectsPlane(t) {
                            let e, i;
                            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                        }
                        intersectsTriangle(t) {
                            if (this.isEmpty()) return !1;
                            this.getCenter(At), Tt.subVectors(this.max, At), yt.subVectors(t.a, At), xt.subVectors(t.b, At), Mt.subVectors(t.c, At), bt.subVectors(xt, yt), St.subVectors(Mt, xt), wt.subVectors(yt, Mt);
                            let e = [0, -bt.z, bt.y, 0, -St.z, St.y, 0, -wt.z, wt.y, bt.z, 0, -bt.x, St.z, 0, -St.x, wt.z, 0, -wt.x, -bt.y, bt.x, 0, -St.y, St.x, 0, -wt.y, wt.x, 0];
                            return !!Rt(e, yt, xt, Mt, Tt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Rt(e, yt, xt, Mt, Tt) && (Et.crossVectors(bt, St), e = [Et.x, Et.y, Et.z], Rt(e, yt, xt, Mt, Tt)))
                        }
                        clampPoint(t, e) {
                            return e.copy(t).clamp(this.min, this.max)
                        }
                        distanceToPoint(t) {
                            return this.clampPoint(t, vt).distanceTo(t)
                        }
                        getBoundingSphere(t) {
                            return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(vt).length()), t
                        }
                        intersect(t) {
                            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                        }
                        union(t) {
                            return this.min.min(t.min), this.max.max(t.max), this
                        }
                        applyMatrix4(t) {
                            return this.isEmpty() || (gt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), gt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), gt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), gt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), gt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), gt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), gt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), gt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(gt)), this
                        }
                        translate(t) {
                            return this.min.add(t), this.max.add(t), this
                        }
                        equals(t) {
                            return t.min.equals(this.min) && t.max.equals(this.max)
                        }
                    }
                    const gt = [new dt, new dt, new dt, new dt, new dt, new dt, new dt, new dt],
                        vt = new dt,
                        _t = new ft,
                        yt = new dt,
                        xt = new dt,
                        Mt = new dt,
                        bt = new dt,
                        St = new dt,
                        wt = new dt,
                        At = new dt,
                        Tt = new dt,
                        Et = new dt,
                        Ct = new dt;

                    function Rt(t, e, i, n, r) {
                        for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                            Ct.fromArray(t, s);
                            const a = r.x * Math.abs(Ct.x) + r.y * Math.abs(Ct.y) + r.z * Math.abs(Ct.z),
                                o = e.dot(Ct),
                                l = i.dot(Ct),
                                h = n.dot(Ct);
                            if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1
                        }
                        return !0
                    }
                    const Pt = new ft,
                        It = new dt,
                        Lt = new dt;
                    class Ut {
                        constructor(t = new dt, e = -1) {
                            this.isSphere = !0, this.center = t, this.radius = e
                        }
                        set(t, e) {
                            return this.center.copy(t), this.radius = e, this
                        }
                        setFromPoints(t, e) {
                            const i = this.center;
                            void 0 !== e ? i.copy(e) : Pt.setFromPoints(t).getCenter(i);
                            let n = 0;
                            for (let e = 0, r = t.length; e < r; e++) n = Math.max(n, i.distanceToSquared(t[e]));
                            return this.radius = Math.sqrt(n), this
                        }
                        copy(t) {
                            return this.center.copy(t.center), this.radius = t.radius, this
                        }
                        isEmpty() {
                            return this.radius < 0
                        }
                        makeEmpty() {
                            return this.center.set(0, 0, 0), this.radius = -1, this
                        }
                        containsPoint(t) {
                            return t.distanceToSquared(this.center) <= this.radius * this.radius
                        }
                        distanceToPoint(t) {
                            return t.distanceTo(this.center) - this.radius
                        }
                        intersectsSphere(t) {
                            const e = this.radius + t.radius;
                            return t.center.distanceToSquared(this.center) <= e * e
                        }
                        intersectsBox(t) {
                            return t.intersectsSphere(this)
                        }
                        intersectsPlane(t) {
                            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                        }
                        clampPoint(t, e) {
                            const i = this.center.distanceToSquared(t);
                            return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                        }
                        getBoundingBox(t) {
                            return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                        }
                        applyMatrix4(t) {
                            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                        }
                        translate(t) {
                            return this.center.add(t), this
                        }
                        expandByPoint(t) {
                            if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                            It.subVectors(t, this.center);
                            const e = It.lengthSq();
                            if (e > this.radius * this.radius) {
                                const t = Math.sqrt(e),
                                    i = .5 * (t - this.radius);
                                this.center.addScaledVector(It, i / t), this.radius += i
                            }
                            return this
                        }
                        union(t) {
                            return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Lt.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(It.copy(t.center).add(Lt)), this.expandByPoint(It.copy(t.center).sub(Lt))), this)
                        }
                        equals(t) {
                            return t.center.equals(this.center) && t.radius === this.radius
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const Nt = new dt,
                        Dt = new dt,
                        Ot = new dt,
                        Bt = new dt,
                        zt = new dt,
                        Ft = new dt,
                        kt = new dt;
                    class Vt {
                        constructor(t = new dt, e = new dt(0, 0, -1)) {
                            this.origin = t, this.direction = e
                        }
                        set(t, e) {
                            return this.origin.copy(t), this.direction.copy(e), this
                        }
                        copy(t) {
                            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                        }
                        at(t, e) {
                            return e.copy(this.origin).addScaledVector(this.direction, t)
                        }
                        lookAt(t) {
                            return this.direction.copy(t).sub(this.origin).normalize(), this
                        }
                        recast(t) {
                            return this.origin.copy(this.at(t, Nt)), this
                        }
                        closestPointToPoint(t, e) {
                            e.subVectors(t, this.origin);
                            const i = e.dot(this.direction);
                            return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i)
                        }
                        distanceToPoint(t) {
                            return Math.sqrt(this.distanceSqToPoint(t))
                        }
                        distanceSqToPoint(t) {
                            const e = Nt.subVectors(t, this.origin).dot(this.direction);
                            return e < 0 ? this.origin.distanceToSquared(t) : (Nt.copy(this.origin).addScaledVector(this.direction, e), Nt.distanceToSquared(t))
                        }
                        distanceSqToSegment(t, e, i, n) {
                            Dt.copy(t).add(e).multiplyScalar(.5), Ot.copy(e).sub(t).normalize(), Bt.copy(this.origin).sub(Dt);
                            const r = .5 * t.distanceTo(e),
                                s = -this.direction.dot(Ot),
                                a = Bt.dot(this.direction),
                                o = -Bt.dot(Ot),
                                l = Bt.lengthSq(),
                                h = Math.abs(1 - s * s);
                            let c, u, d, p;
                            if (h > 0)
                                if (c = s * o - a, u = s * a - o, p = r * h, c >= 0)
                                    if (u >= -p)
                                        if (u <= p) {
                                            const t = 1 / h;
                                            c *= t, u *= t, d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l
                                        } else u = r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                            else u = -r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                            else u <= -p ? (c = Math.max(0, -(-s * r + a)), u = c > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l) : u <= p ? (c = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (c = Math.max(0, -(s * r + a)), u = c > 0 ? r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l);
                            else u = s > 0 ? -r : r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                            return i && i.copy(this.origin).addScaledVector(this.direction, c), n && n.copy(Dt).addScaledVector(Ot, u), d
                        }
                        intersectSphere(t, e) {
                            Nt.subVectors(t.center, this.origin);
                            const i = Nt.dot(this.direction),
                                n = Nt.dot(Nt) - i * i,
                                r = t.radius * t.radius;
                            if (n > r) return null;
                            const s = Math.sqrt(r - n),
                                a = i - s,
                                o = i + s;
                            return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                        }
                        intersectsSphere(t) {
                            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                        }
                        distanceToPlane(t) {
                            const e = t.normal.dot(this.direction);
                            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                            const i = -(this.origin.dot(t.normal) + t.constant) / e;
                            return i >= 0 ? i : null
                        }
                        intersectPlane(t, e) {
                            const i = this.distanceToPlane(t);
                            return null === i ? null : this.at(i, e)
                        }
                        intersectsPlane(t) {
                            const e = t.distanceToPoint(this.origin);
                            return 0 === e || t.normal.dot(this.direction) * e < 0
                        }
                        intersectBox(t, e) {
                            let i, n, r, s, a, o;
                            const l = 1 / this.direction.x,
                                h = 1 / this.direction.y,
                                c = 1 / this.direction.z,
                                u = this.origin;
                            return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, s = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, s = (t.min.y - u.y) * h), i > s || r > n ? null : ((r > i || isNaN(i)) && (i = r), (s < n || isNaN(n)) && (n = s), c >= 0 ? (a = (t.min.z - u.z) * c, o = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, o = (t.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                        }
                        intersectsBox(t) {
                            return null !== this.intersectBox(t, Nt)
                        }
                        intersectTriangle(t, e, i, n, r) {
                            zt.subVectors(e, t), Ft.subVectors(i, t), kt.crossVectors(zt, Ft);
                            let s, a = this.direction.dot(kt);
                            if (a > 0) {
                                if (n) return null;
                                s = 1
                            } else {
                                if (!(a < 0)) return null;
                                s = -1, a = -a
                            }
                            Bt.subVectors(this.origin, t);
                            const o = s * this.direction.dot(Ft.crossVectors(Bt, Ft));
                            if (o < 0) return null;
                            const l = s * this.direction.dot(zt.cross(Bt));
                            if (l < 0) return null;
                            if (o + l > a) return null;
                            const h = -s * Bt.dot(kt);
                            return h < 0 ? null : this.at(h / a, r)
                        }
                        applyMatrix4(t) {
                            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                        }
                        equals(t) {
                            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    class Ht {
                        constructor(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
                            Ht.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f)
                        }
                        set(t, e, i, n, r, s, a, o, l, h, c, u, d, p, m, f) {
                            const g = this.elements;
                            return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                        }
                        identity() {
                            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                        clone() {
                            return (new Ht).fromArray(this.elements)
                        }
                        copy(t) {
                            const e = this.elements,
                                i = t.elements;
                            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                        }
                        copyPosition(t) {
                            const e = this.elements,
                                i = t.elements;
                            return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                        }
                        setFromMatrix3(t) {
                            const e = t.elements;
                            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                        }
                        extractBasis(t, e, i) {
                            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                        }
                        makeBasis(t, e, i) {
                            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                        }
                        extractRotation(t) {
                            const e = this.elements,
                                i = t.elements,
                                n = 1 / Gt.setFromMatrixColumn(t, 0).length(),
                                r = 1 / Gt.setFromMatrixColumn(t, 1).length(),
                                s = 1 / Gt.setFromMatrixColumn(t, 2).length();
                            return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * s, e[9] = i[9] * s, e[10] = i[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                        }
                        makeRotationFromEuler(t) {
                            const e = this.elements,
                                i = t.x,
                                n = t.y,
                                r = t.z,
                                s = Math.cos(i),
                                a = Math.sin(i),
                                o = Math.cos(n),
                                l = Math.sin(n),
                                h = Math.cos(r),
                                c = Math.sin(r);
                            if ("XYZ" === t.order) {
                                const t = s * h,
                                    i = s * c,
                                    n = a * h,
                                    r = a * c;
                                e[0] = o * h, e[4] = -o * c, e[8] = l, e[1] = i + n * l, e[5] = t - r * l, e[9] = -a * o, e[2] = r - t * l, e[6] = n + i * l, e[10] = s * o
                            } else if ("YXZ" === t.order) {
                                const t = o * h,
                                    i = o * c,
                                    n = l * h,
                                    r = l * c;
                                e[0] = t + r * a, e[4] = n * a - i, e[8] = s * l, e[1] = s * c, e[5] = s * h, e[9] = -a, e[2] = i * a - n, e[6] = r + t * a, e[10] = s * o
                            } else if ("ZXY" === t.order) {
                                const t = o * h,
                                    i = o * c,
                                    n = l * h,
                                    r = l * c;
                                e[0] = t - r * a, e[4] = -s * c, e[8] = n + i * a, e[1] = i + n * a, e[5] = s * h, e[9] = r - t * a, e[2] = -s * l, e[6] = a, e[10] = s * o
                            } else if ("ZYX" === t.order) {
                                const t = s * h,
                                    i = s * c,
                                    n = a * h,
                                    r = a * c;
                                e[0] = o * h, e[4] = n * l - i, e[8] = t * l + r, e[1] = o * c, e[5] = r * l + t, e[9] = i * l - n, e[2] = -l, e[6] = a * o, e[10] = s * o
                            } else if ("YZX" === t.order) {
                                const t = s * o,
                                    i = s * l,
                                    n = a * o,
                                    r = a * l;
                                e[0] = o * h, e[4] = r - t * c, e[8] = n * c + i, e[1] = c, e[5] = s * h, e[9] = -a * h, e[2] = -l * h, e[6] = i * c + n, e[10] = t - r * c
                            } else if ("XZY" === t.order) {
                                const t = s * o,
                                    i = s * l,
                                    n = a * o,
                                    r = a * l;
                                e[0] = o * h, e[4] = -c, e[8] = l * h, e[1] = t * c + r, e[5] = s * h, e[9] = i * c - n, e[2] = n * c - i, e[6] = a * h, e[10] = r * c + t
                            }
                            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                        }
                        makeRotationFromQuaternion(t) {
                            return this.compose(jt, t, Xt)
                        }
                        lookAt(t, e, i) {
                            const n = this.elements;
                            return Jt.subVectors(t, e), 0 === Jt.lengthSq() && (Jt.z = 1), Jt.normalize(), qt.crossVectors(i, Jt), 0 === qt.lengthSq() && (1 === Math.abs(i.z) ? Jt.x += 1e-4 : Jt.z += 1e-4, Jt.normalize(), qt.crossVectors(i, Jt)), qt.normalize(), Yt.crossVectors(Jt, qt), n[0] = qt.x, n[4] = Yt.x, n[8] = Jt.x, n[1] = qt.y, n[5] = Yt.y, n[9] = Jt.y, n[2] = qt.z, n[6] = Yt.z, n[10] = Jt.z, this
                        }
                        multiply(t) {
                            return this.multiplyMatrices(this, t)
                        }
                        premultiply(t) {
                            return this.multiplyMatrices(t, this)
                        }
                        multiplyMatrices(t, e) {
                            const i = t.elements,
                                n = e.elements,
                                r = this.elements,
                                s = i[0],
                                a = i[4],
                                o = i[8],
                                l = i[12],
                                h = i[1],
                                c = i[5],
                                u = i[9],
                                d = i[13],
                                p = i[2],
                                m = i[6],
                                f = i[10],
                                g = i[14],
                                v = i[3],
                                _ = i[7],
                                y = i[11],
                                x = i[15],
                                M = n[0],
                                b = n[4],
                                S = n[8],
                                w = n[12],
                                A = n[1],
                                T = n[5],
                                E = n[9],
                                C = n[13],
                                R = n[2],
                                P = n[6],
                                I = n[10],
                                L = n[14],
                                U = n[3],
                                N = n[7],
                                D = n[11],
                                O = n[15];
                            return r[0] = s * M + a * A + o * R + l * U, r[4] = s * b + a * T + o * P + l * N, r[8] = s * S + a * E + o * I + l * D, r[12] = s * w + a * C + o * L + l * O, r[1] = h * M + c * A + u * R + d * U, r[5] = h * b + c * T + u * P + d * N, r[9] = h * S + c * E + u * I + d * D, r[13] = h * w + c * C + u * L + d * O, r[2] = p * M + m * A + f * R + g * U, r[6] = p * b + m * T + f * P + g * N, r[10] = p * S + m * E + f * I + g * D, r[14] = p * w + m * C + f * L + g * O, r[3] = v * M + _ * A + y * R + x * U, r[7] = v * b + _ * T + y * P + x * N, r[11] = v * S + _ * E + y * I + x * D, r[15] = v * w + _ * C + y * L + x * O, this
                        }
                        multiplyScalar(t) {
                            const e = this.elements;
                            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                        }
                        determinant() {
                            const t = this.elements,
                                e = t[0],
                                i = t[4],
                                n = t[8],
                                r = t[12],
                                s = t[1],
                                a = t[5],
                                o = t[9],
                                l = t[13],
                                h = t[2],
                                c = t[6],
                                u = t[10],
                                d = t[14];
                            return t[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + t[11] * (+e * l * c - e * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + t[15] * (-n * a * h - e * o * c + e * a * u + n * s * c - i * s * u + i * o * h)
                        }
                        transpose() {
                            const t = this.elements;
                            let e;
                            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                        }
                        setPosition(t, e, i) {
                            const n = this.elements;
                            return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
                        }
                        invert() {
                            const t = this.elements,
                                e = t[0],
                                i = t[1],
                                n = t[2],
                                r = t[3],
                                s = t[4],
                                a = t[5],
                                o = t[6],
                                l = t[7],
                                h = t[8],
                                c = t[9],
                                u = t[10],
                                d = t[11],
                                p = t[12],
                                m = t[13],
                                f = t[14],
                                g = t[15],
                                v = c * f * l - m * u * l + m * o * d - a * f * d - c * o * g + a * u * g,
                                _ = p * u * l - h * f * l - p * o * d + s * f * d + h * o * g - s * u * g,
                                y = h * m * l - p * c * l + p * a * d - s * m * d - h * a * g + s * c * g,
                                x = p * c * o - h * m * o - p * a * u + s * m * u + h * a * f - s * c * f,
                                M = e * v + i * _ + n * y + r * x;
                            if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const b = 1 / M;
                            return t[0] = v * b, t[1] = (m * u * r - c * f * r - m * n * d + i * f * d + c * n * g - i * u * g) * b, t[2] = (a * f * r - m * o * r + m * n * l - i * f * l - a * n * g + i * o * g) * b, t[3] = (c * o * r - a * u * r - c * n * l + i * u * l + a * n * d - i * o * d) * b, t[4] = _ * b, t[5] = (h * f * r - p * u * r + p * n * d - e * f * d - h * n * g + e * u * g) * b, t[6] = (p * o * r - s * f * r - p * n * l + e * f * l + s * n * g - e * o * g) * b, t[7] = (s * u * r - h * o * r + h * n * l - e * u * l - s * n * d + e * o * d) * b, t[8] = y * b, t[9] = (p * c * r - h * m * r - p * i * d + e * m * d + h * i * g - e * c * g) * b, t[10] = (s * m * r - p * a * r + p * i * l - e * m * l - s * i * g + e * a * g) * b, t[11] = (h * a * r - s * c * r - h * i * l + e * c * l + s * i * d - e * a * d) * b, t[12] = x * b, t[13] = (h * m * n - p * c * n + p * i * u - e * m * u - h * i * f + e * c * f) * b, t[14] = (p * a * n - s * m * n - p * i * o + e * m * o + s * i * f - e * a * f) * b, t[15] = (s * c * n - h * a * n + h * i * o - e * c * o - s * i * u + e * a * u) * b, this
                        }
                        scale(t) {
                            const e = this.elements,
                                i = t.x,
                                n = t.y,
                                r = t.z;
                            return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                        }
                        getMaxScaleOnAxis() {
                            const t = this.elements,
                                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                                i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                                n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                            return Math.sqrt(Math.max(e, i, n))
                        }
                        makeTranslation(t, e, i) {
                            return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                        }
                        makeRotationX(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                        }
                        makeRotationY(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                        }
                        makeRotationZ(t) {
                            const e = Math.cos(t),
                                i = Math.sin(t);
                            return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                        makeRotationAxis(t, e) {
                            const i = Math.cos(e),
                                n = Math.sin(e),
                                r = 1 - i,
                                s = t.x,
                                a = t.y,
                                o = t.z,
                                l = r * s,
                                h = r * a;
                            return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, h * a + i, h * o - n * s, 0, l * o - n * a, h * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
                        }
                        makeScale(t, e, i) {
                            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                        }
                        makeShear(t, e, i, n, r, s) {
                            return this.set(1, i, r, 0, t, 1, s, 0, e, n, 1, 0, 0, 0, 0, 1), this
                        }
                        compose(t, e, i) {
                            const n = this.elements,
                                r = e._x,
                                s = e._y,
                                a = e._z,
                                o = e._w,
                                l = r + r,
                                h = s + s,
                                c = a + a,
                                u = r * l,
                                d = r * h,
                                p = r * c,
                                m = s * h,
                                f = s * c,
                                g = a * c,
                                v = o * l,
                                _ = o * h,
                                y = o * c,
                                x = i.x,
                                M = i.y,
                                b = i.z;
                            return n[0] = (1 - (m + g)) * x, n[1] = (d + y) * x, n[2] = (p - _) * x, n[3] = 0, n[4] = (d - y) * M, n[5] = (1 - (u + g)) * M, n[6] = (f + v) * M, n[7] = 0, n[8] = (p + _) * b, n[9] = (f - v) * b, n[10] = (1 - (u + m)) * b, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                        }
                        decompose(t, e, i) {
                            const n = this.elements;
                            let r = Gt.set(n[0], n[1], n[2]).length();
                            const s = Gt.set(n[4], n[5], n[6]).length(),
                                a = Gt.set(n[8], n[9], n[10]).length();
                            this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], Wt.copy(this);
                            const o = 1 / r,
                                l = 1 / s,
                                h = 1 / a;
                            return Wt.elements[0] *= o, Wt.elements[1] *= o, Wt.elements[2] *= o, Wt.elements[4] *= l, Wt.elements[5] *= l, Wt.elements[6] *= l, Wt.elements[8] *= h, Wt.elements[9] *= h, Wt.elements[10] *= h, e.setFromRotationMatrix(Wt), i.x = r, i.y = s, i.z = a, this
                        }
                        makePerspective(t, e, i, n, r, s, a = 2e3) {
                            const o = this.elements,
                                l = 2 * r / (e - t),
                                h = 2 * r / (i - n),
                                c = (e + t) / (e - t),
                                u = (i + n) / (i - n);
                            let d, p;
                            if (2e3 === a) d = -(s + r) / (s - r), p = -2 * s * r / (s - r);
                            else {
                                if (2001 !== a) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                                d = -s / (s - r), p = -s * r / (s - r)
                            }
                            return o[0] = l, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = h, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                        }
                        makeOrthographic(t, e, i, n, r, s, a = 2e3) {
                            const o = this.elements,
                                l = 1 / (e - t),
                                h = 1 / (i - n),
                                c = 1 / (s - r),
                                u = (e + t) * l,
                                d = (i + n) * h;
                            let p, m;
                            if (2e3 === a) p = (s + r) * c, m = -2 * c;
                            else {
                                if (2001 !== a) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                                p = r * c, m = -1 * c
                            }
                            return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * h, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = m, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                        }
                        equals(t) {
                            const e = this.elements,
                                i = t.elements;
                            for (let t = 0; t < 16; t++)
                                if (e[t] !== i[t]) return !1;
                            return !0
                        }
                        fromArray(t, e = 0) {
                            for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                            return this
                        }
                        toArray(t = [], e = 0) {
                            const i = this.elements;
                            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                        }
                    }
                    const Gt = new dt,
                        Wt = new Ht,
                        jt = new dt(0, 0, 0),
                        Xt = new dt(1, 1, 1),
                        qt = new dt,
                        Yt = new dt,
                        Jt = new dt,
                        Zt = new Ht,
                        Kt = new ut;
                    class Qt {
                        constructor(t = 0, e = 0, i = 0, n = Qt.DEFAULT_ORDER) {
                            this.isEuler = !0, this._x = t, this._y = e, this._z = i, this._order = n
                        }
                        get x() {
                            return this._x
                        }
                        set x(t) {
                            this._x = t, this._onChangeCallback()
                        }
                        get y() {
                            return this._y
                        }
                        set y(t) {
                            this._y = t, this._onChangeCallback()
                        }
                        get z() {
                            return this._z
                        }
                        set z(t) {
                            this._z = t, this._onChangeCallback()
                        }
                        get order() {
                            return this._order
                        }
                        set order(t) {
                            this._order = t, this._onChangeCallback()
                        }
                        set(t, e, i, n = this._order) {
                            return this._x = t, this._y = e, this._z = i, this._order = n, this._onChangeCallback(), this
                        }
                        clone() {
                            return new this.constructor(this._x, this._y, this._z, this._order)
                        }
                        copy(t) {
                            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                        }
                        setFromRotationMatrix(t, e = this._order, i = !0) {
                            const n = t.elements,
                                r = n[0],
                                s = n[4],
                                a = n[8],
                                o = n[1],
                                l = n[5],
                                h = n[9],
                                c = n[2],
                                u = n[6],
                                d = n[10];
                            switch (e) {
                                case "XYZ":
                                    this._y = Math.asin(V(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                                    break;
                                case "YXZ":
                                    this._x = Math.asin(-V(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, r), this._z = 0);
                                    break;
                                case "ZXY":
                                    this._x = Math.asin(V(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                                    break;
                                case "ZYX":
                                    this._y = Math.asin(-V(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                                    break;
                                case "YZX":
                                    this._z = Math.asin(V(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                                    break;
                                case "XZY":
                                    this._z = Math.asin(-V(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, d), this._y = 0);
                                    break;
                                default:
                                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                            }
                            return this._order = e, !0 === i && this._onChangeCallback(), this
                        }
                        setFromQuaternion(t, e, i) {
                            return Zt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Zt, e, i)
                        }
                        setFromVector3(t, e = this._order) {
                            return this.set(t.x, t.y, t.z, e)
                        }
                        reorder(t) {
                            return Kt.setFromEuler(this), this.setFromQuaternion(Kt, t)
                        }
                        equals(t) {
                            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                        }
                        fromArray(t) {
                            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                        }
                        _onChange(t) {
                            return this._onChangeCallback = t, this
                        }
                        _onChangeCallback() {}*[Symbol.iterator]() {
                            yield this._x, yield this._y, yield this._z, yield this._order
                        }
                    }
                    Qt.DEFAULT_ORDER = "XYZ";
                    class $t {
                        constructor() {
                            this.mask = 1
                        }
                        set(t) {
                            this.mask = 1 << t >>> 0
                        }
                        enable(t) {
                            this.mask |= 1 << t
                        }
                        enableAll() {
                            this.mask = -1
                        }
                        toggle(t) {
                            this.mask ^= 1 << t
                        }
                        disable(t) {
                            this.mask &= ~(1 << t)
                        }
                        disableAll() {
                            this.mask = 0
                        }
                        test(t) {
                            return !!(this.mask & t.mask)
                        }
                        isEnabled(t) {
                            return !!(this.mask & 1 << t)
                        }
                    }
                    let te = 0;
                    const ee = new dt,
                        ie = new ut,
                        ne = new Ht,
                        re = new dt,
                        se = new dt,
                        ae = new dt,
                        oe = new ut,
                        le = new dt(1, 0, 0),
                        he = new dt(0, 1, 0),
                        ce = new dt(0, 0, 1),
                        ue = {
                            type: "added"
                        },
                        de = {
                            type: "removed"
                        },
                        pe = {
                            type: "childadded",
                            child: null
                        },
                        me = {
                            type: "childremoved",
                            child: null
                        };
                    class fe extends z {
                        constructor() {
                            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                                value: te++
                            }), this.uuid = k(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = fe.DEFAULT_UP.clone();
                            const t = new dt,
                                e = new Qt,
                                i = new ut,
                                n = new dt(1, 1, 1);
                            e._onChange((function() {
                                i.setFromEuler(e, !1)
                            })), i._onChange((function() {
                                e.setFromQuaternion(i, void 0, !1)
                            })), Object.defineProperties(this, {
                                position: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: t
                                },
                                rotation: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: e
                                },
                                quaternion: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: i
                                },
                                scale: {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: n
                                },
                                modelViewMatrix: {
                                    value: new Ht
                                },
                                normalMatrix: {
                                    value: new X
                                }
                            }), this.matrix = new Ht, this.matrixWorld = new Ht, this.matrixAutoUpdate = fe.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = fe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new $t, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                        }
                        onBeforeShadow() {}
                        onAfterShadow() {}
                        onBeforeRender() {}
                        onAfterRender() {}
                        applyMatrix4(t) {
                            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                        }
                        applyQuaternion(t) {
                            return this.quaternion.premultiply(t), this
                        }
                        setRotationFromAxisAngle(t, e) {
                            this.quaternion.setFromAxisAngle(t, e)
                        }
                        setRotationFromEuler(t) {
                            this.quaternion.setFromEuler(t, !0)
                        }
                        setRotationFromMatrix(t) {
                            this.quaternion.setFromRotationMatrix(t)
                        }
                        setRotationFromQuaternion(t) {
                            this.quaternion.copy(t)
                        }
                        rotateOnAxis(t, e) {
                            return ie.setFromAxisAngle(t, e), this.quaternion.multiply(ie), this
                        }
                        rotateOnWorldAxis(t, e) {
                            return ie.setFromAxisAngle(t, e), this.quaternion.premultiply(ie), this
                        }
                        rotateX(t) {
                            return this.rotateOnAxis(le, t)
                        }
                        rotateY(t) {
                            return this.rotateOnAxis(he, t)
                        }
                        rotateZ(t) {
                            return this.rotateOnAxis(ce, t)
                        }
                        translateOnAxis(t, e) {
                            return ee.copy(t).applyQuaternion(this.quaternion), this.position.add(ee.multiplyScalar(e)), this
                        }
                        translateX(t) {
                            return this.translateOnAxis(le, t)
                        }
                        translateY(t) {
                            return this.translateOnAxis(he, t)
                        }
                        translateZ(t) {
                            return this.translateOnAxis(ce, t)
                        }
                        localToWorld(t) {
                            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
                        }
                        worldToLocal(t) {
                            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(ne.copy(this.matrixWorld).invert())
                        }
                        lookAt(t, e, i) {
                            t.isVector3 ? re.copy(t) : re.set(t, e, i);
                            const n = this.parent;
                            this.updateWorldMatrix(!0, !1), se.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ne.lookAt(se, re, this.up) : ne.lookAt(re, se, this.up), this.quaternion.setFromRotationMatrix(ne), n && (ne.extractRotation(n.matrixWorld), ie.setFromRotationMatrix(ne), this.quaternion.premultiply(ie.invert()))
                        }
                        add(t) {
                            if (arguments.length > 1) {
                                for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                                return this
                            }
                            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(ue), pe.child = t, this.dispatchEvent(pe), pe.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                        }
                        remove(t) {
                            if (arguments.length > 1) {
                                for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                                return this
                            }
                            const e = this.children.indexOf(t);
                            return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(de), me.child = t, this.dispatchEvent(me), me.child = null), this
                        }
                        removeFromParent() {
                            const t = this.parent;
                            return null !== t && t.remove(this), this
                        }
                        clear() {
                            return this.remove(...this.children)
                        }
                        attach(t) {
                            return this.updateWorldMatrix(!0, !1), ne.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ne.multiply(t.parent.matrixWorld)), t.applyMatrix4(ne), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(ue), pe.child = t, this.dispatchEvent(pe), pe.child = null, this
                        }
                        getObjectById(t) {
                            return this.getObjectByProperty("id", t)
                        }
                        getObjectByName(t) {
                            return this.getObjectByProperty("name", t)
                        }
                        getObjectByProperty(t, e) {
                            if (this[t] === e) return this;
                            for (let i = 0, n = this.children.length; i < n; i++) {
                                const n = this.children[i].getObjectByProperty(t, e);
                                if (void 0 !== n) return n
                            }
                        }
                        getObjectsByProperty(t, e, i = []) {
                            this[t] === e && i.push(this);
                            const n = this.children;
                            for (let r = 0, s = n.length; r < s; r++) n[r].getObjectsByProperty(t, e, i);
                            return i
                        }
                        getWorldPosition(t) {
                            return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                        }
                        getWorldQuaternion(t) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(se, t, ae), t
                        }
                        getWorldScale(t) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(se, oe, t), t
                        }
                        getWorldDirection(t) {
                            this.updateWorldMatrix(!0, !1);
                            const e = this.matrixWorld.elements;
                            return t.set(e[8], e[9], e[10]).normalize()
                        }
                        raycast() {}
                        traverse(t) {
                            t(this);
                            const e = this.children;
                            for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                        }
                        traverseVisible(t) {
                            if (!1 === this.visible) return;
                            t(this);
                            const e = this.children;
                            for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                        }
                        traverseAncestors(t) {
                            const e = this.parent;
                            null !== e && (t(e), e.traverseAncestors(t))
                        }
                        updateMatrix() {
                            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                        }
                        updateMatrixWorld(t) {
                            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
                            const e = this.children;
                            for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                        }
                        updateWorldMatrix(t, e) {
                            const i = this.parent;
                            if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === e) {
                                const t = this.children;
                                for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
                            }
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t,
                                i = {};
                            e && (t = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            }, i.metadata = {
                                version: 4.6,
                                type: "Object",
                                generator: "Object3D.toJSON"
                            });
                            const n = {};

                            function r(e, i) {
                                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                            }
                            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((t => ({
                                    boxInitialized: t.boxInitialized,
                                    boxMin: t.box.min.toArray(),
                                    boxMax: t.box.max.toArray(),
                                    sphereInitialized: t.sphereInitialized,
                                    sphereRadius: t.sphere.radius,
                                    sphereCenter: t.sphere.center.toArray()
                                }))), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(t), null !== this._colorsTexture && (n.colorsTexture = this._colorsTexture.toJSON(t)), null !== this.boundingSphere && (n.boundingSphere = {
                                    center: n.boundingSphere.center.toArray(),
                                    radius: n.boundingSphere.radius
                                }), null !== this.boundingBox && (n.boundingBox = {
                                    min: n.boundingBox.min.toArray(),
                                    max: n.boundingBox.max.toArray()
                                })), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(t).uuid);
                            else if (this.isMesh || this.isLine || this.isPoints) {
                                n.geometry = r(t.geometries, this.geometry);
                                const e = this.geometry.parameters;
                                if (void 0 !== e && void 0 !== e.shapes) {
                                    const i = e.shapes;
                                    if (Array.isArray(i))
                                        for (let e = 0, n = i.length; e < n; e++) {
                                            const n = i[e];
                                            r(t.shapes, n)
                                        } else r(t.shapes, i)
                                }
                            }
                            if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                                if (Array.isArray(this.material)) {
                                    const e = [];
                                    for (let i = 0, n = this.material.length; i < n; i++) e.push(r(t.materials, this.material[i]));
                                    n.material = e
                                } else n.material = r(t.materials, this.material);
                            if (this.children.length > 0) {
                                n.children = [];
                                for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object)
                            }
                            if (this.animations.length > 0) {
                                n.animations = [];
                                for (let e = 0; e < this.animations.length; e++) {
                                    const i = this.animations[e];
                                    n.animations.push(r(t.animations, i))
                                }
                            }
                            if (e) {
                                const e = s(t.geometries),
                                    n = s(t.materials),
                                    r = s(t.textures),
                                    a = s(t.images),
                                    o = s(t.shapes),
                                    l = s(t.skeletons),
                                    h = s(t.animations),
                                    c = s(t.nodes);
                                e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), h.length > 0 && (i.animations = h), c.length > 0 && (i.nodes = c)
                            }
                            return i.object = n, i;

                            function s(t) {
                                const e = [];
                                for (const i in t) {
                                    const n = t[i];
                                    delete n.metadata, e.push(n)
                                }
                                return e
                            }
                        }
                        clone(t) {
                            return (new this.constructor).copy(this, t)
                        }
                        copy(t, e = !0) {
                            if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                                for (let e = 0; e < t.children.length; e++) {
                                    const i = t.children[e];
                                    this.add(i.clone())
                                }
                            return this
                        }
                    }
                    fe.DEFAULT_UP = new dt(0, 1, 0), fe.DEFAULT_MATRIX_AUTO_UPDATE = !0, fe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                    const ge = new dt,
                        ve = new dt,
                        _e = new dt,
                        ye = new dt,
                        xe = new dt,
                        Me = new dt,
                        be = new dt,
                        Se = new dt,
                        we = new dt,
                        Ae = new dt;
                    class Te {
                        constructor(t = new dt, e = new dt, i = new dt) {
                            this.a = t, this.b = e, this.c = i
                        }
                        static getNormal(t, e, i, n) {
                            n.subVectors(i, e), ge.subVectors(t, e), n.cross(ge);
                            const r = n.lengthSq();
                            return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                        }
                        static getBarycoord(t, e, i, n, r) {
                            ge.subVectors(n, e), ve.subVectors(i, e), _e.subVectors(t, e);
                            const s = ge.dot(ge),
                                a = ge.dot(ve),
                                o = ge.dot(_e),
                                l = ve.dot(ve),
                                h = ve.dot(_e),
                                c = s * l - a * a;
                            if (0 === c) return r.set(0, 0, 0), null;
                            const u = 1 / c,
                                d = (l * o - a * h) * u,
                                p = (s * h - a * o) * u;
                            return r.set(1 - d - p, p, d)
                        }
                        static containsPoint(t, e, i, n) {
                            return null !== this.getBarycoord(t, e, i, n, ye) && ye.x >= 0 && ye.y >= 0 && ye.x + ye.y <= 1
                        }
                        static getInterpolation(t, e, i, n, r, s, a, o) {
                            return null === this.getBarycoord(t, e, i, n, ye) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, ye.x), o.addScaledVector(s, ye.y), o.addScaledVector(a, ye.z), o)
                        }
                        static isFrontFacing(t, e, i, n) {
                            return ge.subVectors(i, e), ve.subVectors(t, e), ge.cross(ve).dot(n) < 0
                        }
                        set(t, e, i) {
                            return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                        }
                        setFromPointsAndIndices(t, e, i, n) {
                            return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                        }
                        setFromAttributeAndIndices(t, e, i, n) {
                            return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, n), this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                        }
                        getArea() {
                            return ge.subVectors(this.c, this.b), ve.subVectors(this.a, this.b), .5 * ge.cross(ve).length()
                        }
                        getMidpoint(t) {
                            return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                        }
                        getNormal(t) {
                            return Te.getNormal(this.a, this.b, this.c, t)
                        }
                        getPlane(t) {
                            return t.setFromCoplanarPoints(this.a, this.b, this.c)
                        }
                        getBarycoord(t, e) {
                            return Te.getBarycoord(t, this.a, this.b, this.c, e)
                        }
                        getInterpolation(t, e, i, n, r) {
                            return Te.getInterpolation(t, this.a, this.b, this.c, e, i, n, r)
                        }
                        containsPoint(t) {
                            return Te.containsPoint(t, this.a, this.b, this.c)
                        }
                        isFrontFacing(t) {
                            return Te.isFrontFacing(this.a, this.b, this.c, t)
                        }
                        intersectsBox(t) {
                            return t.intersectsTriangle(this)
                        }
                        closestPointToPoint(t, e) {
                            const i = this.a,
                                n = this.b,
                                r = this.c;
                            let s, a;
                            xe.subVectors(n, i), Me.subVectors(r, i), Se.subVectors(t, i);
                            const o = xe.dot(Se),
                                l = Me.dot(Se);
                            if (o <= 0 && l <= 0) return e.copy(i);
                            we.subVectors(t, n);
                            const h = xe.dot(we),
                                c = Me.dot(we);
                            if (h >= 0 && c <= h) return e.copy(n);
                            const u = o * c - h * l;
                            if (u <= 0 && o >= 0 && h <= 0) return s = o / (o - h), e.copy(i).addScaledVector(xe, s);
                            Ae.subVectors(t, r);
                            const d = xe.dot(Ae),
                                p = Me.dot(Ae);
                            if (p >= 0 && d <= p) return e.copy(r);
                            const m = d * l - o * p;
                            if (m <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(i).addScaledVector(Me, a);
                            const f = h * p - d * c;
                            if (f <= 0 && c - h >= 0 && d - p >= 0) return be.subVectors(r, n), a = (c - h) / (c - h + (d - p)), e.copy(n).addScaledVector(be, a);
                            const g = 1 / (f + m + u);
                            return s = m * g, a = u * g, e.copy(i).addScaledVector(xe, s).addScaledVector(Me, a)
                        }
                        equals(t) {
                            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                        }
                    }
                    const Ee = {
                            aliceblue: 15792383,
                            antiquewhite: 16444375,
                            aqua: 65535,
                            aquamarine: 8388564,
                            azure: 15794175,
                            beige: 16119260,
                            bisque: 16770244,
                            black: 0,
                            blanchedalmond: 16772045,
                            blue: 255,
                            blueviolet: 9055202,
                            brown: 10824234,
                            burlywood: 14596231,
                            cadetblue: 6266528,
                            chartreuse: 8388352,
                            chocolate: 13789470,
                            coral: 16744272,
                            cornflowerblue: 6591981,
                            cornsilk: 16775388,
                            crimson: 14423100,
                            cyan: 65535,
                            darkblue: 139,
                            darkcyan: 35723,
                            darkgoldenrod: 12092939,
                            darkgray: 11119017,
                            darkgreen: 25600,
                            darkgrey: 11119017,
                            darkkhaki: 12433259,
                            darkmagenta: 9109643,
                            darkolivegreen: 5597999,
                            darkorange: 16747520,
                            darkorchid: 10040012,
                            darkred: 9109504,
                            darksalmon: 15308410,
                            darkseagreen: 9419919,
                            darkslateblue: 4734347,
                            darkslategray: 3100495,
                            darkslategrey: 3100495,
                            darkturquoise: 52945,
                            darkviolet: 9699539,
                            deeppink: 16716947,
                            deepskyblue: 49151,
                            dimgray: 6908265,
                            dimgrey: 6908265,
                            dodgerblue: 2003199,
                            firebrick: 11674146,
                            floralwhite: 16775920,
                            forestgreen: 2263842,
                            fuchsia: 16711935,
                            gainsboro: 14474460,
                            ghostwhite: 16316671,
                            gold: 16766720,
                            goldenrod: 14329120,
                            gray: 8421504,
                            green: 32768,
                            greenyellow: 11403055,
                            grey: 8421504,
                            honeydew: 15794160,
                            hotpink: 16738740,
                            indianred: 13458524,
                            indigo: 4915330,
                            ivory: 16777200,
                            khaki: 15787660,
                            lavender: 15132410,
                            lavenderblush: 16773365,
                            lawngreen: 8190976,
                            lemonchiffon: 16775885,
                            lightblue: 11393254,
                            lightcoral: 15761536,
                            lightcyan: 14745599,
                            lightgoldenrodyellow: 16448210,
                            lightgray: 13882323,
                            lightgreen: 9498256,
                            lightgrey: 13882323,
                            lightpink: 16758465,
                            lightsalmon: 16752762,
                            lightseagreen: 2142890,
                            lightskyblue: 8900346,
                            lightslategray: 7833753,
                            lightslategrey: 7833753,
                            lightsteelblue: 11584734,
                            lightyellow: 16777184,
                            lime: 65280,
                            limegreen: 3329330,
                            linen: 16445670,
                            magenta: 16711935,
                            maroon: 8388608,
                            mediumaquamarine: 6737322,
                            mediumblue: 205,
                            mediumorchid: 12211667,
                            mediumpurple: 9662683,
                            mediumseagreen: 3978097,
                            mediumslateblue: 8087790,
                            mediumspringgreen: 64154,
                            mediumturquoise: 4772300,
                            mediumvioletred: 13047173,
                            midnightblue: 1644912,
                            mintcream: 16121850,
                            mistyrose: 16770273,
                            moccasin: 16770229,
                            navajowhite: 16768685,
                            navy: 128,
                            oldlace: 16643558,
                            olive: 8421376,
                            olivedrab: 7048739,
                            orange: 16753920,
                            orangered: 16729344,
                            orchid: 14315734,
                            palegoldenrod: 15657130,
                            palegreen: 10025880,
                            paleturquoise: 11529966,
                            palevioletred: 14381203,
                            papayawhip: 16773077,
                            peachpuff: 16767673,
                            peru: 13468991,
                            pink: 16761035,
                            plum: 14524637,
                            powderblue: 11591910,
                            purple: 8388736,
                            rebeccapurple: 6697881,
                            red: 16711680,
                            rosybrown: 12357519,
                            royalblue: 4286945,
                            saddlebrown: 9127187,
                            salmon: 16416882,
                            sandybrown: 16032864,
                            seagreen: 3050327,
                            seashell: 16774638,
                            sienna: 10506797,
                            silver: 12632256,
                            skyblue: 8900331,
                            slateblue: 6970061,
                            slategray: 7372944,
                            slategrey: 7372944,
                            snow: 16775930,
                            springgreen: 65407,
                            steelblue: 4620980,
                            tan: 13808780,
                            teal: 32896,
                            thistle: 14204888,
                            tomato: 16737095,
                            turquoise: 4251856,
                            violet: 15631086,
                            wheat: 16113331,
                            white: 16777215,
                            whitesmoke: 16119285,
                            yellow: 16776960,
                            yellowgreen: 10145074
                        },
                        Ce = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        Re = {
                            h: 0,
                            s: 0,
                            l: 0
                        };

                    function Pe(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                    }
                    class Ie {
                        constructor(t, e, i) {
                            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, i)
                        }
                        set(t, e, i) {
                            if (void 0 === e && void 0 === i) {
                                const e = t;
                                e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                            } else this.setRGB(t, e, i);
                            return this
                        }
                        setScalar(t) {
                            return this.r = t, this.g = t, this.b = t, this
                        }
                        setHex(t, e = P) {
                            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, tt.toWorkingColorSpace(this, e), this
                        }
                        setRGB(t, e, i, n = tt.workingColorSpace) {
                            return this.r = t, this.g = e, this.b = i, tt.toWorkingColorSpace(this, n), this
                        }
                        setHSL(t, e, i, n = tt.workingColorSpace) {
                            if (t = (t % (r = 1) + r) % r, e = V(e, 0, 1), i = V(i, 0, 1), 0 === e) this.r = this.g = this.b = i;
                            else {
                                const n = i <= .5 ? i * (1 + e) : i + e - i * e,
                                    r = 2 * i - n;
                                this.r = Pe(r, n, t + 1 / 3), this.g = Pe(r, n, t), this.b = Pe(r, n, t - 1 / 3)
                            }
                            var r;
                            return tt.toWorkingColorSpace(this, n), this
                        }
                        setStyle(t, e = P) {
                            function i(e) {
                                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                            }
                            let n;
                            if (n = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                                let r;
                                const s = n[1],
                                    a = n[2];
                                switch (s) {
                                    case "rgb":
                                    case "rgba":
                                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                                        break;
                                    case "hsl":
                                    case "hsla":
                                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                                        break;
                                    default:
                                        console.warn("THREE.Color: Unknown color model " + t)
                                }
                            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                                const i = n[1],
                                    r = i.length;
                                if (3 === r) return this.setRGB(parseInt(i.charAt(0), 16) / 15, parseInt(i.charAt(1), 16) / 15, parseInt(i.charAt(2), 16) / 15, e);
                                if (6 === r) return this.setHex(parseInt(i, 16), e);
                                console.warn("THREE.Color: Invalid hex color " + t)
                            } else if (t && t.length > 0) return this.setColorName(t, e);
                            return this
                        }
                        setColorName(t, e = P) {
                            const i = Ee[t.toLowerCase()];
                            return void 0 !== i ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this
                        }
                        clone() {
                            return new this.constructor(this.r, this.g, this.b)
                        }
                        copy(t) {
                            return this.r = t.r, this.g = t.g, this.b = t.b, this
                        }
                        copySRGBToLinear(t) {
                            return this.r = et(t.r), this.g = et(t.g), this.b = et(t.b), this
                        }
                        copyLinearToSRGB(t) {
                            return this.r = it(t.r), this.g = it(t.g), this.b = it(t.b), this
                        }
                        convertSRGBToLinear() {
                            return this.copySRGBToLinear(this), this
                        }
                        convertLinearToSRGB() {
                            return this.copyLinearToSRGB(this), this
                        }
                        getHex(t = P) {
                            return tt.fromWorkingColorSpace(Le.copy(this), t), 65536 * Math.round(V(255 * Le.r, 0, 255)) + 256 * Math.round(V(255 * Le.g, 0, 255)) + Math.round(V(255 * Le.b, 0, 255))
                        }
                        getHexString(t = P) {
                            return ("000000" + this.getHex(t).toString(16)).slice(-6)
                        }
                        getHSL(t, e = tt.workingColorSpace) {
                            tt.fromWorkingColorSpace(Le.copy(this), e);
                            const i = Le.r,
                                n = Le.g,
                                r = Le.b,
                                s = Math.max(i, n, r),
                                a = Math.min(i, n, r);
                            let o, l;
                            const h = (a + s) / 2;
                            if (a === s) o = 0, l = 0;
                            else {
                                const t = s - a;
                                switch (l = h <= .5 ? t / (s + a) : t / (2 - s - a), s) {
                                    case i:
                                        o = (n - r) / t + (n < r ? 6 : 0);
                                        break;
                                    case n:
                                        o = (r - i) / t + 2;
                                        break;
                                    case r:
                                        o = (i - n) / t + 4
                                }
                                o /= 6
                            }
                            return t.h = o, t.s = l, t.l = h, t
                        }
                        getRGB(t, e = tt.workingColorSpace) {
                            return tt.fromWorkingColorSpace(Le.copy(this), e), t.r = Le.r, t.g = Le.g, t.b = Le.b, t
                        }
                        getStyle(t = P) {
                            tt.fromWorkingColorSpace(Le.copy(this), t);
                            const e = Le.r,
                                i = Le.g,
                                n = Le.b;
                            return t !== P ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*i)},${Math.round(255*n)})`
                        }
                        offsetHSL(t, e, i) {
                            return this.getHSL(Ce), this.setHSL(Ce.h + t, Ce.s + e, Ce.l + i)
                        }
                        add(t) {
                            return this.r += t.r, this.g += t.g, this.b += t.b, this
                        }
                        addColors(t, e) {
                            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                        }
                        addScalar(t) {
                            return this.r += t, this.g += t, this.b += t, this
                        }
                        sub(t) {
                            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                        }
                        multiply(t) {
                            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                        }
                        multiplyScalar(t) {
                            return this.r *= t, this.g *= t, this.b *= t, this
                        }
                        lerp(t, e) {
                            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                        }
                        lerpColors(t, e, i) {
                            return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this
                        }
                        lerpHSL(t, e) {
                            this.getHSL(Ce), t.getHSL(Re);
                            const i = H(Ce.h, Re.h, e),
                                n = H(Ce.s, Re.s, e),
                                r = H(Ce.l, Re.l, e);
                            return this.setHSL(i, n, r), this
                        }
                        setFromVector3(t) {
                            return this.r = t.x, this.g = t.y, this.b = t.z, this
                        }
                        applyMatrix3(t) {
                            const e = this.r,
                                i = this.g,
                                n = this.b,
                                r = t.elements;
                            return this.r = r[0] * e + r[3] * i + r[6] * n, this.g = r[1] * e + r[4] * i + r[7] * n, this.b = r[2] * e + r[5] * i + r[8] * n, this
                        }
                        equals(t) {
                            return t.r === this.r && t.g === this.g && t.b === this.b
                        }
                        fromArray(t, e = 0) {
                            return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                        }
                        toArray(t = [], e = 0) {
                            return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                        }
                        fromBufferAttribute(t, e) {
                            return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
                        }
                        toJSON() {
                            return this.getHex()
                        }*[Symbol.iterator]() {
                            yield this.r, yield this.g, yield this.b
                        }
                    }
                    const Le = new Ie;
                    Ie.NAMES = Ee;
                    let Ue = 0;
                    class Ne extends z {
                        constructor() {
                            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                                value: Ue++
                            }), this.uuid = k(), this.name = "", this.type = "Material", this.blending = 1, this.side = n, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = o, this.blendDst = l, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ie(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = B, this.stencilZFail = B, this.stencilZPass = B, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                        }
                        get alphaTest() {
                            return this._alphaTest
                        }
                        set alphaTest(t) {
                            this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                        }
                        onBeforeRender() {}
                        onBeforeCompile() {}
                        customProgramCacheKey() {
                            return this.onBeforeCompile.toString()
                        }
                        setValues(t) {
                            if (void 0 !== t)
                                for (const e in t) {
                                    const i = t[e];
                                    if (void 0 === i) {
                                        console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                                        continue
                                    }
                                    const n = this[e];
                                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                                }
                        }
                        toJSON(t) {
                            const e = void 0 === t || "string" == typeof t;
                            e && (t = {
                                textures: {},
                                images: {}
                            });
                            const i = {
                                metadata: {
                                    version: 4.6,
                                    type: "Material",
                                    generator: "Material.toJSON"
                                }
                            };

                            function r(t) {
                                const e = [];
                                for (const i in t) {
                                    const n = t[i];
                                    delete n.metadata, e.push(n)
                                }
                                return e
                            }
                            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (i.dispersion = this.dispersion), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), this.side !== n && (i.side = this.side), !0 === this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = !0), this.blendSrc !== o && (i.blendSrc = this.blendSrc), this.blendDst !== l && (i.blendDst = this.blendDst), 100 !== this.blendEquation && (i.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (i.depthFunc = this.depthFunc), !1 === this.depthTest && (i.depthTest = this.depthTest), !1 === this.depthWrite && (i.depthWrite = this.depthWrite), !1 === this.colorWrite && (i.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (i.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== B && (i.stencilFail = this.stencilFail), this.stencilZFail !== B && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== B && (i.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaHash && (i.alphaHash = !0), !0 === this.alphaToCoverage && (i.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0), !0 === this.forceSinglePass && (i.forceSinglePass = !0), !0 === this.wireframe && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), e) {
                                const e = r(t.textures),
                                    n = r(t.images);
                                e.length > 0 && (i.textures = e), n.length > 0 && (i.images = n)
                            }
                            return i
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                            const e = t.clippingPlanes;
                            let i = null;
                            if (null !== e) {
                                const t = e.length;
                                i = new Array(t);
                                for (let n = 0; n !== t; ++n) i[n] = e[n].clone()
                            }
                            return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        onBuild() {
                            console.warn("Material: onBuild() has been removed.")
                        }
                    }
                    class De extends Ne {
                        constructor(t) {
                            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ie(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qt, this.combine = c, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
                        }
                    }
                    const Oe = new dt,
                        Be = new j;
                    class ze {
                        constructor(t, e, i = !1) {
                            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                            this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = i, this.usage = 35044, this._updateRange = {
                                offset: 0,
                                count: -1
                            }, this.updateRanges = [], this.gpuType = 1015, this.version = 0
                        }
                        onUploadCallback() {}
                        set needsUpdate(t) {
                            !0 === t && this.version++
                        }
                        get updateRange() {
                            return (t = "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.") in J || (J[t] = !0, console.warn(t)), this._updateRange;
                            var t
                        }
                        setUsage(t) {
                            return this.usage = t, this
                        }
                        addUpdateRange(t, e) {
                            this.updateRanges.push({
                                start: t,
                                count: e
                            })
                        }
                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }
                        copy(t) {
                            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
                        }
                        copyAt(t, e, i) {
                            t *= this.itemSize, i *= e.itemSize;
                            for (let n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                            return this
                        }
                        copyArray(t) {
                            return this.array.set(t), this
                        }
                        applyMatrix3(t) {
                            if (2 === this.itemSize)
                                for (let e = 0, i = this.count; e < i; e++) Be.fromBufferAttribute(this, e), Be.applyMatrix3(t), this.setXY(e, Be.x, Be.y);
                            else if (3 === this.itemSize)
                                for (let e = 0, i = this.count; e < i; e++) Oe.fromBufferAttribute(this, e), Oe.applyMatrix3(t), this.setXYZ(e, Oe.x, Oe.y, Oe.z);
                            return this
                        }
                        applyMatrix4(t) {
                            for (let e = 0, i = this.count; e < i; e++) Oe.fromBufferAttribute(this, e), Oe.applyMatrix4(t), this.setXYZ(e, Oe.x, Oe.y, Oe.z);
                            return this
                        }
                        applyNormalMatrix(t) {
                            for (let e = 0, i = this.count; e < i; e++) Oe.fromBufferAttribute(this, e), Oe.applyNormalMatrix(t), this.setXYZ(e, Oe.x, Oe.y, Oe.z);
                            return this
                        }
                        transformDirection(t) {
                            for (let e = 0, i = this.count; e < i; e++) Oe.fromBufferAttribute(this, e), Oe.transformDirection(t), this.setXYZ(e, Oe.x, Oe.y, Oe.z);
                            return this
                        }
                        set(t, e = 0) {
                            return this.array.set(t, e), this
                        }
                        getComponent(t, e) {
                            let i = this.array[t * this.itemSize + e];
                            return this.normalized && (i = G(i, this.array)), i
                        }
                        setComponent(t, e, i) {
                            return this.normalized && (i = W(i, this.array)), this.array[t * this.itemSize + e] = i, this
                        }
                        getX(t) {
                            let e = this.array[t * this.itemSize];
                            return this.normalized && (e = G(e, this.array)), e
                        }
                        setX(t, e) {
                            return this.normalized && (e = W(e, this.array)), this.array[t * this.itemSize] = e, this
                        }
                        getY(t) {
                            let e = this.array[t * this.itemSize + 1];
                            return this.normalized && (e = G(e, this.array)), e
                        }
                        setY(t, e) {
                            return this.normalized && (e = W(e, this.array)), this.array[t * this.itemSize + 1] = e, this
                        }
                        getZ(t) {
                            let e = this.array[t * this.itemSize + 2];
                            return this.normalized && (e = G(e, this.array)), e
                        }
                        setZ(t, e) {
                            return this.normalized && (e = W(e, this.array)), this.array[t * this.itemSize + 2] = e, this
                        }
                        getW(t) {
                            let e = this.array[t * this.itemSize + 3];
                            return this.normalized && (e = G(e, this.array)), e
                        }
                        setW(t, e) {
                            return this.normalized && (e = W(e, this.array)), this.array[t * this.itemSize + 3] = e, this
                        }
                        setXY(t, e, i) {
                            return t *= this.itemSize, this.normalized && (e = W(e, this.array), i = W(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this
                        }
                        setXYZ(t, e, i, n) {
                            return t *= this.itemSize, this.normalized && (e = W(e, this.array), i = W(i, this.array), n = W(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                        }
                        setXYZW(t, e, i, n, r) {
                            return t *= this.itemSize, this.normalized && (e = W(e, this.array), i = W(i, this.array), n = W(n, this.array), r = W(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                        }
                        onUpload(t) {
                            return this.onUploadCallback = t, this
                        }
                        clone() {
                            return new this.constructor(this.array, this.itemSize).copy(this)
                        }
                        toJSON() {
                            const t = {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: Array.from(this.array),
                                normalized: this.normalized
                            };
                            return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), t
                        }
                    }
                    class Fe extends ze {
                        constructor(t, e, i) {
                            super(new Uint16Array(t), e, i)
                        }
                    }
                    class ke extends ze {
                        constructor(t, e, i) {
                            super(new Uint32Array(t), e, i)
                        }
                    }
                    class Ve extends ze {
                        constructor(t, e, i) {
                            super(new Float32Array(t), e, i)
                        }
                    }
                    let He = 0;
                    const Ge = new Ht,
                        We = new fe,
                        je = new dt,
                        Xe = new ft,
                        qe = new ft,
                        Ye = new dt;
                    class Je extends z {
                        constructor() {
                            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                                value: He++
                            }), this.uuid = k(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                                start: 0,
                                count: 1 / 0
                            }, this.userData = {}
                        }
                        getIndex() {
                            return this.index
                        }
                        setIndex(t) {
                            return Array.isArray(t) ? this.index = new(function(t) {
                                for (let e = t.length - 1; e >= 0; --e)
                                    if (t[e] >= 65535) return !0;
                                return !1
                            }(t) ? ke : Fe)(t, 1) : this.index = t, this
                        }
                        getAttribute(t) {
                            return this.attributes[t]
                        }
                        setAttribute(t, e) {
                            return this.attributes[t] = e, this
                        }
                        deleteAttribute(t) {
                            return delete this.attributes[t], this
                        }
                        hasAttribute(t) {
                            return void 0 !== this.attributes[t]
                        }
                        addGroup(t, e, i = 0) {
                            this.groups.push({
                                start: t,
                                count: e,
                                materialIndex: i
                            })
                        }
                        clearGroups() {
                            this.groups = []
                        }
                        setDrawRange(t, e) {
                            this.drawRange.start = t, this.drawRange.count = e
                        }
                        applyMatrix4(t) {
                            const e = this.attributes.position;
                            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                            const i = this.attributes.normal;
                            if (void 0 !== i) {
                                const e = (new X).getNormalMatrix(t);
                                i.applyNormalMatrix(e), i.needsUpdate = !0
                            }
                            const n = this.attributes.tangent;
                            return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                        }
                        applyQuaternion(t) {
                            return Ge.makeRotationFromQuaternion(t), this.applyMatrix4(Ge), this
                        }
                        rotateX(t) {
                            return Ge.makeRotationX(t), this.applyMatrix4(Ge), this
                        }
                        rotateY(t) {
                            return Ge.makeRotationY(t), this.applyMatrix4(Ge), this
                        }
                        rotateZ(t) {
                            return Ge.makeRotationZ(t), this.applyMatrix4(Ge), this
                        }
                        translate(t, e, i) {
                            return Ge.makeTranslation(t, e, i), this.applyMatrix4(Ge), this
                        }
                        scale(t, e, i) {
                            return Ge.makeScale(t, e, i), this.applyMatrix4(Ge), this
                        }
                        lookAt(t) {
                            return We.lookAt(t), We.updateMatrix(), this.applyMatrix4(We.matrix), this
                        }
                        center() {
                            return this.computeBoundingBox(), this.boundingBox.getCenter(je).negate(), this.translate(je.x, je.y, je.z), this
                        }
                        setFromPoints(t) {
                            const e = [];
                            for (let i = 0, n = t.length; i < n; i++) {
                                const n = t[i];
                                e.push(n.x, n.y, n.z || 0)
                            }
                            return this.setAttribute("position", new Ve(e, 3)), this
                        }
                        computeBoundingBox() {
                            null === this.boundingBox && (this.boundingBox = new ft);
                            const t = this.attributes.position,
                                e = this.morphAttributes.position;
                            if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new dt(-1 / 0, -1 / 0, -1 / 0), new dt(1 / 0, 1 / 0, 1 / 0));
                            if (void 0 !== t) {
                                if (this.boundingBox.setFromBufferAttribute(t), e)
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t];
                                        Xe.setFromBufferAttribute(i), this.morphTargetsRelative ? (Ye.addVectors(this.boundingBox.min, Xe.min), this.boundingBox.expandByPoint(Ye), Ye.addVectors(this.boundingBox.max, Xe.max), this.boundingBox.expandByPoint(Ye)) : (this.boundingBox.expandByPoint(Xe.min), this.boundingBox.expandByPoint(Xe.max))
                                    }
                            } else this.boundingBox.makeEmpty();
                            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }
                        computeBoundingSphere() {
                            null === this.boundingSphere && (this.boundingSphere = new Ut);
                            const t = this.attributes.position,
                                e = this.morphAttributes.position;
                            if (t && t.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new dt, 1 / 0);
                            if (t) {
                                const i = this.boundingSphere.center;
                                if (Xe.setFromBufferAttribute(t), e)
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = e[t];
                                        qe.setFromBufferAttribute(i), this.morphTargetsRelative ? (Ye.addVectors(Xe.min, qe.min), Xe.expandByPoint(Ye), Ye.addVectors(Xe.max, qe.max), Xe.expandByPoint(Ye)) : (Xe.expandByPoint(qe.min), Xe.expandByPoint(qe.max))
                                    }
                                Xe.getCenter(i);
                                let n = 0;
                                for (let e = 0, r = t.count; e < r; e++) Ye.fromBufferAttribute(t, e), n = Math.max(n, i.distanceToSquared(Ye));
                                if (e)
                                    for (let r = 0, s = e.length; r < s; r++) {
                                        const s = e[r],
                                            a = this.morphTargetsRelative;
                                        for (let e = 0, r = s.count; e < r; e++) Ye.fromBufferAttribute(s, e), a && (je.fromBufferAttribute(t, e), Ye.add(je)), n = Math.max(n, i.distanceToSquared(Ye))
                                    }
                                this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                        computeTangents() {
                            const t = this.index,
                                e = this.attributes;
                            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            const i = e.position,
                                n = e.normal,
                                r = e.uv;
                            !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new ze(new Float32Array(4 * i.count), 4));
                            const s = this.getAttribute("tangent"),
                                a = [],
                                o = [];
                            for (let t = 0; t < i.count; t++) a[t] = new dt, o[t] = new dt;
                            const l = new dt,
                                h = new dt,
                                c = new dt,
                                u = new j,
                                d = new j,
                                p = new j,
                                m = new dt,
                                f = new dt;

                            function g(t, e, n) {
                                l.fromBufferAttribute(i, t), h.fromBufferAttribute(i, e), c.fromBufferAttribute(i, n), u.fromBufferAttribute(r, t), d.fromBufferAttribute(r, e), p.fromBufferAttribute(r, n), h.sub(l), c.sub(l), d.sub(u), p.sub(u);
                                const s = 1 / (d.x * p.y - p.x * d.y);
                                isFinite(s) && (m.copy(h).multiplyScalar(p.y).addScaledVector(c, -d.y).multiplyScalar(s), f.copy(c).multiplyScalar(d.x).addScaledVector(h, -p.x).multiplyScalar(s), a[t].add(m), a[e].add(m), a[n].add(m), o[t].add(f), o[e].add(f), o[n].add(f))
                            }
                            let v = this.groups;
                            0 === v.length && (v = [{
                                start: 0,
                                count: t.count
                            }]);
                            for (let e = 0, i = v.length; e < i; ++e) {
                                const i = v[e],
                                    n = i.start;
                                for (let e = n, r = n + i.count; e < r; e += 3) g(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
                            }
                            const _ = new dt,
                                y = new dt,
                                x = new dt,
                                M = new dt;

                            function b(t) {
                                x.fromBufferAttribute(n, t), M.copy(x);
                                const e = a[t];
                                _.copy(e), _.sub(x.multiplyScalar(x.dot(e))).normalize(), y.crossVectors(M, e);
                                const i = y.dot(o[t]) < 0 ? -1 : 1;
                                s.setXYZW(t, _.x, _.y, _.z, i)
                            }
                            for (let e = 0, i = v.length; e < i; ++e) {
                                const i = v[e],
                                    n = i.start;
                                for (let e = n, r = n + i.count; e < r; e += 3) b(t.getX(e + 0)), b(t.getX(e + 1)), b(t.getX(e + 2))
                            }
                        }
                        computeVertexNormals() {
                            const t = this.index,
                                e = this.getAttribute("position");
                            if (void 0 !== e) {
                                let i = this.getAttribute("normal");
                                if (void 0 === i) i = new ze(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                                else
                                    for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
                                const n = new dt,
                                    r = new dt,
                                    s = new dt,
                                    a = new dt,
                                    o = new dt,
                                    l = new dt,
                                    h = new dt,
                                    c = new dt;
                                if (t)
                                    for (let u = 0, d = t.count; u < d; u += 3) {
                                        const d = t.getX(u + 0),
                                            p = t.getX(u + 1),
                                            m = t.getX(u + 2);
                                        n.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, p), l.fromBufferAttribute(i, m), a.add(h), o.add(h), l.add(h), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(m, l.x, l.y, l.z)
                                    } else
                                        for (let t = 0, a = e.count; t < a; t += 3) n.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), i.setXYZ(t + 0, h.x, h.y, h.z), i.setXYZ(t + 1, h.x, h.y, h.z), i.setXYZ(t + 2, h.x, h.y, h.z);
                                this.normalizeNormals(), i.needsUpdate = !0
                            }
                        }
                        normalizeNormals() {
                            const t = this.attributes.normal;
                            for (let e = 0, i = t.count; e < i; e++) Ye.fromBufferAttribute(t, e), Ye.normalize(), t.setXYZ(e, Ye.x, Ye.y, Ye.z)
                        }
                        toNonIndexed() {
                            function t(t, e) {
                                const i = t.array,
                                    n = t.itemSize,
                                    r = t.normalized,
                                    s = new i.constructor(e.length * n);
                                let a = 0,
                                    o = 0;
                                for (let r = 0, l = e.length; r < l; r++) {
                                    a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * n;
                                    for (let t = 0; t < n; t++) s[o++] = i[a++]
                                }
                                return new ze(s, n, r)
                            }
                            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                            const e = new Je,
                                i = this.index.array,
                                n = this.attributes;
                            for (const r in n) {
                                const s = t(n[r], i);
                                e.setAttribute(r, s)
                            }
                            const r = this.morphAttributes;
                            for (const n in r) {
                                const s = [],
                                    a = r[n];
                                for (let e = 0, n = a.length; e < n; e++) {
                                    const n = t(a[e], i);
                                    s.push(n)
                                }
                                e.morphAttributes[n] = s
                            }
                            e.morphTargetsRelative = this.morphTargetsRelative;
                            const s = this.groups;
                            for (let t = 0, i = s.length; t < i; t++) {
                                const i = s[t];
                                e.addGroup(i.start, i.count, i.materialIndex)
                            }
                            return e
                        }
                        toJSON() {
                            const t = {
                                metadata: {
                                    version: 4.6,
                                    type: "BufferGeometry",
                                    generator: "BufferGeometry.toJSON"
                                }
                            };
                            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                                const e = this.parameters;
                                for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
                                return t
                            }
                            t.data = {
                                attributes: {}
                            };
                            const e = this.index;
                            null !== e && (t.data.index = {
                                type: e.array.constructor.name,
                                array: Array.prototype.slice.call(e.array)
                            });
                            const i = this.attributes;
                            for (const e in i) {
                                const n = i[e];
                                t.data.attributes[e] = n.toJSON(t.data)
                            }
                            const n = {};
                            let r = !1;
                            for (const e in this.morphAttributes) {
                                const i = this.morphAttributes[e],
                                    s = [];
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    s.push(n.toJSON(t.data))
                                }
                                s.length > 0 && (n[e] = s, r = !0)
                            }
                            r && (t.data.morphAttributes = n, t.data.morphTargetsRelative = this.morphTargetsRelative);
                            const s = this.groups;
                            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                            const a = this.boundingSphere;
                            return null !== a && (t.data.boundingSphere = {
                                center: a.center.toArray(),
                                radius: a.radius
                            }), t
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                            const e = {};
                            this.name = t.name;
                            const i = t.index;
                            null !== i && this.setIndex(i.clone(e));
                            const n = t.attributes;
                            for (const t in n) {
                                const i = n[t];
                                this.setAttribute(t, i.clone(e))
                            }
                            const r = t.morphAttributes;
                            for (const t in r) {
                                const i = [],
                                    n = r[t];
                                for (let t = 0, r = n.length; t < r; t++) i.push(n[t].clone(e));
                                this.morphAttributes[t] = i
                            }
                            this.morphTargetsRelative = t.morphTargetsRelative;
                            const s = t.groups;
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t];
                                this.addGroup(e.start, e.count, e.materialIndex)
                            }
                            const a = t.boundingBox;
                            null !== a && (this.boundingBox = a.clone());
                            const o = t.boundingSphere;
                            return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }
                    const Ze = new Ht,
                        Ke = new Vt,
                        Qe = new Ut,
                        $e = new dt,
                        ti = new dt,
                        ei = new dt,
                        ii = new dt,
                        ni = new dt,
                        ri = new dt,
                        si = new j,
                        ai = new j,
                        oi = new j,
                        li = new dt,
                        hi = new dt,
                        ci = new dt,
                        ui = new dt,
                        di = new dt;
                    class pi extends fe {
                        constructor(t = new Je, e = new De) {
                            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                        }
                        copy(t, e) {
                            return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                        }
                        updateMorphTargets() {
                            const t = this.geometry.morphAttributes,
                                e = Object.keys(t);
                            if (e.length > 0) {
                                const i = t[e[0]];
                                if (void 0 !== i) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t].name || String(t);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                    }
                                }
                            }
                        }
                        getVertexPosition(t, e) {
                            const i = this.geometry,
                                n = i.attributes.position,
                                r = i.morphAttributes.position,
                                s = i.morphTargetsRelative;
                            e.fromBufferAttribute(n, t);
                            const a = this.morphTargetInfluences;
                            if (r && a) {
                                ri.set(0, 0, 0);
                                for (let i = 0, n = r.length; i < n; i++) {
                                    const n = a[i],
                                        o = r[i];
                                    0 !== n && (ni.fromBufferAttribute(o, t), s ? ri.addScaledVector(ni, n) : ri.addScaledVector(ni.sub(e), n))
                                }
                                e.add(ri)
                            }
                            return e
                        }
                        raycast(t, e) {
                            const i = this.geometry,
                                n = this.material,
                                r = this.matrixWorld;
                            if (void 0 !== n) {
                                if (null === i.boundingSphere && i.computeBoundingSphere(), Qe.copy(i.boundingSphere), Qe.applyMatrix4(r), Ke.copy(t.ray).recast(t.near), !1 === Qe.containsPoint(Ke.origin)) {
                                    if (null === Ke.intersectSphere(Qe, $e)) return;
                                    if (Ke.origin.distanceToSquared($e) > (t.far - t.near) ** 2) return
                                }
                                Ze.copy(r).invert(), Ke.copy(t.ray).applyMatrix4(Ze), null !== i.boundingBox && !1 === Ke.intersectsBox(i.boundingBox) || this._computeIntersections(t, e, Ke)
                            }
                        }
                        _computeIntersections(t, e, i) {
                            let n;
                            const r = this.geometry,
                                s = this.material,
                                a = r.index,
                                o = r.attributes.position,
                                l = r.attributes.uv,
                                h = r.attributes.uv1,
                                c = r.attributes.normal,
                                u = r.groups,
                                d = r.drawRange;
                            if (null !== a)
                                if (Array.isArray(s))
                                    for (let r = 0, o = u.length; r < o; r++) {
                                        const o = u[r],
                                            p = s[o.materialIndex];
                                        for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) n = mi(this, p, t, i, l, h, c, a.getX(r), a.getX(r + 1), a.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = o.materialIndex, e.push(n))
                                    } else
                                        for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) n = mi(this, s, t, i, l, h, c, a.getX(r), a.getX(r + 1), a.getX(r + 2)), n && (n.faceIndex = Math.floor(r / 3), e.push(n));
                                else if (void 0 !== o)
                                if (Array.isArray(s))
                                    for (let r = 0, a = u.length; r < a; r++) {
                                        const a = u[r],
                                            p = s[a.materialIndex];
                                        for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) n = mi(this, p, t, i, l, h, c, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), n.face.materialIndex = a.materialIndex, e.push(n))
                                    } else
                                        for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) n = mi(this, s, t, i, l, h, c, r, r + 1, r + 2), n && (n.faceIndex = Math.floor(r / 3), e.push(n))
                        }
                    }

                    function mi(t, e, i, s, a, o, l, h, c, u) {
                        t.getVertexPosition(h, ti), t.getVertexPosition(c, ei), t.getVertexPosition(u, ii);
                        const d = function(t, e, i, s, a, o, l, h) {
                            let c;
                            if (c = e.side === r ? s.intersectTriangle(l, o, a, !0, h) : s.intersectTriangle(a, o, l, e.side === n, h), null === c) return null;
                            di.copy(h), di.applyMatrix4(t.matrixWorld);
                            const u = i.ray.origin.distanceTo(di);
                            return u < i.near || u > i.far ? null : {
                                distance: u,
                                point: di.clone(),
                                object: t
                            }
                        }(t, e, i, s, ti, ei, ii, ui);
                        if (d) {
                            a && (si.fromBufferAttribute(a, h), ai.fromBufferAttribute(a, c), oi.fromBufferAttribute(a, u), d.uv = Te.getInterpolation(ui, ti, ei, ii, si, ai, oi, new j)), o && (si.fromBufferAttribute(o, h), ai.fromBufferAttribute(o, c), oi.fromBufferAttribute(o, u), d.uv1 = Te.getInterpolation(ui, ti, ei, ii, si, ai, oi, new j)), l && (li.fromBufferAttribute(l, h), hi.fromBufferAttribute(l, c), ci.fromBufferAttribute(l, u), d.normal = Te.getInterpolation(ui, ti, ei, ii, li, hi, ci, new dt), d.normal.dot(s.direction) > 0 && d.normal.multiplyScalar(-1));
                            const t = {
                                a: h,
                                b: c,
                                c: u,
                                normal: new dt,
                                materialIndex: 0
                            };
                            Te.getNormal(ti, ei, ii, t.normal), d.face = t
                        }
                        return d
                    }
                    class fi extends Je {
                        constructor(t = 1, e = 1, i = 1, n = 1, r = 1, s = 1) {
                            super(), this.type = "BoxGeometry", this.parameters = {
                                width: t,
                                height: e,
                                depth: i,
                                widthSegments: n,
                                heightSegments: r,
                                depthSegments: s
                            };
                            const a = this;
                            n = Math.floor(n), r = Math.floor(r), s = Math.floor(s);
                            const o = [],
                                l = [],
                                h = [],
                                c = [];
                            let u = 0,
                                d = 0;

                            function p(t, e, i, n, r, s, p, m, f, g, v) {
                                const _ = s / f,
                                    y = p / g,
                                    x = s / 2,
                                    M = p / 2,
                                    b = m / 2,
                                    S = f + 1,
                                    w = g + 1;
                                let A = 0,
                                    T = 0;
                                const E = new dt;
                                for (let s = 0; s < w; s++) {
                                    const a = s * y - M;
                                    for (let o = 0; o < S; o++) {
                                        const u = o * _ - x;
                                        E[t] = u * n, E[e] = a * r, E[i] = b, l.push(E.x, E.y, E.z), E[t] = 0, E[e] = 0, E[i] = m > 0 ? 1 : -1, h.push(E.x, E.y, E.z), c.push(o / f), c.push(1 - s / g), A += 1
                                    }
                                }
                                for (let t = 0; t < g; t++)
                                    for (let e = 0; e < f; e++) {
                                        const i = u + e + S * t,
                                            n = u + e + S * (t + 1),
                                            r = u + (e + 1) + S * (t + 1),
                                            s = u + (e + 1) + S * t;
                                        o.push(i, n, s), o.push(n, r, s), T += 6
                                    }
                                a.addGroup(d, T, v), d += T, u += A
                            }
                            p("z", "y", "x", -1, -1, i, e, t, s, r, 0), p("z", "y", "x", 1, -1, i, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, s, 2), p("x", "z", "y", 1, -1, t, i, -e, n, s, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new Ve(l, 3)), this.setAttribute("normal", new Ve(h, 3)), this.setAttribute("uv", new Ve(c, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new fi(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                        }
                    }

                    function gi(t) {
                        const e = {};
                        for (const i in t) {
                            e[i] = {};
                            for (const n in t[i]) {
                                const r = t[i][n];
                                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][n] = null) : e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                            }
                        }
                        return e
                    }

                    function vi(t) {
                        const e = {};
                        for (let i = 0; i < t.length; i++) {
                            const n = gi(t[i]);
                            for (const t in n) e[t] = n[t]
                        }
                        return e
                    }
                    const _i = {
                        clone: gi,
                        merge: vi
                    };
                    class yi extends Ne {
                        constructor(t) {
                            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                                clipCullDistance: !1,
                                multiDraw: !1
                            }, this.defaultAttributeValues = {
                                color: [1, 1, 1],
                                uv: [0, 0],
                                uv1: [0, 0]
                            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = gi(t.uniforms), this.uniformsGroups = function(t) {
                                const e = [];
                                for (let i = 0; i < t.length; i++) e.push(t[i].clone());
                                return e
                            }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                        }
                        toJSON(t) {
                            const e = super.toJSON(t);
                            e.glslVersion = this.glslVersion, e.uniforms = {};
                            for (const i in this.uniforms) {
                                const n = this.uniforms[i].value;
                                n && n.isTexture ? e.uniforms[i] = {
                                    type: "t",
                                    value: n.toJSON(t).uuid
                                } : n && n.isColor ? e.uniforms[i] = {
                                    type: "c",
                                    value: n.getHex()
                                } : n && n.isVector2 ? e.uniforms[i] = {
                                    type: "v2",
                                    value: n.toArray()
                                } : n && n.isVector3 ? e.uniforms[i] = {
                                    type: "v3",
                                    value: n.toArray()
                                } : n && n.isVector4 ? e.uniforms[i] = {
                                    type: "v4",
                                    value: n.toArray()
                                } : n && n.isMatrix3 ? e.uniforms[i] = {
                                    type: "m3",
                                    value: n.toArray()
                                } : n && n.isMatrix4 ? e.uniforms[i] = {
                                    type: "m4",
                                    value: n.toArray()
                                } : e.uniforms[i] = {
                                    value: n
                                }
                            }
                            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                            const i = {};
                            for (const t in this.extensions) !0 === this.extensions[t] && (i[t] = !0);
                            return Object.keys(i).length > 0 && (e.extensions = i), e
                        }
                    }
                    const xi = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        Mi = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        bi = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        Si = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        wi = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        Ai = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        Ti = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        Ei = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
                        Ci = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        Ri = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        Pi = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        Ii = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        Li = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        Ui = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        Ni = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        Di = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        Oi = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        Bi = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        zi = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        Fi = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        ki = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        Vi = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                        Hi = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        Gi = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        Wi = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                        ji = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        Xi = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        qi = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        Yi = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        Ji = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        Zi = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        Ki = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                        Qi = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        $i = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                        tn = {
                            common: {
                                diffuse: {
                                    value: new Ie(16777215)
                                },
                                opacity: {
                                    value: 1
                                },
                                map: {
                                    value: null
                                },
                                mapTransform: {
                                    value: new X
                                },
                                alphaMap: {
                                    value: null
                                },
                                alphaMapTransform: {
                                    value: new X
                                },
                                alphaTest: {
                                    value: 0
                                }
                            },
                            specularmap: {
                                specularMap: {
                                    value: null
                                },
                                specularMapTransform: {
                                    value: new X
                                }
                            },
                            envmap: {
                                envMap: {
                                    value: null
                                },
                                envMapRotation: {
                                    value: new X
                                },
                                flipEnvMap: {
                                    value: -1
                                },
                                reflectivity: {
                                    value: 1
                                },
                                ior: {
                                    value: 1.5
                                },
                                refractionRatio: {
                                    value: .98
                                }
                            },
                            aomap: {
                                aoMap: {
                                    value: null
                                },
                                aoMapIntensity: {
                                    value: 1
                                },
                                aoMapTransform: {
                                    value: new X
                                }
                            },
                            lightmap: {
                                lightMap: {
                                    value: null
                                },
                                lightMapIntensity: {
                                    value: 1
                                },
                                lightMapTransform: {
                                    value: new X
                                }
                            },
                            bumpmap: {
                                bumpMap: {
                                    value: null
                                },
                                bumpMapTransform: {
                                    value: new X
                                },
                                bumpScale: {
                                    value: 1
                                }
                            },
                            normalmap: {
                                normalMap: {
                                    value: null
                                },
                                normalMapTransform: {
                                    value: new X
                                },
                                normalScale: {
                                    value: new j(1, 1)
                                }
                            },
                            displacementmap: {
                                displacementMap: {
                                    value: null
                                },
                                displacementMapTransform: {
                                    value: new X
                                },
                                displacementScale: {
                                    value: 1
                                },
                                displacementBias: {
                                    value: 0
                                }
                            },
                            emissivemap: {
                                emissiveMap: {
                                    value: null
                                },
                                emissiveMapTransform: {
                                    value: new X
                                }
                            },
                            metalnessmap: {
                                metalnessMap: {
                                    value: null
                                },
                                metalnessMapTransform: {
                                    value: new X
                                }
                            },
                            roughnessmap: {
                                roughnessMap: {
                                    value: null
                                },
                                roughnessMapTransform: {
                                    value: new X
                                }
                            },
                            gradientmap: {
                                gradientMap: {
                                    value: null
                                }
                            },
                            fog: {
                                fogDensity: {
                                    value: 25e-5
                                },
                                fogNear: {
                                    value: 1
                                },
                                fogFar: {
                                    value: 2e3
                                },
                                fogColor: {
                                    value: new Ie(16777215)
                                }
                            },
                            lights: {
                                ambientLightColor: {
                                    value: []
                                },
                                lightProbe: {
                                    value: []
                                },
                                directionalLights: {
                                    value: [],
                                    properties: {
                                        direction: {},
                                        color: {}
                                    }
                                },
                                directionalLightShadows: {
                                    value: [],
                                    properties: {
                                        shadowIntensity: 1,
                                        shadowBias: {},
                                        shadowNormalBias: {},
                                        shadowRadius: {},
                                        shadowMapSize: {}
                                    }
                                },
                                directionalShadowMap: {
                                    value: []
                                },
                                directionalShadowMatrix: {
                                    value: []
                                },
                                spotLights: {
                                    value: [],
                                    properties: {
                                        color: {},
                                        position: {},
                                        direction: {},
                                        distance: {},
                                        coneCos: {},
                                        penumbraCos: {},
                                        decay: {}
                                    }
                                },
                                spotLightShadows: {
                                    value: [],
                                    properties: {
                                        shadowIntensity: 1,
                                        shadowBias: {},
                                        shadowNormalBias: {},
                                        shadowRadius: {},
                                        shadowMapSize: {}
                                    }
                                },
                                spotLightMap: {
                                    value: []
                                },
                                spotShadowMap: {
                                    value: []
                                },
                                spotLightMatrix: {
                                    value: []
                                },
                                pointLights: {
                                    value: [],
                                    properties: {
                                        color: {},
                                        position: {},
                                        decay: {},
                                        distance: {}
                                    }
                                },
                                pointLightShadows: {
                                    value: [],
                                    properties: {
                                        shadowIntensity: 1,
                                        shadowBias: {},
                                        shadowNormalBias: {},
                                        shadowRadius: {},
                                        shadowMapSize: {},
                                        shadowCameraNear: {},
                                        shadowCameraFar: {}
                                    }
                                },
                                pointShadowMap: {
                                    value: []
                                },
                                pointShadowMatrix: {
                                    value: []
                                },
                                hemisphereLights: {
                                    value: [],
                                    properties: {
                                        direction: {},
                                        skyColor: {},
                                        groundColor: {}
                                    }
                                },
                                rectAreaLights: {
                                    value: [],
                                    properties: {
                                        color: {},
                                        position: {},
                                        width: {},
                                        height: {}
                                    }
                                },
                                ltc_1: {
                                    value: null
                                },
                                ltc_2: {
                                    value: null
                                }
                            },
                            points: {
                                diffuse: {
                                    value: new Ie(16777215)
                                },
                                opacity: {
                                    value: 1
                                },
                                size: {
                                    value: 1
                                },
                                scale: {
                                    value: 1
                                },
                                map: {
                                    value: null
                                },
                                alphaMap: {
                                    value: null
                                },
                                alphaMapTransform: {
                                    value: new X
                                },
                                alphaTest: {
                                    value: 0
                                },
                                uvTransform: {
                                    value: new X
                                }
                            },
                            sprite: {
                                diffuse: {
                                    value: new Ie(16777215)
                                },
                                opacity: {
                                    value: 1
                                },
                                center: {
                                    value: new j(.5, .5)
                                },
                                rotation: {
                                    value: 0
                                },
                                map: {
                                    value: null
                                },
                                mapTransform: {
                                    value: new X
                                },
                                alphaMap: {
                                    value: null
                                },
                                alphaMapTransform: {
                                    value: new X
                                },
                                alphaTest: {
                                    value: 0
                                }
                            }
                        },
                        en = {
                            basic: {
                                uniforms: vi([tn.common, tn.specularmap, tn.envmap, tn.aomap, tn.lightmap, tn.fog]),
                                vertexShader: Ni,
                                fragmentShader: Di
                            },
                            lambert: {
                                uniforms: vi([tn.common, tn.specularmap, tn.envmap, tn.aomap, tn.lightmap, tn.emissivemap, tn.bumpmap, tn.normalmap, tn.displacementmap, tn.fog, tn.lights, {
                                    emissive: {
                                        value: new Ie(0)
                                    }
                                }]),
                                vertexShader: Oi,
                                fragmentShader: Bi
                            },
                            phong: {
                                uniforms: vi([tn.common, tn.specularmap, tn.envmap, tn.aomap, tn.lightmap, tn.emissivemap, tn.bumpmap, tn.normalmap, tn.displacementmap, tn.fog, tn.lights, {
                                    emissive: {
                                        value: new Ie(0)
                                    },
                                    specular: {
                                        value: new Ie(1118481)
                                    },
                                    shininess: {
                                        value: 30
                                    }
                                }]),
                                vertexShader: Hi,
                                fragmentShader: Gi
                            },
                            standard: {
                                uniforms: vi([tn.common, tn.envmap, tn.aomap, tn.lightmap, tn.emissivemap, tn.bumpmap, tn.normalmap, tn.displacementmap, tn.roughnessmap, tn.metalnessmap, tn.fog, tn.lights, {
                                    emissive: {
                                        value: new Ie(0)
                                    },
                                    roughness: {
                                        value: 1
                                    },
                                    metalness: {
                                        value: 0
                                    },
                                    envMapIntensity: {
                                        value: 1
                                    }
                                }]),
                                vertexShader: Wi,
                                fragmentShader: ji
                            },
                            toon: {
                                uniforms: vi([tn.common, tn.aomap, tn.lightmap, tn.emissivemap, tn.bumpmap, tn.normalmap, tn.displacementmap, tn.gradientmap, tn.fog, tn.lights, {
                                    emissive: {
                                        value: new Ie(0)
                                    }
                                }]),
                                vertexShader: Xi,
                                fragmentShader: qi
                            },
                            matcap: {
                                uniforms: vi([tn.common, tn.bumpmap, tn.normalmap, tn.displacementmap, tn.fog, {
                                    matcap: {
                                        value: null
                                    }
                                }]),
                                vertexShader: zi,
                                fragmentShader: Fi
                            },
                            points: {
                                uniforms: vi([tn.points, tn.fog]),
                                vertexShader: Yi,
                                fragmentShader: Ji
                            },
                            dashed: {
                                uniforms: vi([tn.common, tn.fog, {
                                    scale: {
                                        value: 1
                                    },
                                    dashSize: {
                                        value: 1
                                    },
                                    totalSize: {
                                        value: 2
                                    }
                                }]),
                                vertexShader: Li,
                                fragmentShader: Ui
                            },
                            depth: {
                                uniforms: vi([tn.common, tn.displacementmap]),
                                vertexShader: Ti,
                                fragmentShader: Ei
                            },
                            normal: {
                                uniforms: vi([tn.common, tn.bumpmap, tn.normalmap, tn.displacementmap, {
                                    opacity: {
                                        value: 1
                                    }
                                }]),
                                vertexShader: ki,
                                fragmentShader: Vi
                            },
                            sprite: {
                                uniforms: vi([tn.sprite, tn.fog]),
                                vertexShader: Qi,
                                fragmentShader: $i
                            },
                            background: {
                                uniforms: {
                                    uvTransform: {
                                        value: new X
                                    },
                                    t2D: {
                                        value: null
                                    },
                                    backgroundIntensity: {
                                        value: 1
                                    }
                                },
                                vertexShader: xi,
                                fragmentShader: Mi
                            },
                            backgroundCube: {
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    flipEnvMap: {
                                        value: -1
                                    },
                                    backgroundBlurriness: {
                                        value: 0
                                    },
                                    backgroundIntensity: {
                                        value: 1
                                    },
                                    backgroundRotation: {
                                        value: new X
                                    }
                                },
                                vertexShader: bi,
                                fragmentShader: Si
                            },
                            cube: {
                                uniforms: {
                                    tCube: {
                                        value: null
                                    },
                                    tFlip: {
                                        value: -1
                                    },
                                    opacity: {
                                        value: 1
                                    }
                                },
                                vertexShader: wi,
                                fragmentShader: Ai
                            },
                            equirect: {
                                uniforms: {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                vertexShader: Pi,
                                fragmentShader: Ii
                            },
                            distanceRGBA: {
                                uniforms: vi([tn.common, tn.displacementmap, {
                                    referencePosition: {
                                        value: new dt
                                    },
                                    nearDistance: {
                                        value: 1
                                    },
                                    farDistance: {
                                        value: 1e3
                                    }
                                }]),
                                vertexShader: Ci,
                                fragmentShader: Ri
                            },
                            shadow: {
                                uniforms: vi([tn.lights, tn.fog, {
                                    color: {
                                        value: new Ie(0)
                                    },
                                    opacity: {
                                        value: 1
                                    }
                                }]),
                                vertexShader: Zi,
                                fragmentShader: Ki
                            }
                        };
                    en.physical = {
                        uniforms: vi([en.standard.uniforms, {
                            clearcoat: {
                                value: 0
                            },
                            clearcoatMap: {
                                value: null
                            },
                            clearcoatMapTransform: {
                                value: new X
                            },
                            clearcoatNormalMap: {
                                value: null
                            },
                            clearcoatNormalMapTransform: {
                                value: new X
                            },
                            clearcoatNormalScale: {
                                value: new j(1, 1)
                            },
                            clearcoatRoughness: {
                                value: 0
                            },
                            clearcoatRoughnessMap: {
                                value: null
                            },
                            clearcoatRoughnessMapTransform: {
                                value: new X
                            },
                            dispersion: {
                                value: 0
                            },
                            iridescence: {
                                value: 0
                            },
                            iridescenceMap: {
                                value: null
                            },
                            iridescenceMapTransform: {
                                value: new X
                            },
                            iridescenceIOR: {
                                value: 1.3
                            },
                            iridescenceThicknessMinimum: {
                                value: 100
                            },
                            iridescenceThicknessMaximum: {
                                value: 400
                            },
                            iridescenceThicknessMap: {
                                value: null
                            },
                            iridescenceThicknessMapTransform: {
                                value: new X
                            },
                            sheen: {
                                value: 0
                            },
                            sheenColor: {
                                value: new Ie(0)
                            },
                            sheenColorMap: {
                                value: null
                            },
                            sheenColorMapTransform: {
                                value: new X
                            },
                            sheenRoughness: {
                                value: 1
                            },
                            sheenRoughnessMap: {
                                value: null
                            },
                            sheenRoughnessMapTransform: {
                                value: new X
                            },
                            transmission: {
                                value: 0
                            },
                            transmissionMap: {
                                value: null
                            },
                            transmissionMapTransform: {
                                value: new X
                            },
                            transmissionSamplerSize: {
                                value: new j
                            },
                            transmissionSamplerMap: {
                                value: null
                            },
                            thickness: {
                                value: 0
                            },
                            thicknessMap: {
                                value: null
                            },
                            thicknessMapTransform: {
                                value: new X
                            },
                            attenuationDistance: {
                                value: 0
                            },
                            attenuationColor: {
                                value: new Ie(0)
                            },
                            specularColor: {
                                value: new Ie(1, 1, 1)
                            },
                            specularColorMap: {
                                value: null
                            },
                            specularColorMapTransform: {
                                value: new X
                            },
                            specularIntensity: {
                                value: 1
                            },
                            specularIntensityMap: {
                                value: null
                            },
                            specularIntensityMapTransform: {
                                value: new X
                            },
                            anisotropyVector: {
                                value: new j
                            },
                            anisotropyMap: {
                                value: null
                            },
                            anisotropyMapTransform: {
                                value: new X
                            }
                        }]),
                        vertexShader: Wi,
                        fragmentShader: ji
                    }, Math.sqrt(5), new Float32Array(16), new Float32Array(9), new Float32Array(4), new Map;
                    const nn = new dt,
                        rn = new ct,
                        sn = new ct,
                        an = new dt,
                        on = new Ht,
                        ln = new dt,
                        hn = new Ut,
                        cn = new Ht,
                        un = new Vt;
                    class dn extends pi {
                        constructor(t, e) {
                            super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = d, this.bindMatrix = new Ht, this.bindMatrixInverse = new Ht, this.boundingBox = null, this.boundingSphere = null
                        }
                        computeBoundingBox() {
                            const t = this.geometry;
                            null === this.boundingBox && (this.boundingBox = new ft), this.boundingBox.makeEmpty();
                            const e = t.getAttribute("position");
                            for (let t = 0; t < e.count; t++) this.getVertexPosition(t, ln), this.boundingBox.expandByPoint(ln)
                        }
                        computeBoundingSphere() {
                            const t = this.geometry;
                            null === this.boundingSphere && (this.boundingSphere = new Ut), this.boundingSphere.makeEmpty();
                            const e = t.getAttribute("position");
                            for (let t = 0; t < e.count; t++) this.getVertexPosition(t, ln), this.boundingSphere.expandByPoint(ln)
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                        }
                        raycast(t, e) {
                            const i = this.material,
                                n = this.matrixWorld;
                            void 0 !== i && (null === this.boundingSphere && this.computeBoundingSphere(), hn.copy(this.boundingSphere), hn.applyMatrix4(n), !1 !== t.ray.intersectsSphere(hn) && (cn.copy(n).invert(), un.copy(t.ray).applyMatrix4(cn), null !== this.boundingBox && !1 === un.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, un)))
                        }
                        getVertexPosition(t, e) {
                            return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
                        }
                        bind(t, e) {
                            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                        }
                        pose() {
                            this.skeleton.pose()
                        }
                        normalizeSkinWeights() {
                            const t = new ct,
                                e = this.geometry.attributes.skinWeight;
                            for (let i = 0, n = e.count; i < n; i++) {
                                t.fromBufferAttribute(e, i);
                                const n = 1 / t.manhattanLength();
                                n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                            }
                        }
                        updateMatrixWorld(t) {
                            super.updateMatrixWorld(t), this.bindMode === d ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                        }
                        applyBoneTransform(t, e) {
                            const i = this.skeleton,
                                n = this.geometry;
                            rn.fromBufferAttribute(n.attributes.skinIndex, t), sn.fromBufferAttribute(n.attributes.skinWeight, t), nn.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                            for (let t = 0; t < 4; t++) {
                                const n = sn.getComponent(t);
                                if (0 !== n) {
                                    const r = rn.getComponent(t);
                                    on.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), e.addScaledVector(an.copy(nn).applyMatrix4(on), n)
                                }
                            }
                            return e.applyMatrix4(this.bindMatrixInverse)
                        }
                    }
                    class pn extends fe {
                        constructor() {
                            super(), this.isBone = !0, this.type = "Bone"
                        }
                    }
                    class mn extends ht {
                        constructor(t = null, e = 1, i = 1, n, r, s, a, o, l = f, h = f, c, u) {
                            super(null, s, a, o, l, h, n, r, c, u), this.isDataTexture = !0, this.image = {
                                data: t,
                                width: e,
                                height: i
                            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                        }
                    }
                    const fn = new Ht,
                        gn = new Ht;
                    class vn {
                        constructor(t = [], e = []) {
                            this.uuid = k(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.init()
                        }
                        init() {
                            const t = this.bones,
                                e = this.boneInverses;
                            if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                            else if (t.length !== e.length) {
                                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                                for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Ht)
                            }
                        }
                        calculateInverses() {
                            this.boneInverses.length = 0;
                            for (let t = 0, e = this.bones.length; t < e; t++) {
                                const e = new Ht;
                                this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                            }
                        }
                        pose() {
                            for (let t = 0, e = this.bones.length; t < e; t++) {
                                const e = this.bones[t];
                                e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                            }
                            for (let t = 0, e = this.bones.length; t < e; t++) {
                                const e = this.bones[t];
                                e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                            }
                        }
                        update() {
                            const t = this.bones,
                                e = this.boneInverses,
                                i = this.boneMatrices,
                                n = this.boneTexture;
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = t[n] ? t[n].matrixWorld : gn;
                                fn.multiplyMatrices(r, e[n]), fn.toArray(i, 16 * n)
                            }
                            null !== n && (n.needsUpdate = !0)
                        }
                        clone() {
                            return new vn(this.bones, this.boneInverses)
                        }
                        computeBoneTexture() {
                            let t = Math.sqrt(4 * this.bones.length);
                            t = 4 * Math.ceil(t / 4), t = Math.max(t, 4);
                            const e = new Float32Array(t * t * 4);
                            e.set(this.boneMatrices);
                            const i = new mn(e, t, t, 1023, 1015);
                            return i.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = i, this
                        }
                        getBoneByName(t) {
                            for (let e = 0, i = this.bones.length; e < i; e++) {
                                const i = this.bones[e];
                                if (i.name === t) return i
                            }
                        }
                        dispose() {
                            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                        }
                        fromJSON(t, e) {
                            this.uuid = t.uuid;
                            for (let i = 0, n = t.bones.length; i < n; i++) {
                                const n = t.bones[i];
                                let r = e[n];
                                void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n), r = new pn), this.bones.push(r), this.boneInverses.push((new Ht).fromArray(t.boneInverses[i]))
                            }
                            return this.init(), this
                        }
                        toJSON() {
                            const t = {
                                metadata: {
                                    version: 4.6,
                                    type: "Skeleton",
                                    generator: "Skeleton.toJSON"
                                },
                                bones: [],
                                boneInverses: []
                            };
                            t.uuid = this.uuid;
                            const e = this.bones,
                                i = this.boneInverses;
                            for (let n = 0, r = e.length; n < r; n++) {
                                const r = e[n];
                                t.bones.push(r.uuid);
                                const s = i[n];
                                t.boneInverses.push(s.toArray())
                            }
                            return t
                        }
                    }
                    class _n extends Ne {
                        constructor(t) {
                            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Ie(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
                        }
                        copy(t) {
                            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
                        }
                    }
                    const yn = new dt,
                        xn = new dt,
                        Mn = new Ht,
                        bn = new Vt,
                        Sn = new Ut,
                        wn = new dt,
                        An = new dt;
                    class Tn extends fe {
                        constructor(t = new Je, e = new _n) {
                            super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                        }
                        copy(t, e) {
                            return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                        }
                        computeLineDistances() {
                            const t = this.geometry;
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    i = [0];
                                for (let t = 1, n = e.count; t < n; t++) yn.fromBufferAttribute(e, t - 1), xn.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += yn.distanceTo(xn);
                                t.setAttribute("lineDistance", new Ve(i, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                        raycast(t, e) {
                            const i = this.geometry,
                                n = this.matrixWorld,
                                r = t.params.Line.threshold,
                                s = i.drawRange;
                            if (null === i.boundingSphere && i.computeBoundingSphere(), Sn.copy(i.boundingSphere), Sn.applyMatrix4(n), Sn.radius += r, !1 === t.ray.intersectsSphere(Sn)) return;
                            Mn.copy(n).invert(), bn.copy(t.ray).applyMatrix4(Mn);
                            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                o = a * a,
                                l = this.isLineSegments ? 2 : 1,
                                h = i.index,
                                c = i.attributes.position;
                            if (null !== h) {
                                const i = Math.max(0, s.start),
                                    n = Math.min(h.count, s.start + s.count);
                                for (let r = i, s = n - 1; r < s; r += l) {
                                    const i = h.getX(r),
                                        n = h.getX(r + 1),
                                        s = En(this, t, bn, o, i, n);
                                    s && e.push(s)
                                }
                                if (this.isLineLoop) {
                                    const r = h.getX(n - 1),
                                        s = h.getX(i),
                                        a = En(this, t, bn, o, r, s);
                                    a && e.push(a)
                                }
                            } else {
                                const i = Math.max(0, s.start),
                                    n = Math.min(c.count, s.start + s.count);
                                for (let r = i, s = n - 1; r < s; r += l) {
                                    const i = En(this, t, bn, o, r, r + 1);
                                    i && e.push(i)
                                }
                                if (this.isLineLoop) {
                                    const r = En(this, t, bn, o, n - 1, i);
                                    r && e.push(r)
                                }
                            }
                        }
                        updateMorphTargets() {
                            const t = this.geometry.morphAttributes,
                                e = Object.keys(t);
                            if (e.length > 0) {
                                const i = t[e[0]];
                                if (void 0 !== i) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t].name || String(t);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                                    }
                                }
                            }
                        }
                    }

                    function En(t, e, i, n, r, s) {
                        const a = t.geometry.attributes.position;
                        if (yn.fromBufferAttribute(a, r), xn.fromBufferAttribute(a, s), i.distanceSqToSegment(yn, xn, wn, An) > n) return;
                        wn.applyMatrix4(t.matrixWorld);
                        const o = e.ray.origin.distanceTo(wn);
                        return o < e.near || o > e.far ? void 0 : {
                            distance: o,
                            point: An.clone().applyMatrix4(t.matrixWorld),
                            index: r,
                            face: null,
                            faceIndex: null,
                            object: t
                        }
                    }
                    class Cn {
                        constructor() {
                            this.type = "Curve", this.arcLengthDivisions = 200
                        }
                        getPoint() {
                            return console.warn("THREE.Curve: .getPoint() not implemented."), null
                        }
                        getPointAt(t, e) {
                            const i = this.getUtoTmapping(t);
                            return this.getPoint(i, e)
                        }
                        getPoints(t = 5) {
                            const e = [];
                            for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                            return e
                        }
                        getSpacedPoints(t = 5) {
                            const e = [];
                            for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                            return e
                        }
                        getLength() {
                            const t = this.getLengths();
                            return t[t.length - 1]
                        }
                        getLengths(t = this.arcLengthDivisions) {
                            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                            this.needsUpdate = !1;
                            const e = [];
                            let i, n = this.getPoint(0),
                                r = 0;
                            e.push(0);
                            for (let s = 1; s <= t; s++) i = this.getPoint(s / t), r += i.distanceTo(n), e.push(r), n = i;
                            return this.cacheArcLengths = e, e
                        }
                        updateArcLengths() {
                            this.needsUpdate = !0, this.getLengths()
                        }
                        getUtoTmapping(t, e) {
                            const i = this.getLengths();
                            let n = 0;
                            const r = i.length;
                            let s;
                            s = e || t * i[r - 1];
                            let a, o = 0,
                                l = r - 1;
                            for (; o <= l;)
                                if (n = Math.floor(o + (l - o) / 2), a = i[n] - s, a < 0) o = n + 1;
                                else {
                                    if (!(a > 0)) {
                                        l = n;
                                        break
                                    }
                                    l = n - 1
                                } if (n = l, i[n] === s) return n / (r - 1);
                            const h = i[n];
                            return (n + (s - h) / (i[n + 1] - h)) / (r - 1)
                        }
                        getTangent(t, e) {
                            const i = 1e-4;
                            let n = t - i,
                                r = t + i;
                            n < 0 && (n = 0), r > 1 && (r = 1);
                            const s = this.getPoint(n),
                                a = this.getPoint(r),
                                o = e || (s.isVector2 ? new j : new dt);
                            return o.copy(a).sub(s).normalize(), o
                        }
                        getTangentAt(t, e) {
                            const i = this.getUtoTmapping(t);
                            return this.getTangent(i, e)
                        }
                        computeFrenetFrames(t, e) {
                            const i = new dt,
                                n = [],
                                r = [],
                                s = [],
                                a = new dt,
                                o = new Ht;
                            for (let e = 0; e <= t; e++) {
                                const i = e / t;
                                n[e] = this.getTangentAt(i, new dt)
                            }
                            r[0] = new dt, s[0] = new dt;
                            let l = Number.MAX_VALUE;
                            const h = Math.abs(n[0].x),
                                c = Math.abs(n[0].y),
                                u = Math.abs(n[0].z);
                            h <= l && (l = h, i.set(1, 0, 0)), c <= l && (l = c, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), s[0].crossVectors(n[0], r[0]);
                            for (let e = 1; e <= t; e++) {
                                if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(n[e - 1], n[e]), a.length() > Number.EPSILON) {
                                    a.normalize();
                                    const t = Math.acos(V(n[e - 1].dot(n[e]), -1, 1));
                                    r[e].applyMatrix4(o.makeRotationAxis(a, t))
                                }
                                s[e].crossVectors(n[e], r[e])
                            }
                            if (!0 === e) {
                                let e = Math.acos(V(r[0].dot(r[t]), -1, 1));
                                e /= t, n[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                                for (let i = 1; i <= t; i++) r[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)), s[i].crossVectors(n[i], r[i])
                            }
                            return {
                                tangents: n,
                                normals: r,
                                binormals: s
                            }
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(t) {
                            return this.arcLengthDivisions = t.arcLengthDivisions, this
                        }
                        toJSON() {
                            const t = {
                                metadata: {
                                    version: 4.6,
                                    type: "Curve",
                                    generator: "Curve.toJSON"
                                }
                            };
                            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                        }
                        fromJSON(t) {
                            return this.arcLengthDivisions = t.arcLengthDivisions, this
                        }
                    }
                    class Rn extends Cn {
                        constructor(t = 0, e = 0, i = 1, n = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                            super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                        }
                        getPoint(t, e = new j) {
                            const i = e,
                                n = 2 * Math.PI;
                            let r = this.aEndAngle - this.aStartAngle;
                            const s = Math.abs(r) < Number.EPSILON;
                            for (; r < 0;) r += n;
                            for (; r > n;) r -= n;
                            r < Number.EPSILON && (r = s ? 0 : n), !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
                            const a = this.aStartAngle + t * r;
                            let o = this.aX + this.xRadius * Math.cos(a),
                                l = this.aY + this.yRadius * Math.sin(a);
                            if (0 !== this.aRotation) {
                                const t = Math.cos(this.aRotation),
                                    e = Math.sin(this.aRotation),
                                    i = o - this.aX,
                                    n = l - this.aY;
                                o = i * t - n * e + this.aX, l = i * e + n * t + this.aY
                            }
                            return i.set(o, l)
                        }
                        copy(t) {
                            return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                        }
                    }

                    function Pn() {
                        let t = 0,
                            e = 0,
                            i = 0,
                            n = 0;

                        function r(r, s, a, o) {
                            t = r, e = a, i = -3 * r + 3 * s - 2 * a - o, n = 2 * r - 2 * s + a + o
                        }
                        return {
                            initCatmullRom: function(t, e, i, n, s) {
                                r(e, i, s * (i - t), s * (n - e))
                            },
                            initNonuniformCatmullRom: function(t, e, i, n, s, a, o) {
                                let l = (e - t) / s - (i - t) / (s + a) + (i - e) / a,
                                    h = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                                l *= a, h *= a, r(e, i, l, h)
                            },
                            calc: function(r) {
                                const s = r * r;
                                return t + e * r + i * s + n * (s * r)
                            }
                        }
                    }
                    const In = new dt,
                        Ln = new Pn,
                        Un = new Pn,
                        Nn = new Pn;

                    function Dn(t, e, i, n, r) {
                        const s = .5 * (n - e),
                            a = .5 * (r - i),
                            o = t * t;
                        return (2 * i - 2 * n + s + a) * (t * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
                    }

                    function On(t, e, i, n) {
                        return function(t, e) {
                            const i = 1 - t;
                            return i * i * e
                        }(t, e) + function(t, e) {
                            return 2 * (1 - t) * t * e
                        }(t, i) + function(t, e) {
                            return t * t * e
                        }(t, n)
                    }

                    function Bn(t, e, i, n, r) {
                        return function(t, e) {
                            const i = 1 - t;
                            return i * i * i * e
                        }(t, e) + function(t, e) {
                            const i = 1 - t;
                            return 3 * i * i * t * e
                        }(t, i) + function(t, e) {
                            return 3 * (1 - t) * t * t * e
                        }(t, n) + function(t, e) {
                            return t * t * t * e
                        }(t, r)
                    }
                    class zn extends Cn {
                        constructor(t = new j, e = new j, i = new j, n = new j) {
                            super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
                        }
                        getPoint(t, e = new j) {
                            const i = e,
                                n = this.v0,
                                r = this.v1,
                                s = this.v2,
                                a = this.v3;
                            return i.set(Bn(t, n.x, r.x, s.x, a.x), Bn(t, n.y, r.y, s.y, a.y)), i
                        }
                        copy(t) {
                            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                        }
                    }
                    class Fn extends Cn {
                        constructor(t = new j, e = new j) {
                            super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
                        }
                        getPoint(t, e = new j) {
                            const i = e;
                            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
                        }
                        getPointAt(t, e) {
                            return this.getPoint(t, e)
                        }
                        getTangent(t, e = new j) {
                            return e.subVectors(this.v2, this.v1).normalize()
                        }
                        getTangentAt(t, e) {
                            return this.getTangent(t, e)
                        }
                        copy(t) {
                            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    }
                    class kn extends Cn {
                        constructor(t = new j, e = new j, i = new j) {
                            super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i
                        }
                        getPoint(t, e = new j) {
                            const i = e,
                                n = this.v0,
                                r = this.v1,
                                s = this.v2;
                            return i.set(On(t, n.x, r.x, s.x), On(t, n.y, r.y, s.y)), i
                        }
                        copy(t) {
                            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    }
                    class Vn extends Cn {
                        constructor(t = []) {
                            super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
                        }
                        getPoint(t, e = new j) {
                            const i = e,
                                n = this.points,
                                r = (n.length - 1) * t,
                                s = Math.floor(r),
                                a = r - s,
                                o = n[0 === s ? s : s - 1],
                                l = n[s],
                                h = n[s > n.length - 2 ? n.length - 1 : s + 1],
                                c = n[s > n.length - 3 ? n.length - 1 : s + 2];
                            return i.set(Dn(a, o.x, l.x, h.x, c.x), Dn(a, o.y, l.y, h.y, c.y)), i
                        }
                        copy(t) {
                            super.copy(t), this.points = [];
                            for (let e = 0, i = t.points.length; e < i; e++) {
                                const i = t.points[e];
                                this.points.push(i.clone())
                            }
                            return this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            t.points = [];
                            for (let e = 0, i = this.points.length; e < i; e++) {
                                const i = this.points[e];
                                t.points.push(i.toArray())
                            }
                            return t
                        }
                        fromJSON(t) {
                            super.fromJSON(t), this.points = [];
                            for (let e = 0, i = t.points.length; e < i; e++) {
                                const i = t.points[e];
                                this.points.push((new j).fromArray(i))
                            }
                            return this
                        }
                    }
                    var Hn = Object.freeze({
                        __proto__: null,
                        ArcCurve: class extends Rn {
                            constructor(t, e, i, n, r, s) {
                                super(t, e, i, i, n, r, s), this.isArcCurve = !0, this.type = "ArcCurve"
                            }
                        },
                        CatmullRomCurve3: class extends Cn {
                            constructor(t = [], e = !1, i = "centripetal", n = .5) {
                                super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = n
                            }
                            getPoint(t, e = new dt) {
                                const i = e,
                                    n = this.points,
                                    r = n.length,
                                    s = (r - (this.closed ? 0 : 1)) * t;
                                let a, o, l = Math.floor(s),
                                    h = s - l;
                                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2, h = 1), this.closed || l > 0 ? a = n[(l - 1) % r] : (In.subVectors(n[0], n[1]).add(n[0]), a = In);
                                const c = n[l % r],
                                    u = n[(l + 1) % r];
                                if (this.closed || l + 2 < r ? o = n[(l + 2) % r] : (In.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), o = In), "centripetal" === this.curveType || "chordal" === this.curveType) {
                                    const t = "chordal" === this.curveType ? .5 : .25;
                                    let e = Math.pow(a.distanceToSquared(c), t),
                                        i = Math.pow(c.distanceToSquared(u), t),
                                        n = Math.pow(u.distanceToSquared(o), t);
                                    i < 1e-4 && (i = 1), e < 1e-4 && (e = i), n < 1e-4 && (n = i), Ln.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, e, i, n), Un.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, e, i, n), Nn.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, e, i, n)
                                } else "catmullrom" === this.curveType && (Ln.initCatmullRom(a.x, c.x, u.x, o.x, this.tension), Un.initCatmullRom(a.y, c.y, u.y, o.y, this.tension), Nn.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
                                return i.set(Ln.calc(h), Un.calc(h), Nn.calc(h)), i
                            }
                            copy(t) {
                                super.copy(t), this.points = [];
                                for (let e = 0, i = t.points.length; e < i; e++) {
                                    const i = t.points[e];
                                    this.points.push(i.clone())
                                }
                                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                            }
                            toJSON() {
                                const t = super.toJSON();
                                t.points = [];
                                for (let e = 0, i = this.points.length; e < i; e++) {
                                    const i = this.points[e];
                                    t.points.push(i.toArray())
                                }
                                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                            }
                            fromJSON(t) {
                                super.fromJSON(t), this.points = [];
                                for (let e = 0, i = t.points.length; e < i; e++) {
                                    const i = t.points[e];
                                    this.points.push((new dt).fromArray(i))
                                }
                                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                            }
                        },
                        CubicBezierCurve: zn,
                        CubicBezierCurve3: class extends Cn {
                            constructor(t = new dt, e = new dt, i = new dt, n = new dt) {
                                super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
                            }
                            getPoint(t, e = new dt) {
                                const i = e,
                                    n = this.v0,
                                    r = this.v1,
                                    s = this.v2,
                                    a = this.v3;
                                return i.set(Bn(t, n.x, r.x, s.x, a.x), Bn(t, n.y, r.y, s.y, a.y), Bn(t, n.z, r.z, s.z, a.z)), i
                            }
                            copy(t) {
                                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                            }
                            toJSON() {
                                const t = super.toJSON();
                                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                            }
                            fromJSON(t) {
                                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                            }
                        },
                        EllipseCurve: Rn,
                        LineCurve: Fn,
                        LineCurve3: class extends Cn {
                            constructor(t = new dt, e = new dt) {
                                super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
                            }
                            getPoint(t, e = new dt) {
                                const i = e;
                                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
                            }
                            getPointAt(t, e) {
                                return this.getPoint(t, e)
                            }
                            getTangent(t, e = new dt) {
                                return e.subVectors(this.v2, this.v1).normalize()
                            }
                            getTangentAt(t, e) {
                                return this.getTangent(t, e)
                            }
                            copy(t) {
                                return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                            }
                            toJSON() {
                                const t = super.toJSON();
                                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                            }
                            fromJSON(t) {
                                return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                            }
                        },
                        QuadraticBezierCurve: kn,
                        QuadraticBezierCurve3: class extends Cn {
                            constructor(t = new dt, e = new dt, i = new dt) {
                                super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i
                            }
                            getPoint(t, e = new dt) {
                                const i = e,
                                    n = this.v0,
                                    r = this.v1,
                                    s = this.v2;
                                return i.set(On(t, n.x, r.x, s.x), On(t, n.y, r.y, s.y), On(t, n.z, r.z, s.z)), i
                            }
                            copy(t) {
                                return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                            }
                            toJSON() {
                                const t = super.toJSON();
                                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                            }
                            fromJSON(t) {
                                return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                            }
                        },
                        SplineCurve: Vn
                    });
                    class Gn extends Cn {
                        constructor() {
                            super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                        }
                        add(t) {
                            this.curves.push(t)
                        }
                        closePath() {
                            const t = this.curves[0].getPoint(0),
                                e = this.curves[this.curves.length - 1].getPoint(1);
                            if (!t.equals(e)) {
                                const i = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
                                this.curves.push(new Hn[i](e, t))
                            }
                            return this
                        }
                        getPoint(t, e) {
                            const i = t * this.getLength(),
                                n = this.getCurveLengths();
                            let r = 0;
                            for (; r < n.length;) {
                                if (n[r] >= i) {
                                    const t = n[r] - i,
                                        s = this.curves[r],
                                        a = s.getLength(),
                                        o = 0 === a ? 0 : 1 - t / a;
                                    return s.getPointAt(o, e)
                                }
                                r++
                            }
                            return null
                        }
                        getLength() {
                            const t = this.getCurveLengths();
                            return t[t.length - 1]
                        }
                        updateArcLengths() {
                            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                        }
                        getCurveLengths() {
                            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                            const t = [];
                            let e = 0;
                            for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                            return this.cacheLengths = t, t
                        }
                        getSpacedPoints(t = 40) {
                            const e = [];
                            for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                            return this.autoClose && e.push(e[0]), e
                        }
                        getPoints(t = 12) {
                            const e = [];
                            let i;
                            for (let n = 0, r = this.curves; n < r.length; n++) {
                                const s = r[n],
                                    a = s.isEllipseCurve ? 2 * t : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? t * s.points.length : t,
                                    o = s.getPoints(a);
                                for (let t = 0; t < o.length; t++) {
                                    const n = o[t];
                                    i && i.equals(n) || (e.push(n), i = n)
                                }
                            }
                            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                        }
                        copy(t) {
                            super.copy(t), this.curves = [];
                            for (let e = 0, i = t.curves.length; e < i; e++) {
                                const i = t.curves[e];
                                this.curves.push(i.clone())
                            }
                            return this.autoClose = t.autoClose, this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            t.autoClose = this.autoClose, t.curves = [];
                            for (let e = 0, i = this.curves.length; e < i; e++) {
                                const i = this.curves[e];
                                t.curves.push(i.toJSON())
                            }
                            return t
                        }
                        fromJSON(t) {
                            super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                            for (let e = 0, i = t.curves.length; e < i; e++) {
                                const i = t.curves[e];
                                this.curves.push((new Hn[i.type]).fromJSON(i))
                            }
                            return this
                        }
                    }
                    class Wn extends Gn {
                        constructor(t) {
                            super(), this.type = "Path", this.currentPoint = new j, t && this.setFromPoints(t)
                        }
                        setFromPoints(t) {
                            this.moveTo(t[0].x, t[0].y);
                            for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                            return this
                        }
                        moveTo(t, e) {
                            return this.currentPoint.set(t, e), this
                        }
                        lineTo(t, e) {
                            const i = new Fn(this.currentPoint.clone(), new j(t, e));
                            return this.curves.push(i), this.currentPoint.set(t, e), this
                        }
                        quadraticCurveTo(t, e, i, n) {
                            const r = new kn(this.currentPoint.clone(), new j(t, e), new j(i, n));
                            return this.curves.push(r), this.currentPoint.set(i, n), this
                        }
                        bezierCurveTo(t, e, i, n, r, s) {
                            const a = new zn(this.currentPoint.clone(), new j(t, e), new j(i, n), new j(r, s));
                            return this.curves.push(a), this.currentPoint.set(r, s), this
                        }
                        splineThru(t) {
                            const e = [this.currentPoint.clone()].concat(t),
                                i = new Vn(e);
                            return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this
                        }
                        arc(t, e, i, n, r, s) {
                            const a = this.currentPoint.x,
                                o = this.currentPoint.y;
                            return this.absarc(t + a, e + o, i, n, r, s), this
                        }
                        absarc(t, e, i, n, r, s) {
                            return this.absellipse(t, e, i, i, n, r, s), this
                        }
                        ellipse(t, e, i, n, r, s, a, o) {
                            const l = this.currentPoint.x,
                                h = this.currentPoint.y;
                            return this.absellipse(t + l, e + h, i, n, r, s, a, o), this
                        }
                        absellipse(t, e, i, n, r, s, a, o) {
                            const l = new Rn(t, e, i, n, r, s, a, o);
                            if (this.curves.length > 0) {
                                const t = l.getPoint(0);
                                t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                            }
                            this.curves.push(l);
                            const h = l.getPoint(1);
                            return this.currentPoint.copy(h), this
                        }
                        copy(t) {
                            return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.currentPoint = this.currentPoint.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                        }
                    }
                    class jn extends Je {
                        constructor(t = [new j(0, -.5), new j(.5, 0), new j(0, .5)], e = 12, i = 0, n = 2 * Math.PI) {
                            super(), this.type = "LatheGeometry", this.parameters = {
                                points: t,
                                segments: e,
                                phiStart: i,
                                phiLength: n
                            }, e = Math.floor(e), n = V(n, 0, 2 * Math.PI);
                            const r = [],
                                s = [],
                                a = [],
                                o = [],
                                l = [],
                                h = 1 / e,
                                c = new dt,
                                u = new j,
                                d = new dt,
                                p = new dt,
                                m = new dt;
                            let f = 0,
                                g = 0;
                            for (let e = 0; e <= t.length - 1; e++) switch (e) {
                                case 0:
                                    f = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, m.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                                    break;
                                case t.length - 1:
                                    o.push(m.x, m.y, m.z);
                                    break;
                                default:
                                    f = t[e + 1].x - t[e].x, g = t[e + 1].y - t[e].y, d.x = 1 * g, d.y = -f, d.z = 0 * g, p.copy(d), d.x += m.x, d.y += m.y, d.z += m.z, d.normalize(), o.push(d.x, d.y, d.z), m.copy(p)
                            }
                            for (let r = 0; r <= e; r++) {
                                const d = i + r * h * n,
                                    p = Math.sin(d),
                                    m = Math.cos(d);
                                for (let i = 0; i <= t.length - 1; i++) {
                                    c.x = t[i].x * p, c.y = t[i].y, c.z = t[i].x * m, s.push(c.x, c.y, c.z), u.x = r / e, u.y = i / (t.length - 1), a.push(u.x, u.y);
                                    const n = o[3 * i + 0] * p,
                                        h = o[3 * i + 1],
                                        d = o[3 * i + 0] * m;
                                    l.push(n, h, d)
                                }
                            }
                            for (let i = 0; i < e; i++)
                                for (let e = 0; e < t.length - 1; e++) {
                                    const n = e + i * t.length,
                                        s = n,
                                        a = n + t.length,
                                        o = n + t.length + 1,
                                        l = n + 1;
                                    r.push(s, a, l), r.push(o, l, a)
                                }
                            this.setIndex(r), this.setAttribute("position", new Ve(s, 3)), this.setAttribute("uv", new Ve(a, 2)), this.setAttribute("normal", new Ve(l, 3))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new jn(t.points, t.segments, t.phiStart, t.phiLength)
                        }
                    }
                    class Xn extends jn {
                        constructor(t = 1, e = 1, i = 4, n = 8) {
                            const r = new Wn;
                            r.absarc(0, -e / 2, t, 1.5 * Math.PI, 0), r.absarc(0, e / 2, t, 0, .5 * Math.PI), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
                                radius: t,
                                length: e,
                                capSegments: i,
                                radialSegments: n
                            }
                        }
                        static fromJSON(t) {
                            return new Xn(t.radius, t.length, t.capSegments, t.radialSegments)
                        }
                    }
                    class qn extends Je {
                        constructor(t = 1, e = 32, i = 16, n = 0, r = 2 * Math.PI, s = 0, a = Math.PI) {
                            super(), this.type = "SphereGeometry", this.parameters = {
                                radius: t,
                                widthSegments: e,
                                heightSegments: i,
                                phiStart: n,
                                phiLength: r,
                                thetaStart: s,
                                thetaLength: a
                            }, e = Math.max(3, Math.floor(e)), i = Math.max(2, Math.floor(i));
                            const o = Math.min(s + a, Math.PI);
                            let l = 0;
                            const h = [],
                                c = new dt,
                                u = new dt,
                                d = [],
                                p = [],
                                m = [],
                                f = [];
                            for (let d = 0; d <= i; d++) {
                                const g = [],
                                    v = d / i;
                                let _ = 0;
                                0 === d && 0 === s ? _ = .5 / e : d === i && o === Math.PI && (_ = -.5 / e);
                                for (let i = 0; i <= e; i++) {
                                    const o = i / e;
                                    c.x = -t * Math.cos(n + o * r) * Math.sin(s + v * a), c.y = t * Math.cos(s + v * a), c.z = t * Math.sin(n + o * r) * Math.sin(s + v * a), p.push(c.x, c.y, c.z), u.copy(c).normalize(), m.push(u.x, u.y, u.z), f.push(o + _, 1 - v), g.push(l++)
                                }
                                h.push(g)
                            }
                            for (let t = 0; t < i; t++)
                                for (let n = 0; n < e; n++) {
                                    const e = h[t][n + 1],
                                        r = h[t][n],
                                        a = h[t + 1][n],
                                        l = h[t + 1][n + 1];
                                    (0 !== t || s > 0) && d.push(e, r, l), (t !== i - 1 || o < Math.PI) && d.push(r, a, l)
                                }
                            this.setIndex(d), this.setAttribute("position", new Ve(p, 3)), this.setAttribute("normal", new Ve(m, 3)), this.setAttribute("uv", new Ve(f, 2))
                        }
                        copy(t) {
                            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                        }
                        static fromJSON(t) {
                            return new qn(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
                        }
                    }

                    function Yn(t, e, i) {
                        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    }

                    function Jn(t) {
                        const e = t.length,
                            i = new Array(e);
                        for (let t = 0; t !== e; ++t) i[t] = t;
                        return i.sort((function(e, i) {
                            return t[e] - t[i]
                        })), i
                    }

                    function Zn(t, e, i) {
                        const n = t.length,
                            r = new t.constructor(n);
                        for (let s = 0, a = 0; a !== n; ++s) {
                            const n = i[s] * e;
                            for (let i = 0; i !== e; ++i) r[a++] = t[n + i]
                        }
                        return r
                    }

                    function Kn(t, e, i, n) {
                        let r = 1,
                            s = t[0];
                        for (; void 0 !== s && void 0 === s[n];) s = t[r++];
                        if (void 0 === s) return;
                        let a = s[n];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do {
                                    a = s[n], void 0 !== a && (e.push(s.time), i.push.apply(i, a)), s = t[r++]
                                } while (void 0 !== s);
                            else if (void 0 !== a.toArray)
                            do {
                                a = s[n], void 0 !== a && (e.push(s.time), a.toArray(i, i.length)), s = t[r++]
                            } while (void 0 !== s);
                        else
                            do {
                                a = s[n], void 0 !== a && (e.push(s.time), i.push(a)), s = t[r++]
                            } while (void 0 !== s)
                    }
                    class Qn {
                        constructor(t, e, i, n) {
                            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
                        }
                        evaluate(t) {
                            const e = this.parameterPositions;
                            let i = this._cachedIndex,
                                n = e[i],
                                r = e[i - 1];
                            t: {
                                e: {
                                    let s;i: {
                                        n: if (!(t < n)) {
                                            for (let s = i + 2;;) {
                                                if (void 0 === n) {
                                                    if (t < r) break n;
                                                    return i = e.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                                                }
                                                if (i === s) break;
                                                if (r = n, n = e[++i], t < n) break e
                                            }
                                            s = e.length;
                                            break i
                                        }if (t >= r) break t;
                                        {
                                            const a = e[1];
                                            t < a && (i = 2, r = a);
                                            for (let s = i - 2;;) {
                                                if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                                if (i === s) break;
                                                if (n = r, r = e[--i - 1], t >= r) break e
                                            }
                                            s = i, i = 0
                                        }
                                    }
                                    for (; i < s;) {
                                        const n = i + s >>> 1;
                                        t < e[n] ? s = n : i = n + 1
                                    }
                                    if (n = e[i], r = e[i - 1], void 0 === r) return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                    if (void 0 === n) return i = e.length,
                                    this._cachedIndex = i,
                                    this.copySampleValue_(i - 1)
                                }
                                this._cachedIndex = i,
                                this.intervalChanged_(i, r, n)
                            }
                            return this.interpolate_(i, r, t, n)
                        }
                        getSettings_() {
                            return this.settings || this.DefaultSettings_
                        }
                        copySampleValue_(t) {
                            const e = this.resultBuffer,
                                i = this.sampleValues,
                                n = this.valueSize,
                                r = t * n;
                            for (let t = 0; t !== n; ++t) e[t] = i[r + t];
                            return e
                        }
                        interpolate_() {
                            throw new Error("call to abstract method")
                        }
                        intervalChanged_() {}
                    }
                    class $n extends Qn {
                        constructor(t, e, i, n) {
                            super(t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                                endingStart: T,
                                endingEnd: T
                            }
                        }
                        intervalChanged_(t, e, i) {
                            const n = this.parameterPositions;
                            let r = t - 2,
                                s = t + 1,
                                a = n[r],
                                o = n[s];
                            if (void 0 === a) switch (this.getSettings_().endingStart) {
                                case E:
                                    r = t, a = 2 * e - i;
                                    break;
                                case C:
                                    r = n.length - 2, a = e + n[r] - n[r + 1];
                                    break;
                                default:
                                    r = t, a = i
                            }
                            if (void 0 === o) switch (this.getSettings_().endingEnd) {
                                case E:
                                    s = t, o = 2 * i - e;
                                    break;
                                case C:
                                    s = 1, o = i + n[1] - n[0];
                                    break;
                                default:
                                    s = t - 1, o = e
                            }
                            const l = .5 * (i - e),
                                h = this.valueSize;
                            this._weightPrev = l / (e - a), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = s * h
                        }
                        interpolate_(t, e, i, n) {
                            const r = this.resultBuffer,
                                s = this.sampleValues,
                                a = this.valueSize,
                                o = t * a,
                                l = o - a,
                                h = this._offsetPrev,
                                c = this._offsetNext,
                                u = this._weightPrev,
                                d = this._weightNext,
                                p = (i - e) / (n - e),
                                m = p * p,
                                f = m * p,
                                g = -u * f + 2 * u * m - u * p,
                                v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                                _ = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                                y = d * f - d * m;
                            for (let t = 0; t !== a; ++t) r[t] = g * s[h + t] + v * s[l + t] + _ * s[o + t] + y * s[c + t];
                            return r
                        }
                    }
                    class tr extends Qn {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                        interpolate_(t, e, i, n) {
                            const r = this.resultBuffer,
                                s = this.sampleValues,
                                a = this.valueSize,
                                o = t * a,
                                l = o - a,
                                h = (i - e) / (n - e),
                                c = 1 - h;
                            for (let t = 0; t !== a; ++t) r[t] = s[l + t] * c + s[o + t] * h;
                            return r
                        }
                    }
                    class er extends Qn {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                        interpolate_(t) {
                            return this.copySampleValue_(t - 1)
                        }
                    }
                    class ir {
                        constructor(t, e, i, n) {
                            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                            this.name = t, this.times = Yn(e, this.TimeBufferType), this.values = Yn(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
                        }
                        static toJSON(t) {
                            const e = t.constructor;
                            let i;
                            if (e.toJSON !== this.toJSON) i = e.toJSON(t);
                            else {
                                i = {
                                    name: t.name,
                                    times: Yn(t.times, Array),
                                    values: Yn(t.values, Array)
                                };
                                const e = t.getInterpolation();
                                e !== t.DefaultInterpolation && (i.interpolation = e)
                            }
                            return i.type = t.ValueTypeName, i
                        }
                        InterpolantFactoryMethodDiscrete(t) {
                            return new er(this.times, this.values, this.getValueSize(), t)
                        }
                        InterpolantFactoryMethodLinear(t) {
                            return new tr(this.times, this.values, this.getValueSize(), t)
                        }
                        InterpolantFactoryMethodSmooth(t) {
                            return new $n(this.times, this.values, this.getValueSize(), t)
                        }
                        setInterpolation(t) {
                            let e;
                            switch (t) {
                                case S:
                                    e = this.InterpolantFactoryMethodDiscrete;
                                    break;
                                case w:
                                    e = this.InterpolantFactoryMethodLinear;
                                    break;
                                case A:
                                    e = this.InterpolantFactoryMethodSmooth
                            }
                            if (void 0 === e) {
                                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                                if (void 0 === this.createInterpolant) {
                                    if (t === this.DefaultInterpolation) throw new Error(e);
                                    this.setInterpolation(this.DefaultInterpolation)
                                }
                                return console.warn("THREE.KeyframeTrack:", e), this
                            }
                            return this.createInterpolant = e, this
                        }
                        getInterpolation() {
                            switch (this.createInterpolant) {
                                case this.InterpolantFactoryMethodDiscrete:
                                    return S;
                                case this.InterpolantFactoryMethodLinear:
                                    return w;
                                case this.InterpolantFactoryMethodSmooth:
                                    return A
                            }
                        }
                        getValueSize() {
                            return this.values.length / this.times.length
                        }
                        shift(t) {
                            if (0 !== t) {
                                const e = this.times;
                                for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
                            }
                            return this
                        }
                        scale(t) {
                            if (1 !== t) {
                                const e = this.times;
                                for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
                            }
                            return this
                        }
                        trim(t, e) {
                            const i = this.times,
                                n = i.length;
                            let r = 0,
                                s = n - 1;
                            for (; r !== n && i[r] < t;) ++r;
                            for (; - 1 !== s && i[s] > e;) --s;
                            if (++s, 0 !== r || s !== n) {
                                r >= s && (s = Math.max(s, 1), r = s - 1);
                                const t = this.getValueSize();
                                this.times = i.slice(r, s), this.values = this.values.slice(r * t, s * t)
                            }
                            return this
                        }
                        validate() {
                            let t = !0;
                            const e = this.getValueSize();
                            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                            const i = this.times,
                                n = this.values,
                                r = i.length;
                            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                            let s = null;
                            for (let e = 0; e !== r; e++) {
                                const n = i[e];
                                if ("number" == typeof n && isNaN(n)) {
                                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), t = !1;
                                    break
                                }
                                if (null !== s && s > n) {
                                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, s), t = !1;
                                    break
                                }
                                s = n
                            }
                            if (void 0 !== n && (a = n, ArrayBuffer.isView(a) && !(a instanceof DataView)))
                                for (let e = 0, i = n.length; e !== i; ++e) {
                                    const i = n[e];
                                    if (isNaN(i)) {
                                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, i), t = !1;
                                        break
                                    }
                                }
                            var a;
                            return t
                        }
                        optimize() {
                            const t = this.times.slice(),
                                e = this.values.slice(),
                                i = this.getValueSize(),
                                n = this.getInterpolation() === A,
                                r = t.length - 1;
                            let s = 1;
                            for (let a = 1; a < r; ++a) {
                                let r = !1;
                                const o = t[a];
                                if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                                    if (n) r = !0;
                                    else {
                                        const t = a * i,
                                            n = t - i,
                                            s = t + i;
                                        for (let a = 0; a !== i; ++a) {
                                            const i = e[t + a];
                                            if (i !== e[n + a] || i !== e[s + a]) {
                                                r = !0;
                                                break
                                            }
                                        }
                                    } if (r) {
                                    if (a !== s) {
                                        t[s] = t[a];
                                        const n = a * i,
                                            r = s * i;
                                        for (let t = 0; t !== i; ++t) e[r + t] = e[n + t]
                                    }++s
                                }
                            }
                            if (r > 0) {
                                t[s] = t[r];
                                for (let t = r * i, n = s * i, a = 0; a !== i; ++a) e[n + a] = e[t + a];
                                ++s
                            }
                            return s !== t.length ? (this.times = t.slice(0, s), this.values = e.slice(0, s * i)) : (this.times = t, this.values = e), this
                        }
                        clone() {
                            const t = this.times.slice(),
                                e = this.values.slice(),
                                i = new(0, this.constructor)(this.name, t, e);
                            return i.createInterpolant = this.createInterpolant, i
                        }
                    }
                    ir.prototype.TimeBufferType = Float32Array, ir.prototype.ValueBufferType = Float32Array, ir.prototype.DefaultInterpolation = w;
                    class nr extends ir {
                        constructor(t, e, i) {
                            super(t, e, i)
                        }
                    }
                    nr.prototype.ValueTypeName = "bool", nr.prototype.ValueBufferType = Array, nr.prototype.DefaultInterpolation = S, nr.prototype.InterpolantFactoryMethodLinear = void 0, nr.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class rr extends ir {}
                    rr.prototype.ValueTypeName = "color";
                    class sr extends ir {}
                    sr.prototype.ValueTypeName = "number";
                    class ar extends Qn {
                        constructor(t, e, i, n) {
                            super(t, e, i, n)
                        }
                        interpolate_(t, e, i, n) {
                            const r = this.resultBuffer,
                                s = this.sampleValues,
                                a = this.valueSize,
                                o = (i - e) / (n - e);
                            let l = t * a;
                            for (let t = l + a; l !== t; l += 4) ut.slerpFlat(r, 0, s, l - a, s, l, o);
                            return r
                        }
                    }
                    class or extends ir {
                        InterpolantFactoryMethodLinear(t) {
                            return new ar(this.times, this.values, this.getValueSize(), t)
                        }
                    }
                    or.prototype.ValueTypeName = "quaternion", or.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class lr extends ir {
                        constructor(t, e, i) {
                            super(t, e, i)
                        }
                    }
                    lr.prototype.ValueTypeName = "string", lr.prototype.ValueBufferType = Array, lr.prototype.DefaultInterpolation = S, lr.prototype.InterpolantFactoryMethodLinear = void 0, lr.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class hr extends ir {}
                    hr.prototype.ValueTypeName = "vector";
                    class cr {
                        constructor(t = "", e = -1, i = [], n = 2500) {
                            this.name = t, this.tracks = i, this.duration = e, this.blendMode = n, this.uuid = k(), this.duration < 0 && this.resetDuration()
                        }
                        static parse(t) {
                            const e = [],
                                i = t.tracks,
                                n = 1 / (t.fps || 1);
                            for (let t = 0, r = i.length; t !== r; ++t) e.push(ur(i[t]).scale(n));
                            const r = new this(t.name, t.duration, e, t.blendMode);
                            return r.uuid = t.uuid, r
                        }
                        static toJSON(t) {
                            const e = [],
                                i = t.tracks,
                                n = {
                                    name: t.name,
                                    duration: t.duration,
                                    tracks: e,
                                    uuid: t.uuid,
                                    blendMode: t.blendMode
                                };
                            for (let t = 0, n = i.length; t !== n; ++t) e.push(ir.toJSON(i[t]));
                            return n
                        }
                        static CreateFromMorphTargetSequence(t, e, i, n) {
                            const r = e.length,
                                s = [];
                            for (let t = 0; t < r; t++) {
                                let a = [],
                                    o = [];
                                a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
                                const l = Jn(a);
                                a = Zn(a, 1, l), o = Zn(o, 1, l), n || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new sr(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / i))
                            }
                            return new this(t, -1, s)
                        }
                        static findByName(t, e) {
                            let i = t;
                            if (!Array.isArray(t)) {
                                const e = t;
                                i = e.geometry && e.geometry.animations || e.animations
                            }
                            for (let t = 0; t < i.length; t++)
                                if (i[t].name === e) return i[t];
                            return null
                        }
                        static CreateClipsFromMorphTargetSequences(t, e, i) {
                            const n = {},
                                r = /^([\w-]*?)([\d]+)$/;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e],
                                    s = i.name.match(r);
                                if (s && s.length > 1) {
                                    const t = s[1];
                                    let e = n[t];
                                    e || (n[t] = e = []), e.push(i)
                                }
                            }
                            const s = [];
                            for (const t in n) s.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
                            return s
                        }
                        static parseAnimation(t, e) {
                            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                            const i = function(t, e, i, n, r) {
                                    if (0 !== i.length) {
                                        const s = [],
                                            a = [];
                                        Kn(i, s, a, n), 0 !== s.length && r.push(new t(e, s, a))
                                    }
                                },
                                n = [],
                                r = t.name || "default",
                                s = t.fps || 30,
                                a = t.blendMode;
                            let o = t.length || -1;
                            const l = t.hierarchy || [];
                            for (let t = 0; t < l.length; t++) {
                                const r = l[t].keys;
                                if (r && 0 !== r.length)
                                    if (r[0].morphTargets) {
                                        const t = {};
                                        let e;
                                        for (e = 0; e < r.length; e++)
                                            if (r[e].morphTargets)
                                                for (let i = 0; i < r[e].morphTargets.length; i++) t[r[e].morphTargets[i]] = -1;
                                        for (const i in t) {
                                            const t = [],
                                                s = [];
                                            for (let n = 0; n !== r[e].morphTargets.length; ++n) {
                                                const n = r[e];
                                                t.push(n.time), s.push(n.morphTarget === i ? 1 : 0)
                                            }
                                            n.push(new sr(".morphTargetInfluence[" + i + "]", t, s))
                                        }
                                        o = t.length * s
                                    } else {
                                        const s = ".bones[" + e[t].name + "]";
                                        i(hr, s + ".position", r, "pos", n), i(or, s + ".quaternion", r, "rot", n), i(hr, s + ".scale", r, "scl", n)
                                    }
                            }
                            return 0 === n.length ? null : new this(r, o, n, a)
                        }
                        resetDuration() {
                            let t = 0;
                            for (let e = 0, i = this.tracks.length; e !== i; ++e) {
                                const i = this.tracks[e];
                                t = Math.max(t, i.times[i.times.length - 1])
                            }
                            return this.duration = t, this
                        }
                        trim() {
                            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                            return this
                        }
                        validate() {
                            let t = !0;
                            for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                            return t
                        }
                        optimize() {
                            for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                            return this
                        }
                        clone() {
                            const t = [];
                            for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                            return new this.constructor(this.name, this.duration, t, this.blendMode)
                        }
                        toJSON() {
                            return this.constructor.toJSON(this)
                        }
                    }

                    function ur(t) {
                        if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        const e = function(t) {
                            switch (t.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return sr;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return hr;
                                case "color":
                                    return rr;
                                case "quaternion":
                                    return or;
                                case "bool":
                                case "boolean":
                                    return nr;
                                case "string":
                                    return lr
                            }
                            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                        }(t.type);
                        if (void 0 === t.times) {
                            const e = [],
                                i = [];
                            Kn(t.keys, e, i, "value"), t.times = e, t.values = i
                        }
                        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                    }
                    const dr = {
                        enabled: !1,
                        files: {},
                        add: function(t, e) {
                            !1 !== this.enabled && (this.files[t] = e)
                        },
                        get: function(t) {
                            if (!1 !== this.enabled) return this.files[t]
                        },
                        remove: function(t) {
                            delete this.files[t]
                        },
                        clear: function() {
                            this.files = {}
                        }
                    };
                    class pr {
                        constructor(t, e, i) {
                            const n = this;
                            let r, s = !1,
                                a = 0,
                                o = 0;
                            const l = [];
                            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                                o++, !1 === s && void 0 !== n.onStart && n.onStart(t, a, o), s = !0
                            }, this.itemEnd = function(t) {
                                a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (s = !1, void 0 !== n.onLoad && n.onLoad())
                            }, this.itemError = function(t) {
                                void 0 !== n.onError && n.onError(t)
                            }, this.resolveURL = function(t) {
                                return r ? r(t) : t
                            }, this.setURLModifier = function(t) {
                                return r = t, this
                            }, this.addHandler = function(t, e) {
                                return l.push(t, e), this
                            }, this.removeHandler = function(t) {
                                const e = l.indexOf(t);
                                return -1 !== e && l.splice(e, 2), this
                            }, this.getHandler = function(t) {
                                for (let e = 0, i = l.length; e < i; e += 2) {
                                    const i = l[e],
                                        n = l[e + 1];
                                    if (i.global && (i.lastIndex = 0), i.test(t)) return n
                                }
                                return null
                            }
                        }
                    }
                    const mr = new pr;
                    class fr {
                        constructor(t) {
                            this.manager = void 0 !== t ? t : mr, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                        }
                        load() {}
                        loadAsync(t, e) {
                            const i = this;
                            return new Promise((function(n, r) {
                                i.load(t, n, e, r)
                            }))
                        }
                        parse() {}
                        setCrossOrigin(t) {
                            return this.crossOrigin = t, this
                        }
                        setWithCredentials(t) {
                            return this.withCredentials = t, this
                        }
                        setPath(t) {
                            return this.path = t, this
                        }
                        setResourcePath(t) {
                            return this.resourcePath = t, this
                        }
                        setRequestHeader(t) {
                            return this.requestHeader = t, this
                        }
                    }
                    fr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                    const gr = {};
                    class vr extends Error {
                        constructor(t, e) {
                            super(t), this.response = e
                        }
                    }
                    class _r extends fr {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                            const r = dr.get(t);
                            if (void 0 !== r) return this.manager.itemStart(t), setTimeout((() => {
                                e && e(r), this.manager.itemEnd(t)
                            }), 0), r;
                            if (void 0 !== gr[t]) return void gr[t].push({
                                onLoad: e,
                                onProgress: i,
                                onError: n
                            });
                            gr[t] = [], gr[t].push({
                                onLoad: e,
                                onProgress: i,
                                onError: n
                            });
                            const s = new Request(t, {
                                    headers: new Headers(this.requestHeader),
                                    credentials: this.withCredentials ? "include" : "same-origin"
                                }),
                                a = this.mimeType,
                                o = this.responseType;
                            fetch(s).then((e => {
                                if (200 === e.status || 0 === e.status) {
                                    if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                                    const i = gr[t],
                                        n = e.body.getReader(),
                                        r = e.headers.get("X-File-Size") || e.headers.get("Content-Length"),
                                        s = r ? parseInt(r) : 0,
                                        a = 0 !== s;
                                    let o = 0;
                                    const l = new ReadableStream({
                                        start(t) {
                                            ! function e() {
                                                n.read().then((({
                                                    done: n,
                                                    value: r
                                                }) => {
                                                    if (n) t.close();
                                                    else {
                                                        o += r.byteLength;
                                                        const n = new ProgressEvent("progress", {
                                                            lengthComputable: a,
                                                            loaded: o,
                                                            total: s
                                                        });
                                                        for (let t = 0, e = i.length; t < e; t++) {
                                                            const e = i[t];
                                                            e.onProgress && e.onProgress(n)
                                                        }
                                                        t.enqueue(r), e()
                                                    }
                                                }), (e => {
                                                    t.error(e)
                                                }))
                                            }()
                                        }
                                    });
                                    return new Response(l)
                                }
                                throw new vr(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                            })).then((t => {
                                switch (o) {
                                    case "arraybuffer":
                                        return t.arrayBuffer();
                                    case "blob":
                                        return t.blob();
                                    case "document":
                                        return t.text().then((t => (new DOMParser).parseFromString(t, a)));
                                    case "json":
                                        return t.json();
                                    default:
                                        if (void 0 === a) return t.text();
                                        {
                                            const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                                i = e && e[1] ? e[1].toLowerCase() : void 0,
                                                n = new TextDecoder(i);
                                            return t.arrayBuffer().then((t => n.decode(t)))
                                        }
                                }
                            })).then((e => {
                                dr.add(t, e);
                                const i = gr[t];
                                delete gr[t];
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    n.onLoad && n.onLoad(e)
                                }
                            })).catch((e => {
                                const i = gr[t];
                                if (void 0 === i) throw this.manager.itemError(t), e;
                                delete gr[t];
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    n.onError && n.onError(e)
                                }
                                this.manager.itemError(t)
                            })).finally((() => {
                                this.manager.itemEnd(t)
                            })), this.manager.itemStart(t)
                        }
                        setResponseType(t) {
                            return this.responseType = t, this
                        }
                        setMimeType(t) {
                            return this.mimeType = t, this
                        }
                    }
                    class yr extends fr {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                            const r = this,
                                s = dr.get(t);
                            if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                                e && e(s), r.manager.itemEnd(t)
                            }), 0), s;
                            const a = Y("img");

                            function o() {
                                h(), dr.add(t, this), e && e(this), r.manager.itemEnd(t)
                            }

                            function l(e) {
                                h(), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                            }

                            function h() {
                                a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                            }
                            return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                        }
                    }
                    class xr extends fr {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = this,
                                s = new mn,
                                a = new _r(this.manager);
                            return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(t, (function(t) {
                                let i;
                                try {
                                    i = r.parse(t)
                                } catch (t) {
                                    if (void 0 === n) return void console.error(t);
                                    n(t)
                                }
                                void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width, s.image.height = i.height, s.image.data = i.data), s.wrapS = void 0 !== i.wrapS ? i.wrapS : m, s.wrapT = void 0 !== i.wrapT ? i.wrapT : m, s.magFilter = void 0 !== i.magFilter ? i.magFilter : g, s.minFilter = void 0 !== i.minFilter ? i.minFilter : g, s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.colorSpace && (s.colorSpace = i.colorSpace), void 0 !== i.flipY && (s.flipY = i.flipY), void 0 !== i.format && (s.format = i.format), void 0 !== i.type && (s.type = i.type), void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps, s.minFilter = v), 1 === i.mipmapCount && (s.minFilter = g), void 0 !== i.generateMipmaps && (s.generateMipmaps = i.generateMipmaps), s.needsUpdate = !0, e && e(s, i)
                            }), i, n), s
                        }
                    }
                    class Mr extends fr {
                        constructor(t) {
                            super(t)
                        }
                        load(t, e, i, n) {
                            const r = new ht,
                                s = new yr(this.manager);
                            return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                                r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                            }), i, n), r
                        }
                    }
                    class br {
                        static decodeText(t) {
                            if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), "undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                            let e = "";
                            for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                            try {
                                return decodeURIComponent(escape(e))
                            } catch (t) {
                                return e
                            }
                        }
                        static extractUrlBase(t) {
                            const e = t.lastIndexOf("/");
                            return -1 === e ? "./" : t.slice(0, e + 1)
                        }
                        static resolveURL(t, e) {
                            return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                        }
                    }
                    class Sr {
                        constructor(t, e, i) {
                            let n, r, s;
                            switch (this.binding = t, this.valueSize = i, e) {
                                case "quaternion":
                                    n = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                                    break;
                                case "string":
                                case "bool":
                                    n = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                                    break;
                                default:
                                    n = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
                            }
                            this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                        }
                        accumulate(t, e) {
                            const i = this.buffer,
                                n = this.valueSize,
                                r = t * n + n;
                            let s = this.cumulativeWeight;
                            if (0 === s) {
                                for (let t = 0; t !== n; ++t) i[r + t] = i[t];
                                s = e
                            } else {
                                s += e;
                                const t = e / s;
                                this._mixBufferRegion(i, r, 0, t, n)
                            }
                            this.cumulativeWeight = s
                        }
                        accumulateAdditive(t) {
                            const e = this.buffer,
                                i = this.valueSize,
                                n = i * this._addIndex;
                            0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), this.cumulativeWeightAdditive += t
                        }
                        apply(t) {
                            const e = this.valueSize,
                                i = this.buffer,
                                n = t * e + e,
                                r = this.cumulativeWeight,
                                s = this.cumulativeWeightAdditive,
                                a = this.binding;
                            if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                                const t = e * this._origIndex;
                                this._mixBufferRegion(i, n, t, 1 - r, e)
                            }
                            s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
                            for (let t = e, r = e + e; t !== r; ++t)
                                if (i[t] !== i[t + e]) {
                                    a.setValue(i, n);
                                    break
                                }
                        }
                        saveOriginalState() {
                            const t = this.binding,
                                e = this.buffer,
                                i = this.valueSize,
                                n = i * this._origIndex;
                            t.getValue(e, n);
                            for (let t = i, r = n; t !== r; ++t) e[t] = e[n + t % i];
                            this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                        }
                        restoreOriginalState() {
                            const t = 3 * this.valueSize;
                            this.binding.setValue(this.buffer, t)
                        }
                        _setAdditiveIdentityNumeric() {
                            const t = this._addIndex * this.valueSize,
                                e = t + this.valueSize;
                            for (let i = t; i < e; i++) this.buffer[i] = 0
                        }
                        _setAdditiveIdentityQuaternion() {
                            this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                        }
                        _setAdditiveIdentityOther() {
                            const t = this._origIndex * this.valueSize,
                                e = this._addIndex * this.valueSize;
                            for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
                        }
                        _select(t, e, i, n, r) {
                            if (n >= .5)
                                for (let n = 0; n !== r; ++n) t[e + n] = t[i + n]
                        }
                        _slerp(t, e, i, n) {
                            ut.slerpFlat(t, e, t, e, t, i, n)
                        }
                        _slerpAdditive(t, e, i, n, r) {
                            const s = this._workIndex * r;
                            ut.multiplyQuaternionsFlat(t, s, t, e, t, i), ut.slerpFlat(t, e, t, e, t, s, n)
                        }
                        _lerp(t, e, i, n, r) {
                            const s = 1 - n;
                            for (let a = 0; a !== r; ++a) {
                                const r = e + a;
                                t[r] = t[r] * s + t[i + a] * n
                            }
                        }
                        _lerpAdditive(t, e, i, n, r) {
                            for (let s = 0; s !== r; ++s) {
                                const r = e + s;
                                t[r] = t[r] + t[i + s] * n
                            }
                        }
                    }
                    const wr = "\\[\\]\\.:\\/",
                        Ar = new RegExp("[" + wr + "]", "g"),
                        Tr = "[^" + wr + "]",
                        Er = "[^" + wr.replace("\\.", "") + "]",
                        Cr = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Tr) + /(WCOD+)?/.source.replace("WCOD", Er) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Tr) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Tr) + "$"),
                        Rr = ["material", "materials", "bones", "map"];
                    class Pr {
                        constructor(t, e, i) {
                            this.path = e, this.parsedPath = i || Pr.parseTrackName(e), this.node = Pr.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                        static create(t, e, i) {
                            return t && t.isAnimationObjectGroup ? new Pr.Composite(t, e, i) : new Pr(t, e, i)
                        }
                        static sanitizeNodeName(t) {
                            return t.replace(/\s/g, "_").replace(Ar, "")
                        }
                        static parseTrackName(t) {
                            const e = Cr.exec(t);
                            if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                            const i = {
                                    nodeName: e[2],
                                    objectName: e[3],
                                    objectIndex: e[4],
                                    propertyName: e[5],
                                    propertyIndex: e[6]
                                },
                                n = i.nodeName && i.nodeName.lastIndexOf(".");
                            if (void 0 !== n && -1 !== n) {
                                const t = i.nodeName.substring(n + 1); - 1 !== Rr.indexOf(t) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = t)
                            }
                            if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                            return i
                        }
                        static findNode(t, e) {
                            if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                            if (t.skeleton) {
                                const i = t.skeleton.getBoneByName(e);
                                if (void 0 !== i) return i
                            }
                            if (t.children) {
                                const i = function(t) {
                                        for (let n = 0; n < t.length; n++) {
                                            const r = t[n];
                                            if (r.name === e || r.uuid === e) return r;
                                            const s = i(r.children);
                                            if (s) return s
                                        }
                                        return null
                                    },
                                    n = i(t.children);
                                if (n) return n
                            }
                            return null
                        }
                        _getValue_unavailable() {}
                        _setValue_unavailable() {}
                        _getValue_direct(t, e) {
                            t[e] = this.targetObject[this.propertyName]
                        }
                        _getValue_array(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
                        }
                        _getValue_arrayElement(t, e) {
                            t[e] = this.resolvedProperty[this.propertyIndex]
                        }
                        _getValue_toArray(t, e) {
                            this.resolvedProperty.toArray(t, e)
                        }
                        _setValue_direct(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }
                        _setValue_direct_setNeedsUpdate(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }
                        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_array(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                        }
                        _setValue_array_setNeedsUpdate(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }
                        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                            const i = this.resolvedProperty;
                            for (let n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_arrayElement(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }
                        _setValue_arrayElement_setNeedsUpdate(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }
                        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_fromArray(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }
                        _setValue_fromArray_setNeedsUpdate(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }
                        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _getValue_unbound(t, e) {
                            this.bind(), this.getValue(t, e)
                        }
                        _setValue_unbound(t, e) {
                            this.bind(), this.setValue(t, e)
                        }
                        bind() {
                            let t = this.node;
                            const e = this.parsedPath,
                                i = e.objectName,
                                n = e.propertyName;
                            let r = e.propertyIndex;
                            if (t || (t = Pr.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                            if (i) {
                                let n = e.objectIndex;
                                switch (i) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (let e = 0; e < t.length; e++)//=Math.floor((Math.random()*2.5)**2))//--baka的恶作剧而已
                                            if (t[e].name === n) {
                                                n = e;
                                                break
                                            } break;
                                    case "map":
                                        if ("map" in t) {
                                            t = t.map;
                                            break
                                        }
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                        t = t.material.map;
                                        break;
                                    default:
                                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[i]
                                }
                                if (void 0 !== n) {
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[n]
                                }
                            }
                            const s = t[n];
                            if (void 0 === s) {
                                const i = e.nodeName;
                                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", t)
                            }
                            let a = this.Versioning.None;
                            this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                            let o = this.BindingType.Direct;
                            if (void 0 !== r) {
                                if ("morphTargetInfluences" === n) {
                                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                                }
                                o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                            this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                        }
                        unbind() {
                            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                    }
                    Pr.Composite = class {
                        constructor(t, e, i) {
                            const n = i || Pr.parseTrackName(e);
                            this._targetGroup = t, this._bindings = t.subscribe_(e, n)
                        }
                        getValue(t, e) {
                            this.bind();
                            const i = this._targetGroup.nCachedObjects_,
                                n = this._bindings[i];
                            void 0 !== n && n.getValue(t, e)
                        }
                        setValue(t, e) {
                            const i = this._bindings;
                            for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
                        }
                        bind() {
                            const t = this._bindings;
                            for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                        }
                        unbind() {
                            const t = this._bindings;
                            for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                        }
                    }, Pr.prototype.BindingType = {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    }, Pr.prototype.Versioning = {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    }, Pr.prototype.GetterByBindingType = [Pr.prototype._getValue_direct, Pr.prototype._getValue_array, Pr.prototype._getValue_arrayElement, Pr.prototype._getValue_toArray], Pr.prototype.SetterByBindingTypeAndVersioning = [
                        [Pr.prototype._setValue_direct, Pr.prototype._setValue_direct_setNeedsUpdate, Pr.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                        [Pr.prototype._setValue_array, Pr.prototype._setValue_array_setNeedsUpdate, Pr.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                        [Pr.prototype._setValue_arrayElement, Pr.prototype._setValue_arrayElement_setNeedsUpdate, Pr.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                        [Pr.prototype._setValue_fromArray, Pr.prototype._setValue_fromArray_setNeedsUpdate, Pr.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                    ];
                    class Ir {
                        constructor(t, e, i = null, n = e.blendMode) {
                            this._mixer = t, this._clip = e, this._localRoot = i, this.blendMode = n;
                            const r = e.tracks,
                                s = r.length,
                                a = new Array(s),
                                o = {
                                    endingStart: T,
                                    endingEnd: T
                                };
                            for (let t = 0; t !== s; ++t) {
                                const e = r[t].createInterpolant(null);
                                a[t] = e, e.settings = o
                            }
                            this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                        }
                        play() {
                            return this._mixer._activateAction(this), this
                        }
                        stop() {
                            return this._mixer._deactivateAction(this), this.reset()
                        }
                        reset() {
                            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                        }
                        isRunning() {
                            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                        }
                        isScheduled() {
                            return this._mixer._isActiveAction(this)
                        }
                        startAt(t) {
                            return this._startTime = t, this
                        }
                        setLoop(t, e) {
                            return this.loop = t, this.repetitions = e, this
                        }
                        setEffectiveWeight(t) {
                            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                        }
                        getEffectiveWeight() {
                            return this._effectiveWeight
                        }
                        fadeIn(t) {
                            return this._scheduleFading(t, 0, 1)
                        }
                        fadeOut(t) {
                            return this._scheduleFading(t, 1, 0)
                        }
                        crossFadeFrom(t, e, i) {
                            if (t.fadeOut(e), this.fadeIn(e), i) {
                                const i = this._clip.duration,
                                    n = t._clip.duration,
                                    r = n / i,
                                    s = i / n;
                                t.warp(1, r, e), this.warp(s, 1, e)
                            }
                            return this
                        }
                        crossFadeTo(t, e, i) {
                            return t.crossFadeFrom(this, e, i)
                        }
                        stopFading() {
                            const t = this._weightInterpolant;
                            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                        }
                        setEffectiveTimeScale(t) {
                            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                        }
                        getEffectiveTimeScale() {
                            return this._effectiveTimeScale
                        }
                        setDuration(t) {
                            return this.timeScale = this._clip.duration / t, this.stopWarping()
                        }
                        syncWith(t) {
                            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                        }
                        halt(t) {
                            return this.warp(this._effectiveTimeScale, 0, t)
                        }
                        warp(t, e, i) {
                            const n = this._mixer,
                                r = n.time,
                                s = this.timeScale;
                            let a = this._timeScaleInterpolant;
                            null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
                            const o = a.parameterPositions,
                                l = a.sampleValues;
                            return o[0] = r, o[1] = r + i, l[0] = t / s, l[1] = e / s, this
                        }
                        stopWarping() {
                            const t = this._timeScaleInterpolant;
                            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                        }
                        getMixer() {
                            return this._mixer
                        }
                        getClip() {
                            return this._clip
                        }
                        getRoot() {
                            return this._localRoot || this._mixer._root
                        }
                        _update(t, e, i, n) {
                            if (!this.enabled) return void this._updateWeight(t);
                            const r = this._startTime;
                            if (null !== r) {
                                const n = (t - r) * i;
                                n < 0 || 0 === i ? e = 0 : (this._startTime = null, e = i * n)
                            }
                            e *= this._updateTimeScale(t);
                            const s = this._updateTime(e),
                                a = this._updateWeight(t);
                            if (a > 0) {
                                const t = this._interpolants,
                                    e = this._propertyBindings;
                                if (2501 === this.blendMode)
                                    for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(s), e[i].accumulateAdditive(a);
                                else
                                    for (let i = 0, r = t.length; i !== r; ++i) t[i].evaluate(s), e[i].accumulate(n, a)
                            }
                        }
                        _updateWeight(t) {
                            let e = 0;
                            if (this.enabled) {
                                e = this.weight;
                                const i = this._weightInterpolant;
                                if (null !== i) {
                                    const n = i.evaluate(t)[0];
                                    e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                                }
                            }
                            return this._effectiveWeight = e, e
                        }
                        _updateTimeScale(t) {
                            let e = 0;
                            if (!this.paused) {
                                e = this.timeScale;
                                const i = this._timeScaleInterpolant;
                                null !== i && (e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
                            }
                            return this._effectiveTimeScale = e, e
                        }
                        _updateTime(t) {
                            const e = this._clip.duration,
                                i = this.loop;
                            let n = this.time + t,
                                r = this._loopCount;
                            const s = 2202 === i;
                            if (0 === t) return -1 === r || !s || 1 & ~r ? n : e - n;
                            if (2200 === i) {
                                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                                t: {
                                    if (n >= e) n = e;
                                    else {
                                        if (!(n < 0)) {
                                            this.time = n;
                                            break t
                                        }
                                        n = 0
                                    }
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    this.time = n,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t < 0 ? -1 : 1
                                    })
                                }
                            } else {
                                if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), n >= e || n < 0) {
                                    const i = Math.floor(n / e);
                                    n -= e * i, r += Math.abs(i);
                                    const a = this.repetitions - r;
                                    if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = t > 0 ? e : 0, this.time = n, this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t > 0 ? 1 : -1
                                    });
                                    else {
                                        if (1 === a) {
                                            const e = t < 0;
                                            this._setEndings(e, !e, s)
                                        } else this._setEndings(!1, !1, s);
                                        this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                                            type: "loop",
                                            action: this,
                                            loopDelta: i
                                        })
                                    }
                                } else this.time = n;
                                if (s && !(1 & ~r)) return e - n
                            }
                            return n
                        }
                        _setEndings(t, e, i) {
                            const n = this._interpolantSettings;
                            i ? (n.endingStart = E, n.endingEnd = E) : (n.endingStart = t ? this.zeroSlopeAtStart ? E : T : C, n.endingEnd = e ? this.zeroSlopeAtEnd ? E : T : C)
                        }
                        _scheduleFading(t, e, i) {
                            const n = this._mixer,
                                r = n.time;
                            let s = this._weightInterpolant;
                            null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
                            const a = s.parameterPositions,
                                o = s.sampleValues;
                            return a[0] = r, o[0] = e, a[1] = r + t, o[1] = i, this
                        }
                    }
                    const Lr = new Float32Array(1);
                    class Ur extends z {
                        constructor(t) {
                            super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                        }
                        _bindAction(t, e) {
                            const i = t._localRoot || this._root,
                                n = t._clip.tracks,
                                r = n.length,
                                s = t._propertyBindings,
                                a = t._interpolants,
                                o = i.uuid,
                                l = this._bindingsByRootAndName;
                            let h = l[o];
                            void 0 === h && (h = {}, l[o] = h);
                            for (let t = 0; t !== r; ++t) {
                                const r = n[t],
                                    l = r.name;
                                let c = h[l];
                                if (void 0 !== c) ++c.referenceCount, s[t] = c;
                                else {
                                    if (c = s[t], void 0 !== c) {
                                        null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, o, l));
                                        continue
                                    }
                                    const n = e && e._propertyBindings[t].binding.parsedPath;
                                    c = new Sr(Pr.create(i, l, n), r.ValueTypeName, r.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, o, l), s[t] = c
                                }
                                a[t].resultBuffer = c.buffer
                            }
                        }
                        _activateAction(t) {
                            if (!this._isActiveAction(t)) {
                                if (null === t._cacheIndex) {
                                    const e = (t._localRoot || this._root).uuid,
                                        i = t._clip.uuid,
                                        n = this._actionsByClip[i];
                                    this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                                }
                                const e = t._propertyBindings;
                                for (let t = 0, i = e.length; t !== i; ++t) {
                                    const i = e[t];
                                    0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState())
                                }
                                this._lendAction(t)
                            }
                        }
                        _deactivateAction(t) {
                            if (this._isActiveAction(t)) {
                                const e = t._propertyBindings;
                                for (let t = 0, i = e.length; t !== i; ++t) {
                                    const i = e[t];
                                    0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                                }
                                this._takeBackAction(t)
                            }
                        }
                        _initMemoryManager() {
                            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                            const t = this;
                            this.stats = {
                                actions: {
                                    get total() {
                                        return t._actions.length
                                    },
                                    get inUse() {
                                        return t._nActiveActions
                                    }
                                },
                                bindings: {
                                    get total() {
                                        return t._bindings.length
                                    },
                                    get inUse() {
                                        return t._nActiveBindings
                                    }
                                },
                                controlInterpolants: {
                                    get total() {
                                        return t._controlInterpolants.length
                                    },
                                    get inUse() {
                                        return t._nActiveControlInterpolants
                                    }
                                }
                            }
                        }
                        _isActiveAction(t) {
                            const e = t._cacheIndex;
                            return null !== e && e < this._nActiveActions
                        }
                        _addInactiveAction(t, e, i) {
                            const n = this._actions,
                                r = this._actionsByClip;
                            let s = r[e];
                            if (void 0 === s) s = {
                                knownActions: [t],
                                actionByRoot: {}
                            }, t._byClipCacheIndex = 0, r[e] = s;
                            else {
                                const e = s.knownActions;
                                t._byClipCacheIndex = e.length, e.push(t)
                            }
                            t._cacheIndex = n.length, n.push(t), s.actionByRoot[i] = t
                        }
                        _removeInactiveAction(t) {
                            const e = this._actions,
                                i = e[e.length - 1],
                                n = t._cacheIndex;
                            i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                            const r = t._clip.uuid,
                                s = this._actionsByClip,
                                a = s[r],
                                o = a.knownActions,
                                l = o[o.length - 1],
                                h = t._byClipCacheIndex;
                            l._byClipCacheIndex = h, o[h] = l, o.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(t)
                        }
                        _removeInactiveBindingsForAction(t) {
                            const e = t._propertyBindings;
                            for (let t = 0, i = e.length; t !== i; ++t) {
                                const i = e[t];
                                0 == --i.referenceCount && this._removeInactiveBinding(i)
                            }
                        }
                        _lendAction(t) {
                            const e = this._actions,
                                i = t._cacheIndex,
                                n = this._nActiveActions++,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _takeBackAction(t) {
                            const e = this._actions,
                                i = t._cacheIndex,
                                n = --this._nActiveActions,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _addInactiveBinding(t, e, i) {
                            const n = this._bindingsByRootAndName,
                                r = this._bindings;
                            let s = n[e];
                            void 0 === s && (s = {}, n[e] = s), s[i] = t, t._cacheIndex = r.length, r.push(t)
                        }
                        _removeInactiveBinding(t) {
                            const e = this._bindings,
                                i = t.binding,
                                n = i.rootNode.uuid,
                                r = i.path,
                                s = this._bindingsByRootAndName,
                                a = s[n],
                                o = e[e.length - 1],
                                l = t._cacheIndex;
                            o._cacheIndex = l, e[l] = o, e.pop(), delete a[r], 0 === Object.keys(a).length && delete s[n]
                        }
                        _lendBinding(t) {
                            const e = this._bindings,
                                i = t._cacheIndex,
                                n = this._nActiveBindings++,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _takeBackBinding(t) {
                            const e = this._bindings,
                                i = t._cacheIndex,
                                n = --this._nActiveBindings,
                                r = e[n];
                            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                        }
                        _lendControlInterpolant() {
                            const t = this._controlInterpolants,
                                e = this._nActiveControlInterpolants++;
                            let i = t[e];
                            return void 0 === i && (i = new tr(new Float32Array(2), new Float32Array(2), 1, Lr), i.__cacheIndex = e, t[e] = i), i
                        }
                        _takeBackControlInterpolant(t) {
                            const e = this._controlInterpolants,
                                i = t.__cacheIndex,
                                n = --this._nActiveControlInterpolants,
                                r = e[n];
                            t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
                        }
                        clipAction(t, e, i) {
                            const n = e || this._root,
                                r = n.uuid;
                            let s = "string" == typeof t ? cr.findByName(n, t) : t;
                            const a = null !== s ? s.uuid : t,
                                o = this._actionsByClip[a];
                            let l = null;
                            if (void 0 === i && (i = null !== s ? s.blendMode : 2500), void 0 !== o) {
                                const t = o.actionByRoot[r];
                                if (void 0 !== t && t.blendMode === i) return t;
                                l = o.knownActions[0], null === s && (s = l._clip)
                            }
                            if (null === s) return null;
                            const h = new Ir(this, s, e, i);
                            return this._bindAction(h, l), this._addInactiveAction(h, a, r), h
                        }
                        existingAction(t, e) {
                            const i = e || this._root,
                                n = i.uuid,
                                r = "string" == typeof t ? cr.findByName(i, t) : t,
                                s = r ? r.uuid : t,
                                a = this._actionsByClip[s];
                            return void 0 !== a && a.actionByRoot[n] || null
                        }
                        stopAllAction() {
                            const t = this._actions;
                            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                            return this
                        }
                        update(t) {
                            t *= this.timeScale;
                            const e = this._actions,
                                i = this._nActiveActions,
                                n = this.time += t,
                                r = Math.sign(t),
                                s = this._accuIndex ^= 1;
                            for (let a = 0; a !== i; ++a) e[a]._update(n, t, r, s);
                            const a = this._bindings,
                                o = this._nActiveBindings;
                            for (let t = 0; t !== o; ++t) a[t].apply(s);
                            return this
                        }
                        setTime(t) {
                            this.time = 0;
                            for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                            return this.update(t)
                        }
                        getRoot() {
                            return this._root
                        }
                        uncacheClip(t) {
                            const e = this._actions,
                                i = t.uuid,
                                n = this._actionsByClip,
                                r = n[i];
                            if (void 0 !== r) {
                                const t = r.knownActions;
                                for (let i = 0, n = t.length; i !== n; ++i) {
                                    const n = t[i];
                                    this._deactivateAction(n);
                                    const r = n._cacheIndex,
                                        s = e[e.length - 1];
                                    n._cacheIndex = null, n._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(n)
                                }
                                delete n[i]
                            }
                        }
                        uncacheRoot(t) {
                            const e = t.uuid,
                                i = this._actionsByClip;
                            for (const t in i) {
                                const n = i[t].actionByRoot[e];
                                void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                            }
                            const n = this._bindingsByRootAndName[e];
                            if (void 0 !== n)
                                for (const t in n) {
                                    const e = n[t];
                                    e.restoreOriginalState(), this._removeInactiveBinding(e)
                                }
                        }
                        uncacheAction(t, e) {
                            const i = this.existingAction(t, e);
                            null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                        }
                    }
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                        detail: {
                            revision: "168"
                        }
                    })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "168")
                }
            },
            e = {};

        function i(n) {
            var r = e[n];
            if (void 0 !== r) return r.exports;
            var s = e[n] = {
                exports: {}
            };
            return t[n](s, s.exports, i), s.exports
        }
        return i.d = (t, e) => {
            for (var n in e) i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, {
                enumerable: !0,
                get: e[n]
            })
        }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i(822)
    })()));
//# sourceMappingURL=webgl_loader_mmd_audio.js.map